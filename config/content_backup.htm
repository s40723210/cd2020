<h1>Weeks</h1>
<p><a href="https://s40723210.github.io/cd2020/content/Week1-5.html">Week1-5</a></p>
<p><a href="https://s40723210.github.io/cd2020/content/Week6-9.html">Week6-9</a></p>
<p><a href="https://s40723210.github.io/cd2020/content/Week10-14.html">Week10-14</a></p>
<p><a href="https://s40723210.github.io/cd2020/content/Week15-18.html">Week15-18</a></p>
<hr/>
<p>倉儲網址:<a href="https://github.com/s40723210/cd2020" title="https://github.com/s40723210/cd2020">https://github.com/s40723210/cd2020</a></p>
<p>youtube:<a href="https://www.youtube.com/channel/UC8l7lxn3l0ENuxYDhLjgxRw">https://www.youtube.com/channel/UC8l7lxn3l0ENuxYDhLjgxRw</a></p>
<p>分組倉儲網址:<a href="https://s40723210.github.io/cd2020bg4" title="https://s40723210.github.io/cd2020bg4">https://s40723210.github.io/cd2020bg4</a></p>
<p><span>gitter : </span><a href="https://gitter.im/40723210/cd2020">https://gitter.im/40723210/cd2020</a></p>
<h2>Week1-5</h2>
<h4 class="post-title entry-title" itemprop="name"><strong>建立個人cd2020倉儲</strong></h4>
<p><span>1.下載<a href="https://drive.google.com/file/d/1fxMdqdCoCL__O1IpZ-Sv-A_4-c77Wx4E/view?usp=sharing">2019Fall可攜套件.7z</a>，完成後開啟start。</span><span><br/></span><span></span><span><span>2.先登入自己的github帳號，</span><span>創建一個新的倉儲cd2020。</span></span><span><span><br/></span><span>3.進入要存放該資料的資料夾tmp。</span></span><span><span><br/></span></span><span></span><span><span>4.git clone </span><span>https://github.com/s40723210/cd2020 。</span><span><br/></span><span>5.</span><span>git submodule add https://github.com/mdecourse/cmsimde.git。</span></span><span><span><br/>6.再進入cmsimde，將up_dir的所有項目複<span>製到cd2020</span>。</span></span><span><span><br/>7.完成後，python wsgi.py 開始編輯倉儲。<br/></span></span><span><span>8.login密碼為admin，gitconfig要有帳號密碼。</span></span><span><span><br/>9.處理完，git status &gt; git add . &gt; git commit -m "標題" &gt; git push。</span></span><span><span><br/>10.開啟github倉儲設定，點選要推送的branch即可。<br/></span></span></p>
<p><span>我的教學影片:<a href="https://youtu.be/jBFzju1F43s">https://youtu.be/jBFzju1F43s<br/><br/><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/jBFzju1F43s" width="560"></iframe></a></span></p>
<hr color="00ffee"/>
<h4><strong>Updated Python 3.8.2</strong></h4>
<p>1.從Python<a href="https://www.python.org/">官方網站</a>，下載3.8.2版本的<a href="https://www.python.org/ftp/python/3.8.2/python-3.8.2.exe">安裝檔</a>。</p>
<p>2.完成後開啟，點選<span>Customize installation(定制安裝)。</span></p>
<p>3.將第二個選項的pip取消勾選，其他都可以勾選起來。</p>
<p>4.使用預設勾選，將路徑改為y槽的py382資料夾(自己創建)。</p>
<p>5.用編輯器來開啟<span>start_mdecourse.bat檔案。</span></p>
<p>6.<span>將</span><span>檔中的py373全部都改成py382後，重新啟動。</span></p>
<p>7.直接在y槽中執行，python <span>get-pip.py 來安裝pip軟件。</span></p>
<p><span>8.完成之後，來安裝軟件包，輸入python pip install <span style="color: #ff0000;">Flask</span> 依此類推。</span></p>
<p>9.安裝的有<span style="color: #ff0000;">Flask</span>、<span style="color: #ff0000;">Markdown</span>、<span style="color: #ff0000;">lxml</span>、<span style="color: #ff0000;">bs4</span>、<span style="color: #ff0000;">flask_cors</span>、<span style="color: #ff0000;">pelican</span>、<span style="color: #ff0000;">leo</span>。</p>
<p>我的教學影片:<a class="style-scope ytcp-video-share-dialog" href="https://youtu.be/Im6e8ZD1-Xo" id="watch-url" target="_blank">https://youtu.be/Im6e8ZD1-Xo</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/Im6e8ZD1-Xo" width="560"></iframe></p>
<hr color="00ffee"/>
<h4><strong>分配工作和問題討論</strong></h4>
<p>40623115 亂數分組程式<br/>40623251 可攜系統<br/>40723204 可攜系統<br/>42723210 四輪車<br/>40723212 四輪車<br/>40723225 四輪車<br/>40723232 亂數分組程式<br/>40723234 可攜系統<br/>40723238 四輪車<br/>40723245 亂數分組程式<br/>40723250 亂數分組程式</p>
<p>負責各主題的人，主要以課堂上的進度，來更新個人的倉儲，每次更新進度時要做一下紀錄。所有的主題必須要在<span>2020年3月26日之前完成，提交3-5頁的兩欄pdf報告，並在youtube上保存3-5分鐘的影片，將pdf文件放在個人倉儲 downloads / assignment1.pdf。最後整合的作業以assignment1放在自己的網站連結加/ assignment1內。有問題可以在我的 <a href="https://gitter.im/40723210/cd2020">gitter</a> 以及 老師的 <a href="https://gitter.im/mdecourse/cd2020">gitter</a> 上面發問，會的人也可以幫忙回答。<br/></span><br/>直播影片:<a href="https://www.youtube.com/watch?v=r0AABAp474U">https://www.youtube.com/watch?v=r0AABAp474U</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/r0AABAp474U" width="560"></iframe></p>
<hr color="00ffee"/>
<h4>New pull request</h4>
<p>1.先登入github，點進去想要fork的倉儲。<br/><br/>2.點選右上角的Fork，再選擇自己的github。<br/><br/>3.git clone --recurse-submodules (倉儲網址)。<br/><br/>4.更新git push完成，點選New pull request，等組長同意。<br/><br/>5.組員要進行更新時，要記得先git pull (分組網址) 檢查版本。<br/><br/>6.有衝突的話，組長要處理和整合分支並且解決衝突。<br/><br/>我的教學影片:<a href="https://youtu.be/1bZ16BgmF8c">https://youtu.be/1bZ16BgmF8c</a><a href="https://youtu.be/1bZ16BgmF8c"></a></p>
<p><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/1bZ16BgmF8c" width="560"></iframe></p>
<hr color="00ffee"/>
<h4 class="title style-scope ytd-video-primary-info-renderer"><yt-formatted-string class="style-scope ytd-video-primary-info-renderer" force-default-style="">V-rep可動四輪車</yt-formatted-string></h4>
<p>使用內建功能來創建模型，並且模擬最基本的直線移動。</p>
<p>影片連結:<a href="https://youtu.be/y8DJ1sjuAqM">https://youtu.be/y8DJ1sjuAqM</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/y8DJ1sjuAqM" width="560"></iframe></p>
<h2>Week6-9</h2>
<h4>直播會議Assignment 2</h4>
<p>分工表:</p>
<table style="width: 333.6px;">
<tbody>
<tr>
<td style="width: 173px; text-align: center;"><strong>Topic 1:</strong></td>
<td style="width: 158.6px; text-align: center;"><strong>Topic 0:</strong></td>
</tr>
<tr>
<td style="width: 173px; text-align: center;">40623115</td>
<td style="width: 158.6px; text-align: center;">40723232</td>
</tr>
<tr>
<td style="width: 173px; text-align: center;">40623251</td>
<td style="width: 158.6px; text-align: center;">40723234</td>
</tr>
<tr>
<td style="width: 173px; text-align: center;">40723204</td>
<td style="width: 158.6px; text-align: center;">40723238</td>
</tr>
<tr>
<td style="width: 173px; text-align: center;">42723210</td>
<td style="width: 158.6px; text-align: center;">40723245</td>
</tr>
<tr>
<td style="width: 173px; text-align: center;">40723212</td>
<td style="width: 158.6px; text-align: center;">40723250</td>
</tr>
<tr>
<td style="width: 173px; text-align: center;">40723225</td>
<td style="width: 158.6px; text-align: center;"></td>
</tr>
</tbody>
</table>
<p><br/>Topic 1 的文章很長，自己看要翻哪一大章節都可，Topic 0 有兩篇pdf也是一樣自己決定，要全翻也行自己斟酌。最後是個人網頁要有assignment2，downloads裡面也要有檔案assignment2.pdf。作業期限到4/23，要自行檢查是否完成所有內容。</p>
<p><span>直播影片:<a href="https://youtu.be/a69tNWKmC64">https://youtu.be/a69tNWKmC64</a></span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/a69tNWKmC64" width="560"></iframe></span></p>
<hr color="00ffee"/>
<h4>webcam 畫面製作</h4>
<p>老師要求每個人之後的影片，都必須要有視訊畫面，所以要準備一台webcam ，但是需要花錢買，我們可以使用手機來代替webcam，就是使用<a href="https://www.e2esoft.com/ivcam/">iVcam</a>來進行畫面製作，電腦以及手機都要下載，至於obs與iVcam連線可以參考下方的影片。</p>
<p>教學影片連結:<a href="https://youtu.be/YCAGt9qku6I">https://youtu.be/YCAGt9qku6I</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/YCAGt9qku6I" width="560"></iframe></p>
<hr color="00ffee"/>
<h4>V-rep bubbleRob Tutorial</h4>
<p>操作影片連結:<a href="https://youtu.be/BStp8J-KXuY">https://youtu.be/BStp8J-KXuY</a></p>
<div><span><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/BStp8J-KXuY" width="560"></iframe><br/><br/></span></div>
<hr color="00ffee"/>
<h4 class="title style-scope ytd-video-primary-info-renderer"><yt-formatted-string class="style-scope ytd-video-primary-info-renderer" force-default-style="">V-rep 馬達驅動四輪車</yt-formatted-string></h4>
<p>使用內建功能來創建模型，並且模擬最基本馬達的直線移動。</p>
<p>影片連結:<a href="https://youtu.be/y8DJ1sjuAqM">https://youtu.be/y8DJ1sjuAqM</a></p>
<p><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/y8DJ1sjuAqM" width="560"></iframe></p>
<hr color="00ffee"/>
<h4 class="title style-scope ytd-video-primary-info-renderer"><yt-formatted-string class="style-scope ytd-video-primary-info-renderer" force-default-style="">四輪車鍵盤控制轉向</yt-formatted-string></h4>
<p>V-rep 檔案連結: <a href="/downloads/4 wheel car keyboard.ttt">4 wheel car keyboard.ttt</a></p>
<p>四輪車加上轉向及鍵盤控制，先開啟之前做好的四輪車，將兩個前輪馬達複製貼上，再使兩個馬達原地轉向90度，創建兩個小正方體，位置與前輪一模一樣，<span>需要設定屬性避免與其他部件衝突，本體、輪子、小正方體都要關閉如下圖。</span></p>
<p><img alt="" height="136" src="/images/4 wheel car 本體干涉.PNG" width="371"/><br/><br/>將控制迴路啟用，來控制轉向的限制角度，兩個馬達都用預設即可，如下圖設定。<br/><br/><img alt="" height="431" src="/images/4 wheel car 轉向設定.PNG" width="377"/></p>
<p>將之前的馬達速度都關掉，<span>點擊馬達圖示視窗下的</span><span>show dynamic properties dialog</span><span>，把</span><span>motor properties的速度改為0</span><span>，底下的</span><span>lock motor when target velocity is zero是</span><span><span color="#000000">馬達速度為零時鎖定馬達，可開可不開。</span></span></p>
<p><span><span color="#000000"><img alt="" height="171" src="/images/4 wheel car 後輪馬達.PNG" width="380"/></span></span></p>
<p>最後把方塊拖移至對應馬達下，再整個放進本體下，把對應的前輪馬達放置方塊下，本體新增一個控制腳本，選擇cuboid，點擊菜單欄的Add &gt; Associated child script &gt; Threaded，將寫好的腳本複製貼上，更改前輪馬達的名子，這樣腳本才能控制，下圖為整個最終結構。<br/><br/><img alt="" height="355" src="/images/4 wheel car 結構.PNG" width="266"/></p>
<p><span style="color: #0000ff;"><strong>四輪車鍵盤控制轉向程式碼:</strong></span></p>
<pre class="brush:lua;auto-links:false;toolbar:false" contenteditable="false">-- This script is threaded! It is a very simple example of how Ackermann steering can be handled.
-- Normally, one would use a non-threaded script for that

threadFunction=function()
	while simGetSimulationState()~=sim_simulation_advancing_abouttostop do
		-- Read the keyboard messages (make sure the focus is on the main window, scene view):
		message,auxiliaryData=simGetSimulatorMessage()
		while message~=-1 do
			if (message==sim_message_keypress) then
				if (auxiliaryData[1]==2007) then
					-- up key
					desiredWheelRotSpeed=desiredWheelRotSpeed+wheelRotSpeedDx
				end
				if (auxiliaryData[1]==2008) then
					-- down key
					desiredWheelRotSpeed=desiredWheelRotSpeed-wheelRotSpeedDx
				end
				if (auxiliaryData[1]==2009) then
					-- left key
					desiredSteeringAngle=desiredSteeringAngle+steeringAngleDx
					if (desiredSteeringAngle&gt;45*math.pi/180) then
						desiredSteeringAngle=45*math.pi/180
					end
				end
				if (auxiliaryData[1]==2010) then
					-- right key
					desiredSteeringAngle=desiredSteeringAngle-steeringAngleDx
					if (desiredSteeringAngle&lt;-45*math.pi/180) then
						desiredSteeringAngle=-45*math.pi/180
					end
				end
			end
			message,auxiliaryData=simGetSimulatorMessage()
		end

		-- We handle the front left and right wheel steerings (Ackermann steering):
		steeringAngleLeft=math.atan(l/(-d+l/math.tan(desiredSteeringAngle)))
		steeringAngleRight=math.atan(l/(d+l/math.tan(desiredSteeringAngle)))
		simSetJointTargetPosition(steeringLeft,steeringAngleLeft)
		simSetJointTargetPosition(steeringRight,steeringAngleRight)

		-- We take care of setting the desired wheel rotation speed:
		simSetJointTargetVelocity(motorLeft,desiredWheelRotSpeed)
		simSetJointTargetVelocity(motorRight,desiredWheelRotSpeed)

		-- Since this script is threaded, don't waste time here:
		simSwitchThread() -- Resume the script at next simulation loop start
	end
end

-- Put some initialization code here:
-- Retrieving of some handles and setting of some initial values:
steeringLeft=simGetObjectHandle('Steer_left_joint')
steeringRight=simGetObjectHandle('Steer_right_joint')
motorLeft=simGetObjectHandle('Front_left_joint')
motorRight=simGetObjectHandle('Front_right_joint')
desiredSteeringAngle=0
desiredWheelRotSpeed=0
steeringAngleDx=2*math.pi/180
wheelRotSpeedDx=20*math.pi/180
d=0.755 -- 2*d=distance between left and right wheels
l=2.5772 -- l=distance between front and read wheels

-- Here we execute the regular thread code:
res,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)
if not res then
	simAddStatusbarMessage('Lua runtime error: '..err)
end

-- Put some clean-up code here:</pre>
<p><span><span color="#000000"></span></span>教學影片連結:<a href="https://youtu.be/0W1wmC1tr4A">https://youtu.be/0W1wmC1tr4A</a></p>
<p><span><strong><span color="#000000"><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/0W1wmC1tr4A" width="560"></iframe></span></strong></span><strong><span></span></strong></p>
<h1>Assignments</h1>
<p><span>報告連結:</span><a href="/downloads/assignment1.pdf">assignment1.pdf</a></p>
<h2>assignment1</h2>
<p>Due March 25, 2020 for class 2a and March 26, 2020 for class 2b.</p>
<ol>
<li>
<p>Describe how to do an efficient random grouping for this course or do the roll calling randomly?</p>
</li>
<li>
<p>Describe how to prepare a portable Python programming system for Windows 10 64bit system to allow one the maintain CMSiMDE website, Pelican blog and Reveal.js presentation on Github?</p>
</li>
<li>
<p>What do you need to know from<span> </span><a href="http://www.coppeliarobotics.com/helpFiles/index.html" rel="nofollow">http://www.coppeliarobotics.com/helpFiles/index.html</a><span> </span>to implement a four-wheeled robot?</p>
</li>
</ol>
<hr/>
<p>報告連結:<a href="/downloads/assignment1.pdf">assignment1.pdf</a></p>
<p><iframe height="700px" iframe="" src="https://s40723210.github.io/cd2020/downloads/assignment1.pdf" width="100%"></iframe></p>
<h3>Random grouping</h3>
<p>請描述如何針對該課程進行有效的隨機分組，或者隨機進行點名？</p>
<h4><strong>測試程式(點選程式連結再貼上即可):</strong></h4>
<p><iframe allowfullscreen="allowfullscreen" allowtransparency="true" frameborder="no" height="400px" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals" scrolling="no" src="https://repl.it/repls/LightLikelyDominspector?lite=true" width="100%"></iframe></p>
<h4><strong><span style="color: #0000ff;">抽查的python程式</span></strong></h4>
<p>如果要使用python來進行亂數分組抽查的話，可以導入random來從列表中隨機抽出所需要的n個不同元素，如下面的程式執行之後，就可以亂數抽出4位。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import random 

group = [4, 10, 12, 25, 32, 34, 38, 45, 50] 

team = random.sample(group, 4) 
print (team)</pre>
<p>再來是要讀取網頁資料的話，就要導入requests，使用get請求即可直接下載，例如member = requests.get("網址")，再用print(member.text)就可以印出來了如下。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import requests

web = "https://mdecourse.github.io/cd2020/downloads/2b_group_list.txt"

member = requests.get(web)

print(member.text)</pre>
<p>如果使用讀取出的資料，還是無法使用的，因為member.text的性質是str字串，所以我就要將它變回原本的list列表，才可以進行亂數分組，改這個非常的簡單如下。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">x = eval(member.text)</pre>
<p>最後我整理出來的程式，雖然沒有老師這麼精美，但是也是可以進行亂數分組的抽查的，如果要改抽查人數，改y = random.sample(i,2)的數字即可。</p>
<h4><span style="color: #ff6600;"><span color="#0000ff"><b>最終程式碼</b></span></span></h4>
<p>程式碼連結:<a href="https://github.com/s40723210/cd2020/blob/master/downloads/%E4%BA%82%E6%95%B8%E5%88%86%E7%B5%84.py" target="_blank">抽查程式.py</a></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import requests
import random
  
web = "https://mdecourse.github.io/cd2020/downloads/2b_group_list.txt"
member = requests.get(web)
#print(memder.text)
x=0
for i in eval(member.text):
    y = random.sample(i,2)
    x+=1
    print("group"+ str(x))
    print(y)</pre>
<h4><strong><span style="color: #0000ff;">亂數分組的的python程式</span></strong></h4>
<p><strong></strong>一開始先從網頁上抓人員，這次跟上面的不太一樣，抓出來的本來就是str字串，所以必須把每個學號轉變為<span>list列表，直接將f.text加上 .split() 來轉換，完成之後就可以使用，random.shuffle()來將整個順序打亂，再來設定一共要分幾組，再使用while迴圈來判斷每一組要有幾個人，使用if判斷是來中斷迴圈，len()是指一共有幾個數量的意思，要加組別的話就要再多寫一列，接著使用for 迴圈來從，剛剛算好的每組人數，例如:13、12、12、12，再使用一個for迴圈，來一個一個配置組人員，這時候直接使用迭代iter()的next()，來抓人員這樣子就不會重複了，最後再加上一些說明、分格、標題，就可以開始進行亂數分組了。</span></p>
<h4><span style="color: #ff6600;"><span color="#0000ff"><b>最終程式碼</b></span></span></h4>
<p>程式碼連結:<a arget="_blank" href="https://github.com/s40723210/cd2020/blob/master/downloads/%E4%BA%82%E6%95%B8%E5%88%86%E7%B5%84.py" t="">亂數分組.py</a></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import requests
import random

web = "http://s1.mde.nfu.edu.tw:8000/?semester=1082&amp;courseno=0780"
f = requests.get(web)
#print(type(f.text))
x = f.text.split()
#print(len(x))
#print(x)
random.shuffle(x)

group1,group2,group3,group4 = 0,0,0,0
while 1==1:
    group1 += 1
    if (group1+group2+group3+group4) == len(x):
        break
    group2 += 1
    if (group1+group2+group3+group4) == len(x):
        break
    group3 += 1
    if (group1+group2+group3+group4) == len(x):
        break
    group4 += 1
    if (group1+group2+group3+group4) == len(x):
        break
#print(group1,group2,group3,group4)

print("全班人數有"+str(len(x))+"人")
print("="*20)
grp_num = group1,group2,group3,group4
a = iter(x)
team = 0
for i in grp_num:
    team += 1
    print("group"+str(team)+" 共 "+str(i)+" 人")
    for g in range(i):
        print(next(a))
    print("-" * 20)</pre>
<p></p>
<h3>Portable system</h3>
<p>2.描述如何為Windows 10 64位系統準備一個可移植的Python編程系統，以允許在Github上維護CMSiMDE網站，Pelican博客和Reveal.js演示文稿？</p>
<p>要創造可攜編程系統，首先需要的是start.bat以及stop.bat，放進system資料夾(自行創建)後，然後再創建一個data數據目錄資料夾(一樣放進<span>system資料夾內</span>)。</p>
<hr/>
<p style="top: 1595.4px;">start.bat 存放在system資料夾下</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">@echo off
set Disk=y
subst %Disk%: "data"

%Disk%:

set HomePath=%Disk%:\home_mdecourse
set HomeDrive=%Disk%:\home_mdecourse
set Home=%Disk%:\home_mdecourse
set USERPROFILE=%Disk%:\home_mdecourse

REM 將系統 Python 程式的 io 設為 utf-8
set PYTHONIOENCODING="utf-8"

set PYTHONPATH=%Disk%:\py382\DLLs;%Disk%:\py382\Lib;%Disk%:\py382\Lib\site-packages;
set PYTHONHOME=%Disk%:\py382

set path_python=%Disk%:\py382;%Disk%:\py382\Scripts;
set path_msys2=%Disk%:\msys64\mingw64\bin;
set path_tcc=%Disk%:\tcc;
set path_git=%Disk%:\portablegit\bin;

set GIT_HOME=%Disk%:\portablegit\bin\
set GIT_SSH=%Disk%:\putty\plink.exe

path=%Disk%:;%path_python%;%path_msys2%;%path_tcc%;%path_git%;%path_cmake%;%path_coreutils%;%path%;

start /MIN cmd.exe
start /MIN cmd.exe
start /MIN cmd.exe

start /MIN %Disk%:\wscite432\wscite\SciTE.exe
start /MIN %Disk%:\wscite432\wscite\SciTE.exe

Exit</pre>
<p>stop.bat <span>存放在system資料夾下</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">@echo off
set Disk=y
path=%PATH%;

taskkill /IM python.exe /F
taskkill /IM pythonw.exe /F
taskkill /IM SciTE.exe /F
REM 終止虛擬硬碟與目錄的對應
subst %Disk%: /D
REM 關閉 cmd 指令視窗
taskkill /IM cmd.exe /F
EXIT</pre>
<div>
<div class="syntaxhighlighter html" id="highlighter_96320"></div>
</div>
<h4><span style="color: #ff9900;"><strong>data的資料夾內:</strong></span></h4>
<p>編輯器，使用<span>SciTE :</span> <a href="https://www.scintilla.org/SciTEDownload.html">https://www.scintilla.org/SciTEDownload.html</a></p>
<p>下載<span>Windows 64-bit:</span> <span><a href="https://www.scintilla.org/wscite432.zip">full 64-bit download</a></span>，放進<span>data</span>目錄裡的<span>wscite432資料夾(自己創建)，接著</span><span>開啟<span>SciTE.exe</span><span>，點選 </span><span>Options下的</span><span><span style="text-decoration: underline;">Open Global Options File</span><span> ，使用ctrl + f 來收尋code.page=0，將code.page=65001的#刪掉，這樣才不會出現亂碼。</span></span><br/></span></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">code.page=65001
#code.page=0</pre>
<p></p>
<hr/>
<p>Git控制軟體 :<span> <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></span></p>
<p>下載Windows 64-bit: <span><a href="https://github.com/git-for-windows/git/releases/download/v2.25.1.windows.1/Git-2.25.1-64-bit.exe">64-bit Git for Windows Setup</a></span>，放進<span>data</span>目錄裡面並且重新命名為<span>portablegit 。</span></p>
<hr/>
<p><span>ssh</span>連線工具組，使用的<span>putty : </span><span><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/">https://www.chiark.greenend.org.uk/~sgtatham/putty/</a></span></p>
<p>直接下載老師之前給的:<span><a href="https://drive.google.com/file/d/1ISq1TJuaZyYZnfU33l-b7ifzmO3ejlEV/view">putty.7z</a></span>，解壓縮放入<span>data</span>目錄就可以了。</p>
<hr/>
<p>MSYS2：<a href="https://www.msys2.org/">https://www.msys2.org/ </a></p>
<p>下載的是<a href="http://repo.msys2.org/distrib/x86_64/msys2-x86_64-20190524.exe">msys2-x86</a><span><a href="http://repo.msys2.org/distrib/x86_64/msys2-x86_64-20190524.exe">_64-20190524.exe</a></span> ，安裝在<span> data </span>目錄裡的<span>msys64資料夾(自己創建)</span>。</p>
<hr/>
<p>Tiny C Compiler : <a href="https://github.com/TinyCC/tinycc">https://github.com/TinyCC/tinycc</a></p>
<p>直接在<span>data </span>目錄下進行<span>git clone </span><span><a href="https://github.com/TinyCC/tinycc">https://github.com/TinyCC/tinycc</a></span>  tcc </p>
<hr/>
<p>把現在再用的home_mdecourse，整個複製到data 目錄下。</p>
<hr/>
<p>Python : <a href="https://www.python.org/">https://www.python.org/</a>，下載3.8.2版本的<a href="https://www.python.org/ftp/python/3.8.2/python-3.8.2.exe">安裝檔</a>。</p>
<p>1.完成後開啟，點選<span>Customize installation(定制安裝)。</span></p>
<p>2.將第二個選項的pip取消勾選，其他都可以勾選起來。</p>
<p>3.使用預設勾選，將路徑改為data內的py382資料夾(自己創建)。</p>
<p>4.直接在y槽中執行，python <span>get-pip.py 來安裝pip軟件。</span></p>
<p><span>5.完成之後，來安裝軟件包，輸入python pip install<span> </span><span>Flask</span> 依此類推。</span></p>
<p>6.安裝的有<span>Flask</span>、<span>Markdown</span>、<span>lxml</span>、<span>bs4</span>、<span>flask_cors</span>、<span>pelican</span>、<span>leo</span>。</p>
<hr/>
<p>data目錄下的所有資料:</p>
<p><img alt="" height="193" src="/images/explorer_2020-03-21_21-05-25.png" width="519"/></p>
<p><span>system資料夾內:</span></p>
<p><span><img alt="" height="107" src="/images/explorer_2020-03-21_21-44-29.png" width="491"/></span></p>
<p><span>這樣子就完成了最簡單的</span>可攜編程系統了。</p>
<h3>Four wheel car</h3>
<p>我們從<a href="https://www.coppeliarobotics.com/helpFiles/index.html">CoppeliaSim用戶手冊</a>中尋找有關於四輪機器人的文章，找到了幾個相關的文章，分別是<a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm" name="link194folder.9">BubbleRob tutorial</a>、<a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/lineFollowingBubbleRobTutorial.htm" name="link196folder.9">Line following BubbleRob tutorial</a>、<a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm" name="link199folder.9">External</a><a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm" name="link199folder.9"> controller tutorial</a>、<a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/simulation.htm" name="link184folder.7">Simulation</a><span style="color: #000000;">、</span><a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/simulationPropertiesDialog.htm" name="link185folder.7">Simulation dialog</a><span style="color: #000000;">，</span>一共五個有關四輪車的文章。</p>
<p>各篇翻譯:在本站<a href="https://s40723210.github.io/cd2020/content/CoppeliaSim.html">CoppeliaSim</a>下，重點及心得如下:</p>
<p><span><a href="https://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm">BubbleRob tutorial</a></span>:本章教程主要是透過，自己動手實際操作模擬，來了解許多功能以及<span>BubbleRob </span>機器人設置，我們上學期時就已經有親自使用<span>V-rep </span>來操作過一次了，本章使用了包括<span>:</span>基本形狀<span>(</span>機器人本體、輪子、障礙物<span>)</span>、感應器<span>(</span>接近型圓錐傳感器<span>)</span>、接頭或電動機<span>(</span>關節動力馬達<span>)</span>、力傳感器<span>(</span>滑塊<span>)</span>、圖表<span>(</span>運動軌跡<span>)</span>、腳本<span>(</span>模型定義<span>)</span>，使用以上這些功能，就可以實現<span>BubbleRob </span>機器人，能移動並且使用感應器，來感應障礙物，再使用腳本來迴避，最後再由圖表來顯示模擬路徑。</p>
<p><span><a href="https://www.coppeliarobotics.com/helpFiles/en/lineFollowingBubbleRobTutorial.htm">Line following BubbleRob tutorial</a></span>:這個教程是接續著上面的文章，可以使<span>BubbleRob </span>機器人按照規劃的路徑移動，讓我們可以有效的控制機器人，可以避免外部控制所產生的各種問題，這樣子就可以更快的達成需要的模擬狀況，可以提高不少的效率。</p>
<p><span><a href="https://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm">External controller tutorial</a></span>:本章屬於外部控制器的教程，讓我們可以使用遠端操控的方式，來控制四輪機器人，控制的方式有編寫腳本、編寫插件、遠程<span>API</span>、<span>ROS</span>節點、<span>BlueZero</span>節點、編寫外部應用程式，每種都要寫子腳本來進行鏈結。</p>
<p><span><a href="https://www.coppeliarobotics.com/helpFiles/en/simulation.htm">Simulation</a></span>:此教程為模擬案鍵，當我們建立好腳本時，就可以控制模擬的狀況，為了增加模擬的準確性，就可以使用仿真的速度與螺紋渲染，但是必須要適當的調整，才不會造成系統運行中斷。</p>
<p><span><a href="https://www.coppeliarobotics.com/helpFiles/en/simulationPropertiesDialog.htm">Simulation dialog</a></span>:此教程是上篇的進階設定，<strong>時間步</strong>為調整模擬時間，運行越快準確度越差，<strong>每幀模擬遍數</strong>為屏幕刷新速度，刷新越快得到的情報越快，只是電腦很吃效能，<strong>當仿真時間高於時暫停</strong>為允許特定仿真時間暫停，<strong>暫停腳本錯誤</strong>會在發生問題時暫停，<strong>模擬開始時全屏</strong>啟用時對話框和消息不會顯示，<strong>實時仿真-倍增係數</strong>使仿真運行快n倍，<strong>落後時嘗試趕上</strong>系統運行趕不上模擬時，會在低負載時趕上，<strong>復位場景初始狀態</strong>運行模擬結束時，所有設定將回歸初始狀態，<strong>刪除新對象</strong>模擬時，添加的東西將會在結束後移除，以上的各種設定，能讓我們在模擬時，更加的方便，進而提高許多效率。</p>
<h4 class="title style-scope ytd-video-primary-info-renderer"><yt-formatted-string class="style-scope ytd-video-primary-info-renderer" force-default-style="">V-rep可動四輪車</yt-formatted-string></h4>
<p>使用內建功能來創建模型，並且模擬最基本的直線移動。</p>
<p>影片連結:<a href="https://youtu.be/y8DJ1sjuAqM">https://youtu.be/y8DJ1sjuAqM</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/y8DJ1sjuAqM" width="560"></iframe></p>
<h2>assignment2</h2>
<p>Due April 22, 2020 for class 2a and April 23, 2020 for class 2b.</p>
<ol>
<li>
<p>According to the material of Topic 0 and Topic 1, can you describe specifically what the mechanical design team need to do for accomplishing Assignment 1's four wheeled robot.</p>
</li>
<li>
<p>What do you need to know from<span> </span><a href="https://cyberbotics.com/doc/guide/index" rel="nofollow">https://cyberbotics.com/doc/guide/index</a><span> </span>to implement a four-wheeled robot?</p>
</li>
</ol>
<hr/>
<p>報告連結:<a href="/downloads/assignment1.pdf">assignment1.pdf</a></p>
<p><iframe height="700px" iframe="" src="https://s40723210.github.io/cd2020/downloads/assignment.pdf" width="100%"></iframe></p>
<h3>DigitalProductCollaboration</h3>
<p>原文pdf連結:<a href="https://drive.google.com/open?id=1YHQwYduSMisiJQS-Jr_HhJghzIqP_SBc">DigitalProductCollaboration.pdf</a></p>
<p>翻譯連結:<a href="/downloads/DigitalProductCollaboration翻譯.pdf">DigitalProductCollaboration翻譯.pdf</a></p>
<h4><strong>協同設計更好的產品</strong></h4>
<p> 透過設計協調創作更好的產品<span> - </span>心態、工具、過程<span>  2019</span>年<span> 7</span>月<span> 10 </span>日</p>
<p> </p>
<p>現今的數位產品比以往都還要複雜。創建他們需要更多的團隊。每位成員都需要擁有自己的技藝與專業知識。例如<span>Savvy</span>，我們的顧客。需要與產品經理、<span>UX</span>設計師、視覺設計師、開發人員、內容策略師還有增長專家密切配合。</p>
<p> </p>
<p>我們藉由設計協同來處理這種複雜性。正確的設計協同可以讓每一位專家擁有思維、流程和工具來快速的建立更好的產品。</p>
<p> </p>
<p>我們撰寫這篇資源是為了幫助其他<span>APP</span>創作者採用文化偕同和流程。深入閱讀了解為何設計協同對於創作引人注目的產品和體驗來說非常重要</p>
<p> </p>
<h4><strong>什麼是設計協同<span>?</span></strong></h4>
<p> </p>
<p>在直接跳入主題前，我們需要了解什麼是設計協同<span>…</span>什麼不是。簡單來說，設計協同就是在以設計為主的環境中進行協同合作。但是，因為設計的本質，特別是在與<span>Savvy</span>合作的設計之中，設計協同往往會超出人們一般認為的合作範圍。</p>
<p> </p>
<p>協同一般被定義為兩個或更多的人一起為同樣的目標工作，然而設計協同所涉及的東西卻更多。</p>
<p> </p>
<p>設計協同包羅了更多具有不同技能的人、更艱困的挑戰、更大的目標並產生更深遠的影響</p>
<p> </p>
<p>你可能會認為協同就是兩個人懸掛一件藝術品，只需要溝通、團隊工作、和四隻手而已。設計合作是指由策劃團隊精心為參觀者設計的體驗，他們挑取藝術品並挑選掛在什麼地方、如何掛、掛在哪個房間<span>(</span>以及房間的燈光和家具<span>) </span>，甚至是前一個房間和整棟建築物。</p>
<p> </p>
<h4><strong>為什麼設計協同是重要的<span>?</span></strong></h4>
<p> </p>
<p>你可以在沒有協同的情況下設計出一件產品，但透過一個合作的設計過程可以讓產品變的更加優秀，這就是為什麼設計協同是如此的重要。</p>
<p> </p>
<p>我們並不只是為顧客構建應用程式，<span>Savvy</span>構建了多平台體驗、複雜的內部系統，並且在某些情況下，還可以構建整個品牌與業務，為此我們在戰略、設計、開發和成長等領域利用核心專業技術，每個項目都有許多人參加，每個人都有自己的技藝與專長。</p>
<p> </p>
<p>設計協同將這些人的思想概念結合在一起，將他們獨自的專業知識結合起來，創造出能夠解決共同目標所有方面問題的方案。設計協同不是從一個角度來解決一個問題，而是將所有問題放在專家面前，迫使他們考慮新的觀點與可能性。</p>
<p> </p>
<p>例如，我們在早期的設計過程就讓開翻人員參予進來，確保盡快解決技術問題與侷限性。這使我們能夠利用在推動技術能力過程時，進一步消除昂貴的路障。這也同時限制一個人在筒倉的工作量，保持工廠的開放性，將重點放在用戶需求與產品目標上。</p>
<p> </p>
<h4><strong>培養設計協同的心態</strong></h4>
<p> </p>
<p>正確的心態能幫助在設計過程中建立有效的合作關係，它為由誰來合作、如何合作以及合作的目的制定了準則。</p>
<p> </p>
<h4><strong>協同是人人都可以的</strong></h4>
<p> </p>
<p>設計師有時候會認為不是設計師的人是沒有資格給出好的反饋的。但是，好的設計是不僅僅有視覺效果而已的，它包含了一個產品的一切，從品牌到工程再到在到期發展的一切。</p>
<p> </p>
<p>設計協同引進了許多人，每個人都有其自己的觀點與優勢，它使每個人都可以擁有發言權，這些創新的視角給了設計師更多的信息。觀點可以讓設計師能夠做出正確的決定，這些選擇會對以後的設計、開發與營銷產生持久的引響。</p>
<p> </p>
<p>與客戶的合作和與其他設計師、團隊成員的合作同樣重要。在與<span>Savvy</span>的合作中，我們讓客戶參予產品的製作過程，並花時間解釋所選方案，與客戶進行討論，以確保我們了解他們的想法。</p>
<p> </p>
<p>這樣一來，我們就可以確保客戶的買帳並使工作有始有終，較大的揭露並不是什麼太大的驚喜，沒有人會因為第一次看到工作而感到驚訝。</p>
<p> </p>
<p>客戶的合作意味著更早產生一個確定的產品，避免了昂貴的迴避與不必要的會議。</p>
<p> </p>
<p>人們很容易沉浸在自己所扮演的角色中而忽略了大局關，透過讓更多的人在早期參與進來，就能將團隊成員之間的聯繫培養的更緊密，並培養出責任感與對產品是否能成功的興趣。你正在創造一個更開放、更透明的過程，以及一個更有聯繫和投入的團體。</p>
<p> </p>
<h4><strong>協同是有背景的</strong></h4>
<p> </p>
<p>客戶帶著複雜的挑戰與目標來尋找我們。更別提我們會持續與客戶合作數月甚至數年，累積了大量的知識，包含過去的決策、研究等其他有價值的背景。</p>
<p> </p>
<p>透過適者生存的方法，確保每個人都處於最高的知識水平。使他們能夠在開發產品的過程中能夠做出最明確的決定，為了能夠做到這一點，我們透過提前召集所有團隊成員，紀錄和紀錄會議的內容，建立一些重和點，並將下一個團隊成員視為顧客，讓<span>Savvy</span>團隊的每一個人都能及時了解相關資訊。</p>
<p> </p>
<p>在個案合作的基礎上，情境同樣重要，遵循這些準則，在合作中要把情境放在首位。</p>
<p> </p>
<p>在顯示您的工作之前提供上下文。在提供背景信息的情況下，如果您的作品出現在屏幕上，那麼您可能會失去聽眾的注意力。</p>
<p> </p>
<p>描述您要解決的問題或要達到的目標。</p>
<p> </p>
<p>介紹與當前問題相關的工作。說明您的想法以及做出某些決定的原因。</p>
<p> </p>
<p>請具體說明您要反饋的內容。</p>
<p> </p>
<h4><strong>合作是開放，誠實和無畏的</strong></h4>
<p> </p>
<p>將您的工作（和您自己）放在那裡並不容易。情緒會阻礙您提供坦誠的反饋，尤其是當您擔心會傷害對方的感受時。</p>
<p> </p>
<p>這並不意味著在協作中沒有情感的位置。在設計中，讓您感覺如何是很重要的。我們為人們思考並為他們創建解決方案，有情感並在決策中使用情感的人。在對話中留下的情感可能會縮短潛在的想法或解決方案。充其量，僅就事實和數據進行務實的討論將無法提供全面的信息。在最壞的情況下，它可能是掩人耳目或提供虛假的敘述。</p>
<p> </p>
<p>在與<span>Savvy</span>的合作中，我們使我們的團隊對收到反饋感到<span>“</span>無所畏懼<span>”</span>。這意味著放開對我們所創造的東西進行判斷不會感到任何焦慮。這也意味著我們在一起將會更加強大，更有機會創造偉大的事物。在無所畏懼的情況下，我們會更好地相互信任和相互賦予能力，以提供誠實和周到的反饋。</p>
<p> </p>
<p>我們的團隊還信奉無所畏懼地提供反饋。這意味著能夠了解需要解決的問題以及客戶的品牌和目標。同時也意味著可以問很多問題，以發現相關的思想或幫助指導決策。</p>
<p> </p>
<p>嘗試以探索性和指導性的方式提出反饋意見，目的是建立和改進工作，而不是拆散工作。</p>
<p> </p>
<p>您的反饋意見應具有建設性。與其說您不喜歡某些東西，不如說出您的反饋意見以指出您要幫助解決的問題。提供可行的步驟來改進工作，或者至少提供您思考背後的理由。並且不要忘了表達您喜歡什麼以及為什麼。</p>
<p> </p>
<h4><strong>合作不僅僅是新的想法</strong></h4>
<p> </p>
<p>開放並接受協作反饋是一回事，解析這些想法並將其用來催生您自己的想法是另一回事。隨著時間的推移，這是一項更高級的技能。實踐方法將成為更好的聽眾。</p>
<p> </p>
<p>通常，在與他人交談時，我們會更多地考慮接下來要說的內容，而不是別人在說什麼。這會影響反饋過程，尤其是在設計過程中，因為在聽到其他意見或解決方案之前，我們通常會知道我們要說的話。</p>
<p> </p>
<p>當您選擇先聆聽然後再做出反應時，它可以讓您完全理解其他人的反饋，並讓您更深入地了解自己<span> — </span>他們使用的觀點是什麼以及來自何處？很有可能這是您在創建過程中未曾考慮過的觀點。通過聽取並理解收到反饋時背後的上下文和推理，您可以以更多的方式來審視，思考和體驗設計。然後，您可以針對要設計的挑戰，目標和用例來測試這些新觀點，以查看它們是否更適合用戶。</p>
<p> </p>
<p>當所有協作者都在積極聆聽時，更容易接受反饋。最終，提供良好反饋的技能來自於學習如何獲得反饋。當我們努力成為更好的聽眾時，我們也發現自己變得更加謙虛，並認為我們是更好的設計師。</p>
<p> </p>
<p>尋找和使用正確的設計協作工具</p>
<p> </p>
<p>正確的工具在增強團隊的設計協作思維方面大有幫助。在本節中，您將學習在協作工具中尋找什麼。我們還根據自己的經驗推薦工具。</p>
<p> </p>
<h4><strong>選擇合適的工具</strong></h4>
<p> </p>
<p>有效的協作工具消除了協作者想要快速輕鬆地訪問工作並與之交互時的所有障礙。這將重點放在提供反饋上。它們還允許其他人在不破壞原始設計的情況下進行協作。</p>
<p> </p>
<p>過去，我們依賴於提供基本版本控製而不是真正的協作功能的工具。例如，設計人員將保存一個<span>Sketch</span>文件並將其上傳到<span>Dropbox</span>。然後，另一個團隊成員下載它，進行處理，然後重新上傳。當文件在另一個人手中時，沒有辦法用簡單的方法來進行更改。我們使用<span>Github</span>嘗試了類似的方法，該工具被證明非常適合管理代碼庫，但對於反覆設計的工作卻沒有太多幫助。不用說，這些版本控製過程使我們的協作更加耗時，混亂並且非常不協作。</p>
<p> </p>
<p>現在，我們根據要實現的協作類型從各種更高級的工具中進行選擇。</p>
<p> </p>
<h4><strong>設計工具<span>FIGMA</span></strong></h4>
<p> </p>
<p>這是一個以協作為優先的共享工作區工具。<span> Figma</span>非常適合在設計文件的同一區域中包含多個人。您可以時時觀看隊友的設計或在同一個設計上一起工作。</p>
<p> </p>
<p>Figma的好處：</p>
<p> </p>
<p>Figma降低了某人在筒倉中工作的能力。</p>
<p> </p>
<p>無需添加不必要的修飾或創建可交付結果的靜態即可實現協作。因此，您無需更改工作流程即可展示設計。</p>
<p> </p>
<p>可以輕鬆地在其本環境中查看並與之交互，並隨意進行調整。</p>
<p> </p>
<p>使用時：流程文檔，高保真線框，即時協作，以及引導客戶瀏覽一系列屏幕，以解釋並獲得有關設計方向的反饋。</p>
<p> </p>
<h4><strong>MARVEL app</strong><strong>軟體</strong></h4>
<p> </p>
<p>雖然<span>Figma</span>傾向於自由和靈活，但<span>Marvel</span>允許採用更標準化的協作形式。這也使我們的客戶可以輕鬆地與我們合作。</p>
<p> </p>
<p>Marvel的好處：</p>
<p> </p>
<p>Marvel是一個更簡潔、規範和專注的空間，非常適合與非設計團隊成員進行協作。</p>
<p> </p>
<p>它消除了客戶為帳戶付款或對工具進行深入了解的所有需求。</p>
<p> </p>
<p>客戶可以下載屏幕，並通過<span>Marvel</span>應用程序在設備環境中查看它們的運行情況。</p>
<p> </p>
<p>使用時：與客戶和開發人員一起呈現更多的最終設計工作。 （了解<span>Marvel</span>如何與其他原型工具進行比較。）</p>
<p> </p>
<h4><strong>其他合作工具</strong></h4>
<p> </p>
<p>Zeplin是一個有用的傳遞工具，使開發人員可以深入研究設計工作的細節。 （我們在這裡更深入地討論<span>Zeplin</span>。）</p>
<p> </p>
<p>Quip是集思廣益在產品<span>/</span>流程文件的絕佳平台。我們使用它來記錄和組織團隊成員在項目上需要了解的所有環境和知識。對於集思廣益新思路而不是視覺關注的新想法也很有用。</p>
<p> </p>
<p>請注意，還有許多其他工具可以為協作增加與上面類似的好處。此列表代表了在我們日常合作中對我們有效的工具，但並不表示所有可能對您的團隊有效的選項。</p>
<p> </p>
<p>精明的設計合作過程在實踐中</p>
<p> </p>
<p>現在，讓我們採用上面概述的最佳實踐和工具，並展示它們如何在現實生活中融合在一起。我們將使用<span>Press Play</span>應用程序中的實際繪圖經驗來演示設計協作的重要性。這種經驗涉及多個學科領域的團隊成員之間的重大協作，其中包括視覺設計師，<span>UX</span>設計人員，開發人員，產品經理，當然還有客戶。</p>
<p> </p>
<h4><strong>語境與挑戰</strong></h4>
<p> </p>
<p>Press Play是一個抽獎活動應用程序，可保存每日，每周和每月的圖紙。用戶通過觀看廣告賺取門票，並通過五個表情符號的選擇來輸入圖紙。然後，根據獲獎者的選擇與繪畫中隨機選擇的表情符號匹配的方式來獎勵獲獎者。這項特殊任務使我們為等待現場繪畫結果的用戶創造了一種有趣而激動人心的現場體驗。</p>
<p> </p>
<p>對於我們來說，為這種體驗創建類似遊戲的動畫非常重要。我們特別想在屏幕上喚起用戶的嬉戲感和期待感，讓用戶看到他們選擇的表情符號與抽獎活動圖上的表情符號相匹配。</p>
<p> </p>
<p>也就是說，我們需要注意動畫所需的複雜程度及其對整體產品時間表和成本的影響。我們的目標是在合理的時間內提高真實度，而又不顯著影響項目預算。</p>
<p> </p>
<h4><strong>合作的過程</strong></h4>
<p> </p>
<p>階段<span>1</span>：線框和自由討論</p>
<p> </p>
<p>首先，一位精明的<span>UX</span>設計師創建了<span>Press Play</span>的整體<span>UX</span>和線框，確定需要哪些屏幕以及每個屏幕的時間安排。她還為實時繪畫動畫整理了一個粗略的概念，根據客戶的需求和項目已建立的用戶體驗表達了初步的想法。</p>
<p> </p>
<p>她向產品經理和視覺設計師展示了線框和粗糙的動畫。然後這三個人都與客戶會面，因此每個人都可以直接聽到反饋。</p>
<p> </p>
<p>第二階段：研究與背景</p>
<p> </p>
<p>精明的視覺設計師負責創建實際的繪畫動畫，他們的眼睛新鮮，而且對<span>Press Play</span>產品沒有太多的了解。為了加快速度，他與<span>UX</span>設計師和產品經理進行了深入交流。他還花費額外的研究時間來了解總體產品目標，挑戰並熟悉迄今為止的工作。如前所述，他展示線框演示的一部分，並向客戶提出反饋。</p>
<p> </p>
<p>在這種情況下，他進行了一些與手頭任務直接相關的其他研究。通過這樣做，他確保自己了解現場繪畫體驗的要求、目標和挑戰。他查看了具有類似體驗和真實度的其他應用，並參考了粗糙的動畫以了解最終動畫到底需要顯示什麼（在這種情況下，是獲勝的表情符號和用戶的表情符號選擇）。在過於依賴解決方案之前，他會見了一位精明的<span>iOS</span>開發人員，以了解技術限制和注意事項。</p>
<p> </p>
<p>然後，我們的視覺設計師和<span>UX</span>設計師集思廣益，視覺效果非常重要。他們一致認為，需要慢慢進行透露，以便為用戶建立懸念<span>/</span>期待</p>
<p> </p>
<p>階段<span>3</span>：迭代和反饋</p>
<p> </p>
<p>當我們的視覺設計師沿多個不同方向工作時，他邀請了<span>UX</span>設計師來聊聊他在<span>Figma</span>中的進度和設計。通過討論工作，他們激發了更多的想法和迭代，同時確保它們符合客戶的期望。有了更多可靠的選擇，他再次與<span>iOS</span>開發人員會面，以確保從技術角度來看一切都符合要求。</p>
<p> </p>
<p>階段<span>4</span>：客戶的反饋和發展</p>
<p>當我們找到了幾種最終確定的體驗版本時，視覺設計師使用<span>Figma</span>與客戶一起瀏覽了它們。<span> Press Play</span>的產品經理和<span>UX</span>設計師也提供了反饋和指導。</p>
<p> </p>
<p>一旦他們都了解了會引起客戶興趣的東西，視覺設計師便開始著手讓視覺效果最大化，並為開發做好準備。他繼續與<span>iOS</span>開發人員合作，以在技術層面上充分利用該概念。</p>
<p> </p>
<h4><strong>最終結果</strong></h4>
<p> </p>
<p>Press Play的實際繪圖動畫是工作中設計協作的一個示例。一隊跨學科專家團隊，共同解決具有更大影響的設計和開發挑戰。沒有設計協作，我們將找不到用戶體驗，視覺和技術之間的理想交匯處。</p>
<p> </p>
<p>當客戶在他的應用程序中看到動畫是生動時，他稱其為<span>“</span>開創性的<span>”</span>。</p>
<p> </p>
<p>此外，對這種<span>Press Play</span>體驗的研究、協作和創造，幫助我們發現了產品用戶旅程中的空白。最初，實際繪圖的目的是將結果顯示給用戶的一種有趣的方式。在設計過程中，我們意識到，如果用戶不因為觀看實際圖形而迷失了方向，那麼他們就不會體驗到該圖形的用戶旅程。</p>
<p> </p>
<p>基於這一發現，我們決定在其他兩個地方也改進該應用程序。我們在<span>“</span>獲勝者圈子<span>”</span>中添加了一個結果<span>/</span>實際繪圖元素，並在應用程序的<span>“</span>用戶詳細信息<span>”</span>端添加了<span>“</span>輸贏歷史記錄<span>”</span>部分。最後，設計協作使我們能夠實現用戶體驗中這未滿足的需求。</p>
<p> </p>
<h4><strong>結論說明</strong></h4>
<p> </p>
<p>它需要設計協調來處理構建出色的產品和體驗所伴隨的複雜並關鍵的問題。通過利用跨學科的多個團隊成員的專業知識，設計協作可確保團隊從各個角度應對挑戰並尋求更好的解決方案。通過正確的思維方式、工具和流程，設計協調能使團隊能夠通過創造性思維和更深入迭代。</p>
<p> </p>
<p>我們希望本指南為您提供一個良好的基礎，您可以以此為基礎建立自己的有效設計協作流程。您可以在<span>Savvy</span>博客上了解有關設計和產品策略的更多信息，也可以隨時在<span>Savvy Apps</span>網站上與我們聯繫以獲取幫助。</p>
<h3>EngineeringProductDesign</h3>
<p>原文pdf連結:<a href="https://drive.google.com/file/d/1KRwEcU7Vn65xL6twStG_EWaTKz1Ag8PG/view?usp=sharing">IndustrialAndEngineeringProductDesignCollaboration.pdf</a></p>
<p>翻譯連結:<a href="/downloads/IndustrialAndEngineeringProductDesignCollaboration翻譯.pdf">IndustrialAndEngineeringProductDesignCollaboration翻譯.pdf</a></p>
<h4><strong>產品公司中的工業和工程設計的協作產品設計過程</strong></h4>
<p><strong></strong></p>
<p>這項研究在闡明工業設計師和工程設計師如何協作，以及這種合作如何體現在設計過程中。我們與來自六個產品製造商的<span>34</span>名工業和工程設計師進行了有關實際產品設計項目的深入採訪。我們首先從訪問數據中識別出各個設計過程。其次，我們使用鑲嵌的方法將設計過程進行比較並合併為協作過程。最後，我們簡化了協作流程，以創建具有代表性的流程模型。結果，我們發現了四種類型的典型協同產品設計流程及其特徵：<span>e</span>類型<span>1</span>：由<span>ID</span>主導的概念驅動過程，類型<span>2</span>：由<span>ID</span>主導的內外聯合過程，類型<span>3</span>：由<span>ED</span>主導的由內到外的流程，類型<span>4</span>：<span>ID</span>＆<span>ED</span>協同流程。</p>
<p></p>
<p>工程設計和工業設計的綜合貢獻對於向市場推出成功的產品至關重要。從單學科的角度很難解釋產品設計。但是，眾所周知，工程設計和工業設計在設計實踐上有很大不同<span>(Pei, 2009; Persson &amp; Wickman, 2004)</span>，並且它們的設計方法在某些方面是相衝突的<span>(Eder, 2013; Hosnedl, Srp, &amp; Dvorak, 2008; Pahl, Wallace, &amp; Blessing, 2007)</span>。工業設計師的角色包括增強產品的用戶體驗並開發其外部樣式和界面<span>(Ulrich &amp; Eppinger, 2012)</span>。他們運用美學和人體工程學方面的知識和技能<span>(Eder, 2013; Pahl et al., 2007)</span>。在與工業設計師的互動下，工程設計師參加了由工業設計師提出的設計概念的實施<span>(Persson &amp; Warell, 2003)</span>。工程設計人員為產品的功能，可靠和製造提供了一種方法<span>(Hubka &amp; Eder, 2012; Pahl et al., 2007)</span>。這導致了工業和工程設計師之間的有不同觀點<span>(Cross, 2008; Hubka &amp; Eder, 2012)</span>。</p>
<p> </p>
<p>經常有人爭辯說，工程設計師使用<span>”</span>從外觀到功能發展的方式<span>”</span>，而工業設計師則採用<span>``</span>從外觀到功能發展的方式<span>'(Eder, 2013; Hosnedl et al., 2008; Pahl et al., 2007)</span>。基於這些概念，提出了以下兩種設計策略：一種是<span>“</span>由內而外<span>”</span>的策略，定義為首先設計內部工件及配件，從而限制外部形狀，另一種是<span>“</span>由外而內<span>”</span>的策略。首先定義外型，然後約束內部零件<span>(Hubka &amp; Eder, 2012; Kim &amp; Lee, 2010)</span>。這些設計策略涉及公司應在特定條件下為特定目的而採取的設計過程。但是，從經驗來看的證據中很少了解到這兩種策略如何在工業項目中應用。很少有嘗試從工程設計和工業設計的綜合角度來看待設計過程。在這方面，我們研究了工業環境中兩個學科的協作設計過程。</p>
<p> </p>
<p>研究的問題是<span>1:</span>存在哪些類型的協作產品設計流程，以及<span>2:</span>什麼條件促使公司採用特定類型的流程。根據這兩個設計師小組的角色和特點，我們假設會有不同類型的由內而外的設計方法。我們認為，由內而外的方法將以工業設計為主導的設計過程為特徵，從而產生工業設計師作為需求和標準提供者的角色，而由內而外的方法將以工程設計為主導的設計過程，工程設計師通過提供對工業設計師職責的初始要求來限制工業設計師的任務範圍。為了在競爭激烈的市場中取得成功，公司應通過適當地採用從內而外的方法來匹配其情況和目標，從而創建工業設計和工程設計的協作流程。</p>
<p> </p>
<p>本文有兩個目標：首先，闡明在實踐中應用的原始協作產品設計過程的形式；其次，確定在不同條件下用於不同目的的不同類型的過程。為此，我們對六家消費產品製造商的工業設計師和工程設計師進行了深入採訪。我們使用<span>“mosaic method”</span>確定了每家公司的產品設計流程，其中結合了從訪談數據中提取的各個設計流程以完成協作流程。結果，我們確定了四種典型的協作產品設計流程及其特徵。</p>
<p> </p>
<p>在本文中，<span>“</span>協同產品設計<span>”</span>的用語是指通過工業設計和工程設計的共同貢獻而創建的產品設計。特別是在公司環境中，協同產品設計涉及一系列設計活動，例如<span>:</span>創建初始產品概念，確定內部規格以及開發外部特徵和內部結構。因此，<span>“</span>協同產品設計過程<span>”</span>是指工業設計和工程設計都直接參與產品開發活動的產品設計過程。</p>
<p> </p>
<p>此時的<span>“</span>工業設計<span>”</span>主要涉及開發產品的外形，界面和用戶體驗，但不包括純圖形或純樣式的設計。<span> “</span>工程設計<span>”</span>開發了用於在產品中放置和操作內部功能部件的技術解決方案，並以能夠實現大規模生產的方式定義了構成產品的內部和外部部件。我們將從事此類活動的工程師標記為<span>“</span>工程設計師<span>”</span>。</p>
<p>本文包括三個部分：第一部分詳細介紹了研究方法。第二部分介紹了典型的協作產品設計過程及其特徵。最後，它總結了結果，並討論了對設計文獻的影響和貢獻。</p>
<h4><strong>1.</strong><strong>研究方法</strong></h4>
<p>為了研究協作產品設計過程的類型和相關條件，我們在數據收集和分析中採用了紮實的理論方法<span>(Charmaz, 2006; Glaser &amp; Strauss, 2009)</span>，以及我們設計用於重新構建協作設計過程的<span>“</span>鑲嵌方法<span>”</span>在工業設計師和工程設計師之間。紮根的理論方法在社會科學中被廣泛用作為研究，較少的領域有建立理論的系統方法，而在設計研究中已被長期採用<span>(e.g. Lee &amp; Cassidy, 2007; Wong, 2010)</span>。它使用歸納邏輯，主要是通過深入的訪談和或觀察開始進行數據收集。在編碼階段，通常有兩種策略。一種是從數據中收集有意義的參考資訊並進行編碼，如果研究主題沒有明確定義，則將它們分為編碼類別。另一種是在明確定義研究主題時，使用符合特定主題的預定義編碼類別來標識相關參考。我們使用了後一種策略，因為對設計過程進行了廣泛的研究。<span> Berends</span>，<span>Reymen</span>，<span>Stultiens</span>和<span>Peutz</span>（<span>2011</span>）採用了類似的方法，對五家公司的設計過程進行了調查。<span> Kleinsmann</span>和<span>Valkenburg</span>（<span>2003</span>）收集了有關工業中協同設計過程的事例，並確定了協同設計項目的關鍵主題和過程。</p>
<p> </p>
<p>我們首先對個別設計師進行了深入採訪，並收集了他們關於設計項目的事例。為避免追溯性帳戶的不可靠性或準確性所造成的可能的失真（<span>Ackroyd</span>＆<span>Hughes</span>，<span>1981</span>），我們採用了三個標準來選擇研究目標：（<span>1</span>）相似產品領域中的多家公司；<span> </span>（<span>2</span>）工程和工業設計部門的多個參與者；<span> </span>（<span>3</span>）在整個產品開發週期中已經完成的項目。我們設置了第一個標準來提高研究結果的適用性。對項目環境的理解和分析提高了設計過程和方法的適用性（<span>Gericke</span>＆<span>Blessing</span>，<span>2012</span>）。因此，對具有相似項目環境的多家公司進行調查可能會提供更好的機會來應用研究結果。使用第二個標準，來自具有不同觀點的多個受試者的數據將相互補充，以抵消任何潛在的偏見（<span>Miller</span>，<span>Cardinal</span>和<span>Glick</span>，<span>1997</span>）。最後，在回顧性訪談中，可以通過收集和分析整個產品開發週期中已經完成的設計項目的事例來確定設計過程（<span>Berends</span>等，<span>2011</span>）。</p>
<p> </p>
<p>為了基於轉錄的訪談數據重建產品設計過程，我們首先確定<span>“</span>過程元素<span>”</span>，然後繪製出各個設計師實踐的部分設計過程。接下來，我們使用<span>“‘mosaic method”</span>將每個公司的所有部分流程組合為協同產品設計流程。在構建了所有詳細的協同產品設計流程之後，我們使用<span>“</span>流程塊<span>”</span>對其進行了簡化，以識別典型設計流程的類型。最後，我們將它們可視化為設計過程模型。如下圖<span>1</span>顯示了研究過程。</p>
<p>可以根據實際設計項目確定實際設計過程及其相對於上下文的特徵，這可能與公司記錄的設計過程不同。比較兩者將提供洞察力。但是，我們無法收集它們，因為它們被視為對外部機密。取而代之的是，我們詢問受訪者他們的公司是否有書面的標准設計流程，以及它是否與實際設計流程不同。</p>
<p><strong> </strong></p>
<h4><strong>1.1</strong><strong>深度訪談</strong></h4>
<h4><strong>1.1.1</strong><strong>案例公司的選擇</strong></h4>
<p>為了增加適用性，應該在公司的環境和背景下理解設計過程（<span>Maffin</span>，<span>1998</span>）。因此，我們通過指定案例公司來設置三個標準。所採用的三個標準如下：</p>
<p>(1）公司應生產中等複雜的電子產品。</p>
<p>(2）他們應該有獨立的工業設計和工程設計部門。</p>
<p>(3）他們應該是市場上領先的公司，生產精心設計的高質量產品。</p>
<p> </p>
<p>第一個標準使得能夠選擇在產品領域內具有相似性的製造商，其中工業設計師和工程設計者都扮演著重要的角色。生產簡單消費品的製造商在工程設計師中的作用將減少。此外，開發火箭不需要工業設計師。<span> Ulrich</span>和<span>Eppinger</span>（<span>2012</span>）指出，<span>“</span>中等複雜度的機電產品<span>”</span>要求工業設計師和工程設計人員重要程度相同。根據<span>Cross</span>（<span>2008</span>）提出的具有復雜性的工程消費品分類，中等複雜產品的例子包括電鑽和洗衣機。因此，中等複雜的電子消費產品指的是日常消費電子產品，它們是完全集成了電子和機械系統的工程產品（<span>Vasi c</span>＆<span>Lazarevi c</span>，<span>2008</span>）。儘管滿足第一個條件，但是某些公司（例如原始設備製造商（<span>OEM</span>））或小型公司的工業設計或工程設計部門是一個，或者沒有。在這種情況下，他們會使用外部設計或工程諮詢公司。他們的協同過程將不同於內部獨立工業設計和工程部門之間的協同過程。我們傾向於通過探索具有相似背景的案例來提高研究結果的適用性。因此，滿足了第二個標準。最後，生產精心設計和高質量產品的領先公司可以為調查提供合理和適當的數據，研究結果將為其他公司提供很好的參考。<span>Lawson</span>（<span>1994</span>）指出，發現良好的設計實踐是如何發生的，將有助於理解和製訂更有效的方法。這是第三個標準的理由。</p>
<p> </p>
<p>我們根據以上標準選擇了案例公司。我們首先將第一和第三項標準應用於從<span>2006</span>年至<span>2010</span>年連續獲得<span>“</span>韓國優秀設計獎<span>”</span>的公司（關於<span>GD</span>，<span>2011</span>年）。<span> “</span>韓國優秀設計獎<span>”</span>在韓國許多市場領先的製造商中很受歡迎。結果，我們獲得了<span>16</span>個公司名稱。然後，我們與獲獎公司列表中的聯繫方式聯繫了每家公司，並詢問主管是否具有獨立的<span>ID</span>和<span>ED</span>部門（第二標準）以及他們是否願意參加研究。最後，我們選擇了六家公司（表<span>1</span>）。</p>
<p>表<span>1:<br/><img alt="" height="202" src="/images/EngineeringProductDesign表1.png" width="818"/><br/></span></p>
<p> </p>
<h4><strong>1.1.2選擇受訪者</strong></h4>
<p>我們選擇了具有目的性和滾雪球式抽樣方法的受訪者（<span>Berg</span>，<span>1988</span>）。每個公司的主管都建議他們的設計師，而後者又建議他們的同事。在這樣做的同時，我們選擇了滿足以下三個條件的受訪者：</p>
<p>（<span>1</span>）兩年以上公司工作經驗</p>
<p>（<span>2</span>）參與至少一個產品開發過程的周期</p>
<p>（<span>3</span>）與同行的緊密合作和互動（即工業設計，簽名人與工程設計師）</p>
<p> </p>
<p>從一家公司的工業設計師和工程設計師團隊招募的預期受訪者人數為<span>6</span>名，每名受訪者中有<span>3</span>名為了保持平衡。但是，我們只能從<span>B</span>公司和<span>F</span>公司招募兩名工程設計人員。總共有<span>18</span>名工業設計師和<span>16</span>名工程設計師作為受訪者參加。他們的工作經驗從<span>2.1</span>年到<span>20</span>年不等，平均為<span>8.9</span>年。</p>
<h4><strong>1.1.3</strong><strong>面試程序</strong></h4>
<p>根據文獻的建議，我們採用了半結構化深度訪談方法（<span>Kvale</span>＆<span>Brinkmann</span>，<span>2009</span>；<span> Seidman</span>，<span>2012</span>）。我們首先列出了約<span>20</span>個詳細問題，並將它們分為四個主要主題：<strong>個人信息</strong>、<strong>設計過程</strong>、<strong>角色和專業知識</strong>、<strong>交互</strong>，然後提出了四個關鍵問題：</p>
<p>（<span>1</span>）您在團隊中的職位和角色是什麼？</p>
<p>（<span>2</span>）產品設計過程如何進行以及在此過程中發生了什麼過程？</p>
<p>（<span>3</span>）您在設計過程中擁有哪些任務，以及哪些知識和常識您執行項目所需的技能？</p>
<p>（<span>4</span>）工業設計和工程設計如何相互作用，在設計過程中互相交流？</p>
<p> </p>
<p>訪談首先是關於受訪者在團隊中的角色和工作經驗的問題，然後是他們經歷的產品開發過程以及在這些過程中的任務。當受訪者由於不願指出要回憶的時刻而猶豫不決時，我們提供了詳細的背景信息，例如：<span>“</span>假設今天是您參與的項目的開工會議日，然後告訴我發生了什麼事。<span>”</span>假設，替代，理想和解釋性問題（<span>Merriam</span>，<span>1998</span>年）。為了限制由多個訪問者引起的不一致，一位作者執行了所有訪問（<span>Ahmed</span>，<span>2007</span>年）。此外，作者在產品開發方面擁有<span>14</span>年的行業經驗，這限制了誤解受訪者描述的綜合設計情況的可能性。為了避免對面試官產生偏見，本研究遵循了<span>“ Epoche”</span>過程，該過程將對現象的判斷和假設封閉，以便在參與者的世界中進行檢查（<span>Leedy</span>＆<span>Ormrod</span>，<span>2012</span>年）。因此，面試官在感覺要判斷受訪者的反應時就忽略了對這種現象的判斷。我們在每個公司的會議室中進行了採訪，並對所有對話進行了錄音。為了幫助進行對話並記錄補充信息，我們做了現場說明。有時，受訪者會在便箋上製作圖紙以提供詳細說明。</p>
<p> </p>
<p>從經驗中知道，<span>90</span>分鐘適合進行深度訪談，因為受訪人在這段時間內會認真回答採訪，而受訪人在<span>90</span>分鐘以上時的回應往往會減少（<span>Seidman</span>，<span>2012</span>年）。遵循指南，我們計劃的採訪時間為<span>90</span>分鐘，但我們沒有控制住它。當我們有足夠的關於問題的數據時，我們通過觀察減少了來自答复的新信息，從而結束了訪談。錄音機中的<span>“</span>語音檢測錄音功能<span>”</span>使我們可以無聲地暫停錄音幾秒鐘，並在聲音返回時恢復錄音。每個受訪者的錄音時間從<span>70</span>分鐘到<span>100</span>分鐘不等，所有參與者的平均錄音時間為<span>78.5</span>分鐘。因此，每個受訪者的實際採訪時間應長於錄音時間。我們逐字記錄了所有採訪數據。結果，我們獲得了大約<span>1000</span>頁的全部轉錄。</p>
<h4><strong>1.2</strong><strong>確定設計過程</strong></h4>
<h4><strong>1.2.1</strong><strong>確定每個人經歷的設計過程</strong></h4>
<p>儘管所有轉錄數據都包含與設計過程有關的信息，但它們都與其他內容混合在一起，包括項目的情況和目標，個人的角色，必要的技能和知識，參與者之間的衝突，每個對象的感知圖像首先，通過回顧相關文獻來確定用於構建設計過程的<span>“</span>過程元素<span>”</span>，從而製定出一個編碼框架。我們通過仔細閱讀<span>A</span>公司的採訪記錄來確認他們。關於過程建模，將過程視為信息處理和狀態轉換系統的兩種觀點為有關過程建模的過程元素的編碼類別提供了有意義的線索。</p>
<p> </p>
<p>從信息處理的角度來看，<span>Browning</span>，<span>Fricke</span>和<span>Negele</span>（<span>2006</span>）將產品開發及其活動視為信息收集，創建，解釋，轉換和轉移的過程。大多數產品開發活動需要一組輸入，並作為活動的結果，初步輸出，狀態報告等進行生產（<span>Browning</span>等，<span>2006</span>）。這種觀點得到了有關設計過程和組織的大量文獻的支持（例如<span>Burns</span>＆<span>Stalker</span>，<span>1961; Clark</span>，<span>1991; Hubka</span>＆<span>Eder</span>，<span>2012</span>）。<span> Ulrich</span>和<span>Eppinger</span>（<span>2012</span>）將其描述為最終結果所必需的信息，該信息被注入以將當前設計問題轉換為下一個問題以降低不確定性，從而產生輸出，直到形成最終結果為止。這被建模為將功能規範（輸入）轉換為製品規範（輸出）的過程（<span>Takeda</span>，<span>Veerkamp</span>和<span>Yoshikawa</span>，<span>1990</span>；<span> Tomiyama</span>和<span>Yoshikawa</span>，<span>1986</span>）。<span> Browning</span>和<span>Ramasesh</span>（<span>2007</span>）指出，由於對交互的了解不多，從信息處理的角度進行過程建模無法捕獲完整的信息流。他們認為，確定組織單位之間的相互作用的重要性，因為它們會引起建立可交付的流程模式的活動之間的依賴。最終，從這個角度來看，流程建模的基本元素概括為<strong>信息流</strong>與<span>IPO</span>（<span>InputeProcesseOutput</span>）表示以及組織單位（人員，團隊，公司等）的<span>“</span>互動<span>”</span>。</p>
<p> </p>
<p>從狀態轉換的角度來看，<span>Reymen</span>（<span>2001</span>）將設計過程描述為通過在每個階段執行任務並評估設計活動將狀態從一種狀態轉移到另一種狀態的過程。這與階段模型一致，在階段模型中，每個階段都會進行設計活動，並在設計評審中評估階段的設計輸出，從而決定是否進行下一階段，重複當前階段或拒絕項目。（<span>Cagan</span>＆<span>Vogel</span>，<span>2002</span>；<span> Ulrich</span>＆<span>Eppinger</span>，<span>2012</span>）。大多數基於階段的模型都提倡這種觀點（<span>Wynn</span>＆<span>Clarkson</span>，<span>2005</span>）。基於階段的模型由旨在執行任務的動作和旨在評估執行任務的結果的決策組成；這項工作的完成構成了下一階段的發展（<span>J€ansch</span>＆<span>Birkhofer</span>，<span>2006</span>；<span> Roozenburg</span>＆<span>Cross</span>，<span>1991</span>）。除此之外，當從一個階段跳到另一個階段或在子過程之間鏈接時，伴隨輸入和輸出的信息流就會發生（<span>Lindemann</span>，<span>2003</span>；<span> Ogot</span>和<span>Okudan-Kremer</span>，<span>2004</span>）。<span> Pahl</span>等人提出的工程設計過程模型。<span> </span>（<span>2007</span>）證明了每個階段的明確投入和成果。第一階段的輸入為<span>“</span>任務<span>”</span>，結果為<span>“</span>規範<span>”</span>，該輸入再次進入下一階段。這樣，繪製出了將輸入和結果連接起來的順序發展階段。關於<span>“</span>任務<span>”</span>和<span>“</span>設計活動<span>”</span>，<span>Pahl</span>等人。<span> </span>（<span>2007</span>）使用<span>“</span>任務<span>”</span>來表示項目的初始起點，不同於在每個階段執行的<span>“</span>任務<span>”</span>。但是，這兩個術語的用法類似，用以表示執行設計工作，因此，人們對相互連接和處理任務的設計過程達成了普遍共識（<span>Dorst</span>，<span>2008</span>年）。</p>
<p> </p>
<p>從狀態轉換的角度來看，有兩個活動：執行任務和評估結果。通常，評估是在相對較短的時間內進行的，以便在<span>“</span>前進，重複或下降<span>”</span>之間做出決定。因此，我們將這些活動（評估，設計審查，門禁檢查，決策）稱為<span>“</span>事件<span>”</span>。目前，我們有兩個編碼類別；總而言之，我們可以用四個編碼類別對設計過程進行建模。<span>“</span>任務<span>”</span>，<span>“</span>事件<span>”</span>，<span>“</span>信息流<span>”</span>和<span>“</span>互動<span>”</span>，並且可以通過階段的關聯來表示。此時，設計過程的一個階段可以用<span>“</span>輸入任務（設計活動）事件（決策制定）輸出<span>”</span>來表示。以下內容描述如何使用以上四種編碼類別對過程要素進行編碼。</p>
<p>任務：清除設計人員執行的任務，例如<span>“</span>想法草圖<span>”</span>，<span>“ 3D</span>建模<span>”</span>等。我使用圓珠筆粗略地表達了我的想法。它上的顏色很少，或者掃描後可以在<span>Photoshop</span>上進行修飾。<span>”</span>我們將其編碼為帶有<span>“</span>想法草圖<span>”</span>標籤的任務類別。</p>
<p> </p>
<p>事件：完成特定任務後，將進行一個事件（決策），從而導致下一個動作。一位受訪者說；<span> ‘</span>我們去樣板公司製作原型，並帶走所有兩個或三個原型。與他們舉行了一次模擬評估會議<span> </span>。工程師們聽老闆的批評。老闆說就是這樣，那就是，如果工程師有不同的想法，他們會提供意見<span>..</span>。最後一個被選中。我們在活動類別中使用<span>“</span>模擬評估會議<span>”</span>標籤對此進行了編碼。</p>
<p> </p>
<p>資訊交流：當任務或事件發生時會生成信息流。它總是伴隨著輸入和輸出。一位受訪者說；<span> ‘</span>事實上，我們根據工程設計人員提供的規范進行工作。我們要等到事情來臨時才開始工作。<span>”</span>這表示工業設計師從工程設計師那裡收到了輸入的<span>“</span>規格數據<span>”</span>作為他們開始工作的依據。我們對<span>“</span>從<span>ED</span>到<span>ID</span>的規範數據<span>”</span>進行了編碼。<span> ‘</span>。選擇一個後，我們會將模型的<span>3D</span>數據傳遞到工程部門。我們發送<span>“ STEP”</span>文件，然後他們使用<span>“ UG”</span>開始設計。<span>”</span>這說明他們向工程設計人員發送了<span>3D CAD</span>數據作為其設計活動的輸出，這些輸入成為後續工程設計的輸入。活動。我們對<span>“</span>從<span>ID</span>到<span>ED</span>的<span>3D CAD</span>數據<span>”</span>進行了編碼。</p>
<p> </p>
<p>交互：發生任務或事件時，兩組經常交互。例如，當工業設計師檢查是否可以修改內部空間時，工程設計師通過提供相關信息為他們提供建議。在這種情況下，會發生激烈的互動，而工程設計人員會充當<span>“</span>顧問<span>”</span>的角色。<span> ‘</span>他們解釋說<span>‘</span>應該放在這裡，應該放在那裡。<span>’</span>然後，我們修改尺寸和位置，然後再次詢問他們是否可以減小<span>2</span>毫米的間隙。如果他們說<span>“</span>是<span>”</span>，我們會將一個部分與另一個部分拼合。<span>”</span>我們將其編碼為<span>“ ED</span>到<span>ID</span>的顧問角色<span>”</span>。</p>
<p> </p>
<p>我們從每個轉錄的訪談數據中識別出流程要素。我們盡可能用參與者自己的話語標記他們。我們將現場說明用作補充數據源。在此過程中，我們按時間順序排列並連接了編碼元素，以構建部分設計過程。該方法被廣泛採用以可視化行業中的過程模型（<span>Vergidis</span>，<span>Tiwari</span>和＆<span>Majeed</span>，<span>2008</span>年）。我們還根據訪談數據確定了設計過程中涉及的項目類型和目標。兩名研究人員執行了整個程序。一位研究人員首先構建了部分設計流程，另一位研究人員通過檢查訪談數據對其進行了檢查。結果，我們從每個公司用<span>7-9</span>獲得了<span>45</span>個局部設計過程（請參見表<span>2</span>中的第二行）。</p>
<p>表<span>2:<br/><img alt="" height="148" src="/images/EngineeringProductDesign表2.png" width="828"/><br/></span></p>
<h4><strong>1.2.2</strong><strong>確定協作產品設計流程</strong></h4>
<p>下一步是通過<span>“mosaic method”</span>將每個公司的設計過程結合到協作設計過程中。我們首先從公司的特定項目中收集了部分設計過程。之所以容易做到這一點，是因為公司的設計師描述了同一項目中的共享經驗，因此各個局部設計過程相互重疊並相互補充。之後，我們通過比較和合併過程元素來合併部分過程。從工業設計者的訪談數據中提取的部分過程提供了有關工業設計活動的豐富信息，包括與工程設計師的互動行為，但有關純工程設計活動的信息較少。工程設計也是如此。我們將公司中工業設計師的部分流程合併在一起，以圍繞工業設計活動重建設計流程。同時，我們利用工程設計師提供的信息來補充和加強工程設計方面的設計活動流程。我們以相同的方式圍繞工程設計活動重建了設計流程。我們最終將這兩個設計過程合併為一個協作產品設計過程。在鑲嵌方法中，結合交叉檢查的局部過程有利於提高可靠性和通用性。通過抵消彼此的信息，這大大降低了構建信息不完整的流程的可能性。因此，<span>“mosaic method”</span>降低了構建不准確流程的可能性。</p>
<p> </p>
<p>在比較部分設計過程時，我們發現產品計劃團隊參與了一些設計過程元素。因此，我們包括了它的作用。這意味著產品規劃團隊在工業設計和工程設計的協同設計項目中扮演著一定的角色。我們還標準化了一些表示相同任務或事件的術語。但是，它們的編碼方式不同，因為受訪者使用它們的方式略有不同。例如<span>:</span>我們發現一個會議在一個局部設計過程中被編碼為<span>“</span>產品計劃會議<span>”</span>，而在另一個局部設計過程中被編碼為<span>“</span>產品開發會議<span>”</span>。因此，我們將它們統一為<span>“</span>產品計劃會議<span>”</span>。也有人將工業設計結果稱為<span>“</span>模型<span>”</span>，<span>“</span>設計模型<span>”</span>或<span>“</span>模型製造<span>”</span>。我們將它們統一為<span>“</span>設計模型<span>”</span>。我們還將<span>“</span>模擬評估事件<span>”</span>和<span>“</span>模擬選擇<span>”</span>標準化為<span>“</span>模擬評估事件<span>”</span>。這項工作是通過對每個公司的面試數據進行交叉檢查，同時評估了評估的意義和環境來完成的。具體條款。實際上，設計師似乎了解每家公司定義了標準術語的文件化設計過程，但並沒有特別意識到這一點。他們似乎忽略了標準化流程，因為市場形勢迫使他們迅速採取行動。語言差異也是造成術語差異的可能原因。在產品設計領域，韓國語中的母語和借來的單詞混合使用。例如，我們同時使用借用詞和用英語表示<span>“</span>設計<span>”</span>的母語。此外，兩支球隊的文化和位置上的差異很可能會導致期限上的差異。除<span>F</span>公司外，這兩個部門分別位於不同的物理空間，至少位於不同的樓層。</p>
<p> </p>
<p>最後，我們通過將階段元素（輸入，任務，事件和輸出）合併到一個框中並在其中將它們與相關任務進行命名，來定義設計過程中的階段（參見圖<span>2</span>）。例如，工業設計師開始根據前一階段的研究結果繪製各種構想草圖。然後，他們通過評估選擇一些最佳草圖。根據選擇的結果，他們決定進入下一階段或重複當前階段。因此，<span>“</span>想法草圖<span>”</span>階段由<span>“</span>研究結果（輸入），<span>”</span>想法草圖（任務），<span>“</span>評估（事件）<span>”</span>和<span>“</span>最佳草圖（輸出）<span>”</span>組成。</p>
<p> </p>
<p>圖<span>2:<br/><img alt="" height="379" src="/images/EngineeringProductDesign圖2.png" width="828"/><br/></span></p>
<p>結果，我們從所有公司獲得了<span>12</span>個協同產品設計流程；每個公司一到三個（請參閱表<span>2</span>中的第三行）。我們將它們發送給每個公司的受訪者，以檢查我們對其流程的解釋。在此過程中進行了較小的更改。圖<span>3</span>顯示了公司<span>A</span>的協作產品設計過程。它在兩側顯示了兩個並行的過程：左側是工業設計過程，右側是工程設計過程，中間示出了兩者之間的相互作用。中間的<span>“</span>產品規劃會議<span>”</span>是由<span>“</span>產品規劃小組<span>”</span>主持的活動，由他們決定是否繼續將概念商業化或拒絕。文本框是由輸入任務事件輸出組成的階段。帶有虛線的文本框不是階段。它們沒有所有四個階段的元素。例如，<span>“</span>檢查<span>”</span>是一種決定。沒有輸入和輸出。垂直箭頭指示流程的進度。它還顯示了信息流的方向，前一級的輸出變成了下一級的輸入。水平箭頭表示<span>“</span>信息流<span>”</span>或<span>“</span>交互<span>”</span>的方向。圓形箭頭表示各階段中反复且強烈的交互。圖<span>3</span>和<span>5</span>中的顏色顯示了它們的連通性。稍後將這些分類為階段，並在下一部分中進行說明。</p>
<h4><strong>1.2.3</strong><strong>簡化流程</strong></h4>
<p>一旦我們制定了每個公司的協作產品設計流程，我們就將它們分類以確定它們的類型，目的和條件。但是，由於每個公司的流程都包含詳細的設計動作和信息，因此直接在公司之間進行比較並不容易。因此，我們通過<span>“</span>流程塊<span>”</span>的概念簡化了每個公司的設計流程，以幫助它們保持可比性，同時又保持基本特徵。</p>
<p> </p>
<p>我們發現在一組小的連續階段中存在一種模式。所有主要階段都完成了一項主要工作。完成後，一個清晰的新階段從另一個工作開始。我們將這些小階段定義為<span>“</span>流程塊<span>”</span>。其特徵在於初始輸入，內部迭代，決策，最終結果和不可逆趨勢（圖<span>4</span>）。流程塊中的內部流程從初始輸入開始，並在內部的各個小階段中運行。迭代或反饋可能在塊內的各個小階段之間發生。最後，他們對最終結果做出最終決定。這是一個里程碑，指示該階段將跳到下一階段。例如，在圖<span>3</span>的藍色方框中，此塊的主要工作是開發執行六個小階段的設計概念。當他們處於渲染階段時，如果在渲染評估事件中不滿意渲染結果，則可以返回到構思草圖階段。在最後階段，設計樣機作為結果由高層管理人員確認，然後跳至<span>“</span>產品計劃會議<span>”</span>。</p>
<p> </p>
<p>在前一個結果進入下一個過程塊的輸入之後，兩個過程塊之間的過程流幾乎沒有機會被逆轉。跨團隊通常進行最終設計，並由高層經理在每個工作組中批准。回到上一個區塊意味著它無法滿足市場時間表。因此，應該由最高管理層對此事做出決定。根據訪談數據，他們寧願放棄該項目，也不願返回上一個階段。在大多數基於階段的模型中都對階段之間的迭代和反饋進行了描述（<span>Wynn</span>＆<span>Clarkson</span>，<span>2005</span>）。但是，在本研究中，將一個過程塊或兩個並行塊視為一個階段，因此在實際情況中很少會發生階段之間的反向迭代或反饋。它發生在一個塊中的各個階段之間。因此，似乎在階段之間幾乎不可能放棄項目，但是在階段之間可以放棄。</p>
<p> </p>
<p>我們通過其主要工作來命名流程塊。在命名這些過程塊時，我們發現<span>“</span>概念設計<span>”</span>一詞在工程設計和工業設計中的用法有所不同。工程設計中的概念設計是與技術概念有關的技術概念，該技術概念通過開發對工作結構和功能的廣泛解決方案來與產品的工作方式相關（<span>Haik</span>＆<span>Shahin</span>，<span>2010; Kroll</span>，<span>Condoor</span>，＆<span>Jansson</span>，<span>2001; Ullman</span>，<span>2009</span>）。但是，工業設計師在概念設計階段決定產品樣式和交互作用的方向，這由概念關鍵字，情緒板，想法草圖和用戶場景來表示（<span>Press</span>＆<span>Cooper</span>，<span>2003</span>；<span> Tovey</span>＆<span>Harris</span>，<span>1999</span>；<span>Vredenburg</span>，<span>Isensee</span>，<span> Righi</span>和＆<span>Design</span>，<span>2001</span>年）。因此，我們標記了這個概念工業設計師的設計活動稱為<span>“ Concept Design-I”</span>，而工程設計師的設計活動稱為<span>“ Concept Design-E”</span>。</p>
<p> </p>
<p>圖<span>5</span>是圖<span>3</span>的簡化版本。圖<span>3</span>中的彩色框使用圖<span>5</span>中的相同彩色框進行了簡化。圖<span>3</span>中的藍色框變為<span>“</span>概念設計<span>-I”</span>。圖<span>3</span>中的<span>“</span>產品計劃會議<span>”</span>為定義為<span>“</span>產品計劃<span>”</span>，並以細長的六邊形可視化。由於它是一個單獨且獨特的設計活動，因此被確定為單個階段。在紅色塊內部，有兩個並行的處理塊；右邊的<span>“ Concept Design-E”</span>（紅色的小方框）是<span>“</span>主流程塊<span>”</span>，左邊的是<span>“</span>形狀修改<span>”</span>（黃色），是<span>“</span>對應的塊<span>”</span>。塊並不能視為單獨的階段，因為它們與大紅色塊內的開始到結束相結合。這樣，兩個設計師團隊之間的互動就很強。為了區分兩個平行的塊，我們用粗實線表示主塊，並用淺實線表示相應的塊。在綠色塊中，由於所有<span>12</span>個流程之間的設計活動都沒有什麼區別，因此我們將詳細設計，測試和生產的兩個順序流程塊合併為一個。因此，在本研究中我們將它們視為一個階段。當綠色方框中的設計過程繼續進行時，工業設計師會根據工程設計師的要求或他們自己的設計檢查目的不時做出反應。他們通常將這些活動稱為<span>“</span>後續活動<span>”</span>，與主要任務有所不同。這些活動顯然存在，但不屬於流程塊。它們是如圖<span>3</span>所示的離散過程元素，因此用虛線表示。為了幫助視覺理解，實心箭頭，雙向寬箭頭和單個方向寬箭頭分別表示過程流，相互交互和單向交互。</p>
<p>圖<span>3:<br/><img alt="" height="1153" src="/images/EngineeringProductDesign圖3.png" width="828"/><br/></span></p>
<p>圖<span>4:<br/><img alt="" height="458" src="/images/EngineeringProductDesign圖4.png" width="609"/><br/></span></p>
<p>圖<span>5:<br/><img alt="" height="1178" src="/images/EngineeringProductDesign圖5.png" width="828"/></span></p>
<h4><strong>1.2.4</strong><strong>確定協作設計過程的類型</strong></h4>
<p>我們根據流程結構，流程塊和階段的輸入和結果的相似性以及工業設計師和工程設計師之間的交互性，對<span>12</span>個簡化的協同產品設計流程進行了比較和分類。我們首先將每個流程塊和階段與其他<span>11</span>個流程的相應流程塊和階段進行結構比較。然後，我們比較了<span>12</span>個流程中每個相應階段的投入和結果。例如，圖<span>5</span>中的<span>“</span>概念設計<span>-I”</span>階段沒有輸入，但是產生了<span>“</span>設計模型<span>”</span>作為輸出。其他流程中的某些<span>“</span>概念設計<span>-I”</span>階段始於工程設計團隊的初步佈局設計。因此，檢查階段的輸入和結果的類型為確定總體流程如何進行提供了線索。最後，我們評估了一個階段中工業設計人員與工程設計人員之間的互動。藍色方框中的兩個組之間沒有交互。但是，在紅色塊中，它們之間存在強大的交互作用。結果，我們將<span>12</span>個協作產品設計過程分為四種代表性過程。</p>
<h4><strong>2.</strong><strong>協作產品設計過程的類型</strong></h4>
<p>我們根據協作產品設計過程的特徵來命名四種類型。它們是類型<span>1</span>：由<span>ID</span>主導的概念驅動過程；類型<span>2</span>：由<span>ID</span>領導的內外聯合流程；類型<span>3</span>：<span>ED</span>主導的內部流程；和類型<span>4</span>：<span>ID</span>＆<span>ED</span>協同過程，它們之間的差異主要存在於開發設計概念和初步佈局的過程的早期階段。在詳細設計階段之後，工程設計師的任務占主導地位，這之間存在一些差異。它相當標準化。這表明協作產品設計過程的類型由詳細設計階段之前採用的方法確定。</p>
<p> </p>
<p>兩家公司根據其目標和情況採用了一到三種類型的設計流程（請參見表<span>3</span>）。類型<span>1</span>和<span>4</span>僅用於新設計，但<span>C</span>公司在市場要求在短時間內進行新樣式時採用了類型<span>1</span>。當他們有很多參考產品並且交貨時間很短時，就會發生這種情況。<span> Type 2</span>用於新設計和重新設計。有趣的是，類型<span>3</span>僅用於重新設計。除公司<span>C</span>（“移動通信產品製造商”）通過服務提供商向市場發布其產品外，大多數流程都用於<span>B2C</span>。考慮到<span>C</span>公司在與<span>A</span>公司和<span>E</span>公司不同的情況下使用<span>Type 1</span>，業務類型（<span>B2B</span>或<span>B2C</span>）將影響設計流程的選擇。</p>
<p><span> </span></p>
<p>關於實際設計過程和書面過程之間的區別，大多數人回答說他們已經記錄了所有公司的標准設計過程，但根本沒有遵循。<span> Ma </span>ﬃ<span> n</span>（<span>1998</span>）的發現支持了這一點，即設計師根據產品開發環境開發了自己的方法。似乎已記錄在案件的流程根據項目類型定義了標準化的任務流和階段，每個部門的任務和角色以及項目時間。但是，他們總是被迫縮短實際項目時間。這種管理壓力很可能導致他們不遵循記錄的流程。</p>
<p><span></span></p>
<p>表<span>3:<br/><img alt="" height="406" src="/images/EngineeringProductDesign表3.png" width="714"/><br/></span></p>
<p>通過比較每種類型過程的使用頻率，我們發現類型<span>3</span>是最常用的，而類型<span>4</span>是最少的。使用類型<span>2</span>的頻率比使用類型<span>1</span>的頻率更高。除了公司<span>B</span>的情況外，類型<span>3</span>與大多數受訪者所說的公司標準最為相似。考慮到重新設計比新設計更頻繁發生的論點（<span>Roozenburg</span>＆<span>Eekels</span>，<span>1995</span>），成功的徹底創新可能每<span>5-10</span>年發生一次（<span>Norman</span>＆<span>Verganti</span>，<span>2014</span>），這是一個合理的發現。由於類型<span>4</span>是個人自發發起的，並且不是一套官方的標準程序，因此這種情況很少見。以下各節介紹了每種類型的設計過程的詳細特徵以及相關的上下文。</p>
<h4><strong>2.1</strong><strong>類型<span>1</span>：由<span>ID</span>主導的概念驅動的過程</strong></h4>
<p>工業設計人員在決定類型<span>1</span>初始階段的產品開發方向方面起著主導作用。根據過程塊，它分為四個階段，如圖<span>6</span>所示。</p>
<p><span> </span></p>
<p>第一階段（概念設計<span>-I</span>）：工業設計師獨立開發產品的概念，而不受其他部門的干擾。他們主要關注與美學外觀和用戶體驗有關的方面。他們很少考慮內部零件，這給了他們很多自由。他們為外部和高質量渲染圖像生成<span>3D CAD</span>數據以測試該概念。最終確定外觀形式後，他們會生成一個“設計模型”，一個無功能的原型，以驗證該概念。最後，在“設計評估會議”上選擇最佳設計。此階段的最終結果是外形的<span>3D CAD</span>數據和設計模型。工程設計師在此階段不採取任何行動。通常，他們甚至不知道工業設計師在設計什麼。</p>
<p><span> </span></p>
<p>第二階段（產品計劃）：產品計劃部門決定所選設計的商業化以及目標市場，設計的目標價格和材料成本。最後，他們準備一份產品計劃文件，並確定設計商業化的具體方向。</p>
<p>圖<span>6:<br/><img alt="" height="427" src="/images/EngineeringProductDesign圖6.png" width="386"/><br/></span></p>
<p> </p>
<p>第三階段（概念設計<span>-E /</span>形狀修改）：前一階段的產品規劃文檔和由工業設計師開發的最終<span>3D CAD</span>數據是向工程設計師提供的初始輸入。工程設計人員回顧了工業設計人員提出的設計概念的可行性，因為工程設計人員收集了相關技術並在<span>3D CAD</span>數據中佈置了內部零件，以測試是否可以將所有必不可少的內部功能零件固定在外部表格中。有時，工程設計人員會生成實驗性原型，以測試是否可以通過預設的外觀形式實現所需的性能。由於工業設計師在定義外觀形式時未考慮內部零件，因此工程設計師在將內部零件佈置在給定的形式中時遇到了麻煩。因此，以某種方式不可避免地要改變外觀。因此，<span>Concept Design-E</span>有一個相應的過程：工業設計師的“形狀修改”。工業設計師使用從工程設計師那裡收到的佈局數據來修改外觀形式。此時，兩個目標相互碰撞。工業設計人員嘗試保持原始形式，而工程設計人員要求進行修改以確保功能和性能。在這個過程中，發生了非常緊密的交互。結果是有關外部形狀和內部零件佈局的<span>3D CAD</span>數據。</p>
<p><span> </span></p>
<p>第四階段（詳細設計測試和生產<span>/</span>跟進）：從這一階段開始，工程設計師在所有零件中領導該過程。工程設計人員根據上一階段確定的<span>3D CAD</span>數據來決定各個零件的幾何形狀和成分結構。由於考慮了批量生產或可靠性測試，他們有時會要求工業設計師對外觀設計進行較小的修改。詳細設計完成後，將生產稱為“工程樣品”的工作原型，以檢查形式和功能。在這一點上，工業設計師要評估其外觀設計符合其設計理念的程度。然後，工程設計師決定供應商，生產模具，並通過多個事件過程測試“生產前原型”，以提高性能的可靠性和產品的耐用性。</p>
<p> </p>
<p>另一方面，在“跟進”中，工業設計師決定如何在產品上應用顏色，圖形，材料和表面修飾，並為工程設計師提供相關規範。對於所生產的每個工作原型，工業設計師都會根據規格測試美學和情感品質。當他們批准時，他們在設計過程中的正式作用就結束了。除非獲得批准，否則工程設計師應再次生產和測試有問題的零件。我們發現所有六個公司都具有這種機制來維持產品的設計質量。</p>
<p> </p>
<p>類型<span>1</span>與傳統觀念相反，傳統觀念認為新產品開發過程是通過市場研究或開發新技術來確定市場需求而開始的。它始於純粹的工業設計師的完全自由的概念化。這意味著可以根據工業設計師在腦海中設想的圖片來開發新產品。這與工程設計學科中描述的產品設計過程不一致（例如，<span>Dym</span>，<span>1994</span>年；<span> Haik</span>＆<span>Shahin</span>，<span>2010</span>年；<span> Pahl</span>等，<span>2007</span>年），在工業設計中，工業設計師在概念設計中的作用缺失。</p>
<p><span> </span></p>
<p>考慮到相關的理論，即創造力是在以解決方案為導向的方法（<span>Wynn</span>＆<span>Clarkson</span>，<span>2005</span>）對問題進行徹底分析之前發生的，例如“主要生成器”（<span>Darke</span>，<span>1979</span>）和猜想分析模型（<span>Hillier</span>）。 ，<span>Musgrove</span>和<span>O'Sullivan</span>，<span>1972</span>年），以及<span>Lawson</span>（<span>2006</span>年）和<span>March</span>（<span>1984</span>年）的其他相關發現和觀點，這將是公司在沒有外部影響的情況下，賦予工業設計師自由和自主權來產生創造性解決方案概念的最佳策略。干擾。實際上，類型<span>1</span>在兩種情況下被使用：一種是開發形狀和功能都新的概念產品，包括開發新產品類別（如公司<span>A</span>和<span>E</span>中的產品），另一種是啟動新概念產品。盡快（如公司<span>C</span>中）的現有產品。當參考設計豐富時，後一種情況似乎是可能的，因此，工業設計師可以在交貨時間短時確定產品尺寸和外部元素而無需任何產品規格。</p>
<h4><strong>2.2</strong><strong>類型<span>2</span>：由<span>ID</span>領導的組合內外流程 </strong></h4>
<p>公司使用此過程來開發新型產品或修改現有產品。在任何一種情況下，與類型<span>1</span>不同，產品計劃團隊都將啟動該過程。我們可以分四個階段來解釋類型<span>2</span>，如圖<span>7</span>所示。</p>
<p>圖<span>7:<br/><img alt="" height="450" src="/images/EngineeringProductDesign圖7.png" width="437"/><br/></span></p>
<p>第一階段（產品計劃）：產品計劃小組創建一個產品計劃文檔以啟動產品開發。它設置了目標市場，目標價格和產品規格。在開發現有產品的修改版本時，它會根據現有產品（包括競爭對手的產品）來決定它們。在開發新產品時，工程設計師會幫助他們確定。此階段的結果是產品規劃文檔。</p>
<p><span> </span></p>
<p>第二階段（概念設計<span>-I</span>）：從產品計劃部門收到產品計劃文件後，工業設計師將決定產品的外觀和相關內部。他們收集符合產品尺寸和規格的待開發產品所需的功能項目，並從對用戶或設計趨勢的研究中得出形式概念。然後，他們安排內部零件以決定外觀形式，同時避免內部零件與預期的外部形式之間發生任何衝突。因此，它們在外形設計和內部零件的佈置之間來回移動。在此階段，工業設計師和工程設計師之間幾乎沒有互動。對於最終事件，設計評估將使用非功能性設計模型進行。因此，此階段的結果是有關產品外觀和初始內部佈局的<span>3D CAD</span>數據，以及設計模型。</p>
<p><span> </span></p>
<p>第三階段（概念設計<span>-E /</span>形狀修改）：從工業設計師那裡獲得<span>3D CAD</span>數據後，工程設計師會仔細檢查內部零件與外部形狀相關的可行性和可操作性，並製定最終佈局。工程設計師檢查它們時，經常要求工業設計師修改佈局或外部形式。因此，工業設計活動要進行相應的過程。 “形狀修改”。但是，形狀更改不像<span>Type1</span>那樣重要，因為他們在上一階段決定了與內部部件相關的外部形狀。該階段的結果是有關最終外觀形式和內部零件確定佈局的<span>3D CAD</span>數據。</p>
<p><span> </span></p>
<p>第四階段（詳細設計測試和生產<span>/</span>跟進）：該階段與類型<span>1</span>並無顯著差異。</p>
<p>類型<span>2</span>的顯著特徵是工業設計師在確定第二階段的外形時積極參與佈置功能性組件。儘管工業設計師對內部佈局與外部形狀之間的聯繫的了解較少以工程為重點，但此案例清楚地表明，工業設計師的作用已經超出了我們通常期望的範圍。因此，工業設計師變得很有潛力並且可以主動地進行決策。此外，工程設計師幾乎沒有參與此階段。根據工程設計文獻的建議（例如<span>Hubka</span>＆<span>Eder</span>，<span>1987; Pahl et al</span>。，<span>2007; Ullman</span>，<span>2009</span>），我們希望版圖設計將是工程設計人員的專屬工作。我們假設至少工程設計人員會積極為工業設計師提供建議和指導。但是，他們希望數據能夠從工業設計師那裡獲得，並賦予工業設計師自由完成與產品內部結構有關的外部形式的能力。此時，公司的設計第一政策似乎是主要原因。</p>
<p><span> </span></p>
<p><span>2.3</span>類型<span>3</span>：由<span>ED</span>主導的內部第一個過程類型<span>3</span>與類型<span>1</span>和類型<span>2</span>有兩點不同：它們僅用於重新設計現有產品，工程設計人員的工作要先於工業設計人員進行。它要求工程設計師扮演更重要的角色，同時減少工業設計師的角色。我們解釋它們的特徵如下：</p>
<p><span> </span></p>
<p>第一階段（產品計劃）：如圖<span>8</span>所示，產品計劃團隊首先根據年度產品開發路線圖啟動產品開發項目。至此，他們在路線圖中確實具有產品的功能概念。產品規劃專家根據市場上現有的產品確定目標市場，目標價格，產品尺寸和材料成本。工程設計人員經常通過分析競爭對手產品的技術部分並估算材料成本來幫助他們開發產品規格。此階段的結果是產品計劃文件，其中包括產品規格。</p>
<p><span> </span></p>
<p>第二階段（概念設計<span>-E</span>）：工程設計師根據產品規格快速制定初步佈局。他們通常使用以前開發的產品的數據。完成後，他們將初步佈局作為<span>3D CAD</span>數據發送給工業設計師。這是工業設計過程的起點。工業設計人員將其用作開發外觀的輸入，而工程設計人員則尋求系統性能的解決方案並繼續完善佈局。隨著內部佈局和外部形式的同時發展，兩個團隊密切互動並討論任何分歧或衝突之處，並反復交換反饋以進行修改。最終，當設計草圖發展為確定的外觀形式時，初步佈局成為確定的佈局。這個階段的結果是確定設計的最終佈局，從而確定最終產品的尺寸。</p>
<p> </p>
<p>2.5階段（概念設計<span>-I</span>）：此過程遠非一個獨立的後續階段，而是第二和第三階段之間的中間階段。因此，我們將其稱為第<span>2.5</span>階段。它從收到工程設計人員的初步佈局開始，並與<span>Concept Design-E</span>同時進行。工業設計師檢查內部佈局並以匹配的外部形式進行覆蓋。他們進行構想草圖，<span>3D CAD</span>建模，渲染，設計評估會議和模型選擇活動，以決定外觀設計。工程設計人員不斷為外觀設計提供建議和評估。因此，外觀設計和佈局通過相互交織的<span>Concept Design-I</span>和<span>Concept Design-E</span>逐步發展。</p>
<p> </p>
<p>第三階段（詳細設計測試和生產<span>/</span>跟進）：該階段與類型<span>1</span>和類型<span>2</span>沒有明顯不同。</p>
<p><span> </span></p>
<p>除公司<span>B</span>以外的所有公司都使用此過程。這表明它被最廣泛地使用。受訪者指出，就角色，任務和階段而言，此過程可與公司有關設計過程的正式指導方針相媲美。但是，他們提到實際時間比指南中指定的時間短。</p>
<h4><strong>2.4</strong><strong>類型<span>4</span>：<span>ID</span>＆<span>ED</span>協同過程</strong></h4>
<p>類型4並非是根據官方提議而發生的，而是各個設計師在早期階段的嘗試。在許多情況下，由於在有限的時間內存在可行性問題，參與開發陣容模型的工程設計師往往會拒絕工業設計師提出的新穎設計概念。為了實施這些概念，工業設計師與自由設計師合作。因此，此過程使繼續拒絕的新穎設計概念成為可能。此外，工業設計師和工程設計師也可以協同工作。與傳統的分離方法不同，它們以集成方式處理設計概念，同時考慮了許多設計變量。此過程的詳細階段如下）：</p>
<p>圖<span>8:<br/><img alt="" height="441" src="/images/EngineeringProductDesign圖8.png" width="410"/><br/></span></p>
<p>第一階段（產生概念）：如圖<span>9</span>所示，工業設計師獨立地構思新設計。他們大都是根據僅有創新性但仍未開始進行的設計構想來構建它。</p>
<p>第二階段（概念設計）：此階段始於工業設計師尋找可以與他們合作的工程設計師。當工程設計師同意加入工業設計師以實施設計概念時，他們將在整個階段中緊密合作。工程設計師為工業設計師提供最先進的技術，以增強設計理念。內部佈局的第一層是根據要開發的外部形狀開發的。該階段的結果是有關外觀和內部佈局的<span>3D CAD</span>數據。</p>
<p>第三階段（產品計劃）：產品計劃小組通過設計評估會議來決定設計的商業化。然後，產品計劃團隊確定設計的目標市場。從這個階段開始，負責開發陣容模型的工程設計人員就參與其中。</p>
<p>第四階段（詳細設計測試和生產<span>/</span>跟進）：該階段的過程與類型<span>1</span>、<span>2</span>和<span>3</span>的過程沒有太大不同。</p>
<p>現有的產品開發環境使工程設計人員趨於保守。消費電子領域的大多數開發項目都是緊迫的。公司通常會在計劃中設定產品發布日。因此，設計人員將按照時間軸執行所有任務和排程。根據訪談數據，參與此類項目的工程設計師傾向於拒絕工業設計師提出的新穎設計概念，因為他們認為自己無法確保使用這些概念的作品能夠在選定的時間通過性能和可靠性測試。測試失敗將直接影響公司的產品開發路線圖以及工程設計師評估時的年度績效。這似乎使他們保守地選擇和評估設計概念。因此，對於直接參與按時間表進入市場的項目的設計人員來說，幾乎無法使用此過程。相反，相對而言，從時間表到市場的時間相對有限的工程設計師，例如那些參與開發面向未來產品的先進技術的工程師，將更願意接受新穎的設計理念。此外，更重要的是，似乎更願意與其他專家合作進行設計的設計師傾向於執行此過程。</p>
<p>對於公司<span>D</span>，通過採用此過程，類型<span>4</span>在新產品方面取得了巨大的市場成功。但是，在我們的採訪中沒有報告更多將這一過程積極應用於後續項目的案例。儘管如此，有趣的是，<span>D</span>公司還是從先進技術開發團隊派遣了幾名工程設計師到工業設計團隊的一個相鄰辦事處。這啟用了協同處理案例。最高管理者故意讓他們動用，以使他們迅速為工業設計師提供必要的技術支持，以防止工業設計師提出不切實際的設計概念。這似乎激發了雙方更加親密，從而營造了合作的氣氛。這將增加新興的集成設計流程的可能性。</p>
<h4><strong>3.</strong><strong>討論與啟示</strong><br/> <strong>3.1</strong><strong>角色變更</strong></h4>
<p>工業設計師的貢獻在概念設計階段占主導地位，此後，工程設計師接任其主要角色。這可以視為四種設計過程的一般特徵。除類型<span>3</span>外，所有設計過程均始於工業設計師開發的設計概念。對於類型<span>1</span>和類型<span>2</span>，工業設計師根據形狀和用途獨立定義設計概念。<span> Type 4</span>在概念設計階段是集成的，但從工業設計師的初始設計概念開始。與其他三種類型（第<span>3</span>種情況）不同，在這種情況下，對現有產品進行了計劃中的修改，首先是由工程設計師進行佈局設計。看來他們的角色分為概念開發者和概念實現者。有趣的是，當一家公司追求新概念的產品或強調情感感覺和可用性（即使在重新設計案例中）時，工業設計師的作用似乎很重要。這與通過開發新原理和新技術來開發新概念產品的想法不同。他們寧願設計新用途或現有用途的含義。因此，這可以被視為新設計也從現有技術和原理開始的證據。</p>
<p>關於工業設計師的知識，與我們認為很少考慮內部零件的信念相反，他們似乎具有足夠的知識來閱讀和處理內部功能組件並進行外部設計。除類型<span>1</span>外，定義外部形狀通常是通過工業設計師考慮並重新佈置內部功能部件來進行的。類型<span>2</span>是意外情況。工業設計師通過同時安排相關的內部組件來開發外形。但是，他們在內部零件上的工作可能僅限於直接影響外部形狀的主要零件。儘管他們沒有完全參與設計內部零件的細節，但是很明顯，他們的作用已擴展到工程設計領域。這要歸功於最高管理層對工業設計的大力支持以及兩組之間共享的<span>CAD</span>工具。</p>
<h4><strong>3.2</strong><strong>選擇設計方法</strong></h4>
<p>從理論上講，“由內而外”和“由外而內”的方法是發生的，並且是由工程設計師和工業設計師的不同工作傾向共同造成的（<span>Hubka</span>＆<span>Eder</span>，<span>2012</span>；<span> Kim</span>＆<span>Lee</span>，<span>2010</span>）。四種類型的協作設計過程可以看作是這兩種方法的擴展版本。本節討論四種類型與兩種方法之間的關係，以及成功應用每種類型並將其應用於顧問和客戶合作夥伴設置的條件。</p>
<p>對於強調使用環境的消費產品，工業設計師應首先定義與可用性和外觀有關的外觀，然後工程設計師確定與外部鏈接的內部功能部件以支持可用性和外觀。在這種情況下，這是一種由外而內的方法，其中類型<span>1</span>適用，類型<span>2</span>幾乎適用。如果我們將內向外過程定義為首先確定初步佈局，然後將其用於共同開發隨後的外部形式和確定性佈局，則類型<span>3</span>是一種情況。考慮到這兩種方法，類型<span>4</span>被視為混合過程，因為外部和內部都同時定義。如果我們將內部到外部的過程定義為在完成內部確定的佈局後決定外部的過程，則此處研究的公司中沒有這樣的過程。它不太適合與消費產品一起使用。它非常適合工業耐用品。例如，如果我們設計一台工業電動機，容量將決定電線的纏繞數和磁芯的尺寸。我們應該科學地計算內部轉子和定子的佈局和尺寸，以獲得最佳性能。因此，必須首先完全確定內部零件，然後將外部形式定義為覆蓋。如果我們根據預設的外部形式開發電機的內部零件，它將無法正常運行。</p>
<p>使用<span>Type 1</span>時，工業設計師可以自由提出創新的設計思路。然而，該方法將導致兩個問題。首先，很難獲得工程技術性能。為了獲得最佳性能，內部功能部件可能會與外形衝突。其次，為了解決第一個問題，設計團隊可能會通過在功能和外觀之間進行權衡來折衷原始設計概念。為了成功管理此方法，當折衷方案發生時，高層管理人員必須保持強大的支持以保持設計的創新性。正如我們在<span>B</span>公司中觀察到的那樣，類型<span>2</span>可以替代這些問題。它的策略是，工業設計師在移動或放置相關內部零件時確定外觀形式。這避免了內部和外部之間的嚴重干擾。然而，有爭議的是，工業設計師是否應在外觀設計開發之外還進行室內佈局設計，以犧牲想像力為代價。他們可能會在自己的知識範圍內折衷創新。要成功應用<span>Type 2</span>，設計師應該對工業設計和工程設計都具有很高的知識。</p>
<p>為了在早期階段獲得高級設計概念的可行性，值得注意的是<span>Type 4</span>，因為工業設計師的概念和工程設計師的技術支持可以開發新產品。鑑於此過程非常有效並且有可能開發創新產品，因此公司需要為其提供適當的使用條件。戴森公司可以成為榜樣。眾所周知，設計師和工程師作為一個部門的成員共享一個工作區，以實現設計的集成實施（<span>Dyson</span>＆<span>Coren</span>，<span>1997</span>）。為了促進此過程，公司需要有一個集成的團隊，其中兩個小組共享一個工作空間，並按預期吸收每個學科的文化。更為重要的是組織文化，它激發了設計師挑戰性和開放性，可以一起工作。如果設計師擔心公司因失敗而受到懲罰，那麼他們會更加保守。沒有這種情況的改變，類型<span>4</span>甚至作為公司中有據可查的流程都將無法有效地發揮作用。</p>
<p>在行業中，許多工程公司與外部工業設計師合作。儘管我們沒有調查這種類型的協作，但是，根據我們的發現對可能的流程方案進行討論將是有益的。當製造商與設計諮詢公司合作時，他們可以得到補充支持，以按時完成項目或產生新的想法（<span>Bruce</span>＆<span>Morris</span>，<span>1994</span>）。在顧問和客戶合作關係中，有兩種過程耦合方式：被動耦合，其中顧問在與客戶聯繫以獲取更多信息或查看其結果時獨立開發解決方案，以及主動耦合，其中顧問和客戶設計師的協作團隊密切合作生成解決方案（<span>Gericke</span>＆<span>Maier</span>，<span>2011</span>年）。在被動耦合中，由於外部設計師獨立工作，其設計過程將類似於類型<span>1</span>或類型<span>2</span>。當客戶希望利用他們缺少的特定專業來收集盡可能多的創意時，類型<span>1</span>將非常有用。當客戶公司高度以技術為導向並且有足夠的能力在強大的工程支持下實施好的概念時，這種情況將很有幫助。如果客戶的能力比上述情況要小，並且在初期需要聘請外部工業設計師來領導其產品開發，則類型<span>2</span>將是合適的。主動耦合模式將具有與類型<span>3</span>和類型<span>4</span>相似的過程。當客戶已經具有良好的設計方向和相關技術，並且想要改善產品的美學外觀時，類型<span>3</span>將是合適的。除非客戶和顧問公司的整合團隊在項目期間在同一空間工作，否則第<span>4</span>類將是不可能的。在顧問和客戶合作夥伴的協作設計過程中應該考慮其他因素。在許多情況下，客戶為顧問提供的信息在一定程度上受到限制。因此，在顧問和客戶合作夥伴以及公司內部發生的相同類型的協作過程在內容方面將是不同的。儘管如此，我們的研究結果和討論仍可為在消費電子領域選擇更好的設計方法提供線索。</p>
<h4><strong>3.3</strong><strong>設計過程類型的含義</strong></h4>
<p>工業設計師和工程設計師在設計方法和關於產品開發的觀點上是不同的（<span>Eder</span>，<span>2013</span>；<span> Pahl</span>等，<span>2007</span>；<span> Ulrich</span>＆<span>Eppinger</span>，<span>2012</span>）。工業設計師產生以用戶為中心的解決方案概念，工程設計師根據技術角度解決設計問題。這兩個群體的專業所面臨的過程可能是開發具有競爭力的創新產品的基礎。此外，系統工程設計和以用戶為中心的設計思想的耦合過程對於在顧問與客戶之間的關係中生成以用戶為中心的解決方案是有益的（<span>Gericke</span>＆<span>Maier</span>，<span>2011</span>）。耦合過程是公司採取並實現市場競爭力的最佳選擇。例如，消費電子公司使用四種類型的協作設計過程來實現其市場目標。工業設計師在這四種類型的早期階段中的作用是顯而易見的，採用工業設計師專業的方式是採用適當類型的協作設計過程的重要因素。通過給予類型<span>1</span>中的工業設計師自由，可以增加獲得創新設計概念的可能性。那麼，這種自由如何驅動工業設計師創建創新設計概念呢？實際上，建築和工業設計師首先從解決方案的圖像入手，然後通過重複試驗最終確定（<span>Lawson</span>，<span>2006</span>；<span> Roozenburg</span>＆<span>Cross</span>，<span>1991</span>）。這與一個模型有關，在該模型中，設計人員首先基於預設進行推測，然後進行分析（<span>Hillier</span>等，<span>1972</span>）。這意味著工業設計師依靠對未來的展望來創造創新的概念，而不是對市場和客戶進行深入的設計研究。<span> Press and Cooper</span>（<span>2003</span>）補充說，工業設計方法是價值驅動的。因此，類型<span>1</span>的工業設計師可以不受約束，可以通過設想所需的未來產生創意。</p>
<p><span>Norman</span>和<span>Verganti</span>（<span>2014</span>）認為，創新產品開發是通過技術或含義的改變進行的，而不是以人為中心的認真的設計研究。他們補充說，以人為本的設計方法更適合於現有產品的逐步改進</p>
<p>產品。在消費電子領域當前的產品開發環境中，產品規劃專家在市場和客戶研究中起著關鍵作用。因此，產品規劃團隊對工業設計師的投入將僅限於他們的創造力。這解釋了為什麼公司以相反的方式使用<span>Type 1</span>；首先開發概念，然後再定義市場，而不是相反。通常，在產品設計概念中，設計師會考慮與技術高度相關的功能概念，以及會給用戶帶來新含義的樣式概念（<span>Baxter</span>，<span>1995</span>年）。因此，由於功能和<span>/</span>或樣式概念，工業設計師提出的設計概念應該是創新的。當涉及到技術時，工程設計師應開發新技術或尋找適當的技術來實施該概念。如果在產品開發計劃階段沒有被拒絕，這種類型的過程會導致新技術的開發。</p>
<p>在類型<span>2</span>中，公司對工業設計師承擔各種角色和職責。由於工程設計師不會打擾他們，所以他們可能有一定的自由度。工業設計師的方法是面向解決方案的。他們通常不遵循系統的過程。他們寧願提出新的想法並重複他們。但是，類型<span>2</span>可能通過強加他們在內部佈局設計和外部設計中扮演的另一角色而中斷了工業設計師的方法。工業設計師採用面向問題和系統的方法，將最終限制他們在概念開發中的想像力。在考慮其設計概念的可行性時，這將使它們更加現實。因此，類型<span>2</span>的設計結果將不如類型<span>1</span>的創新。否則，類型<span>2</span>將比新設計更適合重新設計。如果工業設計師不考慮將<span>Type 2</span>的內部零件進行重新設計，則他們可能會面臨困難，設計概念可能會被拒絕（<span>Kim</span>＆<span>Lee</span>，<span>2014</span>）。</p>
<p> 如果我們考慮將類型<span>2</span>和類型<span>3</span>用於重新設計，那麼類型<span>2</span>何時比類型<span>3</span>更好？類型<span>3</span>的特性符合工程設計中顯示的大多數設計過程。工業設計被認為是工程設計領域中的事後想法（例如<span>Andreasen</span>＆<span>Hein</span>，<span>2000</span>；<span> Hubka</span>＆<span>Eder</span>，<span>1987</span>；<span> Pahl</span>等，<span>2007</span>）。按照他們的觀點，工業設計的功能與產品外觀的各個方面有關，例如確定產品的技術特徵後的樣式，形式和顏色。第<span>3</span>類是工程設計師為設計概念提供技術解決方案的過程。他們要求工業設計師開發外觀。因此，類型<span>3</span>僅使用工業設計師的部分專業知識來創造美學外觀。從這個角度來看，類型<span>2</span>比類型<span>3</span>可以為工業設計師提供更多的方法來展示其專業知識。考慮到類型<span>3</span>是最常用的過程，因此在過程管理方面可以更有效。類型<span>3</span>早期階段的不確定性可能是四種類型中最小的。的大多數技術解決方案設計概念是由工程設計師在早期階段設定的，而工業設計師只限於創造美學外觀。</p>
<p>我們找不到的一個過程是類型<span>5</span>：<span>ED</span>主導的技術驅動過程。這可以與類型<span>1</span>：由<span>ID</span>主導的概念驅動過程形成對比。在類型<span>5</span>中，工程設計人員將首先開發一項新技術而無需考慮產品開發計劃，並使用測試原型來測試其性能。接下來，工業設計師為該技術產生新的產品設計概念。然後，可視化的設計概念和原型可用於決定產品開發。應用類型<span>5</span>，公司可以創建新類別的產品，從而增加打開新市場的可能性。我們無法找到這種類型的原因之一是創新技術開發的稀缺性，以及新技術滿足新概念的難得機會。另外，在決定產品開發之前，公司不太可能等不確定的工程設計師和工業設計師。為了使此過程更好，我們需要工程設計師開發新技術，需要工業設計師使用相互合作的技術創建新概念。根據這一論點，類型<span>4</span>在正式用於創新產品設計時會很有用。它還可以使工程設計師開發的技術與工業設計師提出的新概念集成在一起。<br/> 4.結論</p>
<p>我們旨在確定協作設計過程類型的存在以及在公司中採用特定類型的條件。我們根據工業設計師和工程設計師的深入訪談數據建立了協作設計流程。結果，我們發現了四種類型的協作設計過程。根據設計過程早期階段的不同對它們進行分類。四種類型的過程在不同的上下文中用於不同的目的。有時，它們會被戰略性地用於開發新設計或重新設計，有時它們會由於內部和外部因素而有機地應用。我們還發現，工業設計師的作用是有影響力的，而且是擴展的。</p>
<p>設計過程模型的抽象特徵和研究中的一門學科方法與實際實踐並不完全匹配，並且被確定為造成這種問題情況的原因（<span>Brooks Jr</span>，<span>2010</span>；<span> Eckert</span>＆<span>Clarkson</span>，<span>2005</span>）。在這方面，有人要求結合不同的設計過程模型（<span>Albers</span>，<span>2010</span>；<span> Dorst</span>，<span>2008</span>）。四種類型的過程是工業設計師驅動的以解決方案為導向的方法和工程設計師以問題為導向的方法的組合過程。它們表明，即使在單個領域（即消費類電子產品）中，實際的設計過程也無法用單個模型來表示。為了提高設計過程的適用性並在設計實踐中獲得設計方法的適當支持，需要考慮公司和項目具體環境的更為具體的過程模型（<span>Finkelstein</span>＆<span>Finkelstein</span>，<span>1983</span>；<span> Gericke</span>＆<span>Blessing</span>，<span>2011</span>）。我們特別專注於消費電子領域，在這一領域中，工業設計師和工程設計師在產品開發中起著重要的合作作用。我們發現了四種類型的設計過程，並確定了它們的目的和背景。因此，我們發現的有關上下文的詳細信息將為公司計劃針對新產品開發的有效設計過程管理提供有用的信息，尤其是在消費電子領域。</p>
<p>根據研究方法，我們展示瞭如何從設計師的深入訪談數據中建立協作設計過程。我們確定了過程元素，並使用它們構造了部分過程，並使用鑲嵌方法建立了詳細的協作設計過程。我們還引入了“過程塊”，並定義了一個或兩個交互塊作為一個階段。我們認為這種方法有利於確定最佳水平的實際設計過程。我們認為該方法適用於發現其他設計過程。我們的過程模型的形式可與其他基於階段的模型相比較（例如<span>French</span>，<span>1998</span>；<span> Pahl</span>等，<span>2007</span>）。我們從模型中發現，在階段之間很少發生反向迭代或反饋。這與現有的基於階段的工程設計過程模型的描述不同。在理想情況下，我們認為雙向迭代是可能的，但是實際上由於激烈的市場競爭，我們認為這種情況很少發生。</p>
<p>特別是針對其他產品領域中的其他項目案例，需要對該方法進行進一步的研究。本研究中的公司均為電子產品製造商。因此，結果僅限於此產品類別。我們需要測試這四個協作設計過程如何在其他公司中應用。相反，值得研究創新產品開發和應用過程的案例。</p>
<p> </p>
<h3>MechanicalDesignProcess</h3>
<p>原文pdf連結: <a href="https://drive.google.com/file/d/13THamnfayiRT4Wa9KzmjXQSP4ZW2jIej/view?usp=sharing">MechanicalDesignProcess.pdf</a></p>
<p>翻譯連結: <a href="/downloads/MechanicalDesignProcess翻譯.pdf">MechanicalDesignProcess翻譯.pdf</a></p>
<p><iframe height="700px" iframe="" src="https://github.com/s40723210/cd2020/blob/master/downloads/MechanicalDesignProcess%E7%BF%BB%E8%AD%AF.pdf" width="100%"></iframe></p>
<h3>Keyboard control car</h3>
<h4 class="title style-scope ytd-video-primary-info-renderer"><yt-formatted-string class="style-scope ytd-video-primary-info-renderer" force-default-style="">V-rep 馬達驅動四輪車</yt-formatted-string></h4>
<p><span>V-rep 檔案連結: <a href="/downloads/4 wheel car.ttt">4 wheel car.ttt</a></span></p>
<p>剛開始可以使用內建的功能來創建模型，Add &gt; Primitive shape &gt; Cuboid(需要的 形狀)，給定所需形狀的參數值即可，創建出一個正方形本體，還有四個圓柱形輪子， 移動到相對應的位置，再來加上馬達 Add &gt; Joint &gt; Revolute，分別定位在四個輪 子的軸上，雙擊Revolute_joint圖示，在彈出的屬性框點擊Show dynamic parameters dialog，勾選 Motor enable，並設置 Target velocity 為 10，四個馬達都是如此。 </p>
<p>影片連結:<a href="https://youtu.be/y8DJ1sjuAqM">https://youtu.be/y8DJ1sjuAqM</a></p>
<p><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/y8DJ1sjuAqM" width="560"></iframe></p>
<hr color="00ffee"/>
<h4 class="title style-scope ytd-video-primary-info-renderer"><yt-formatted-string class="style-scope ytd-video-primary-info-renderer" force-default-style="">四輪車鍵盤控制轉向</yt-formatted-string></h4>
<p>V-rep 檔案連結: <a href="/downloads/4%20wheel%20car%20keyboard.ttt">4 wheel car keyboard.ttt</a></p>
<p>四輪車加上轉向及鍵盤控制，先開啟之前做好的四輪車，將兩個前輪馬達複製貼上，再使兩個馬達原地轉向90度，創建兩個小正方體，位置與前輪一模一樣，<span>需要設定屬性避免與其他部件衝突，本體、輪子、小正方體都要關閉如下圖。</span></p>
<p><img alt="" height="136" src="/images/4%20wheel%20car%20%E6%9C%AC%E9%AB%94%E5%B9%B2%E6%B6%89.PNG" width="371"/><br/><br/>將控制迴路啟用，來控制轉向的限制角度，兩個馬達都用預設即可，如下圖設定。<br/><br/><img alt="" height="431" src="/images/4%20wheel%20car%20%E8%BD%89%E5%90%91%E8%A8%AD%E5%AE%9A.PNG" width="377"/></p>
<p>將之前的馬達速度都關掉，<span>點擊馬達圖示視窗下的</span><span>show dynamic properties dialog</span><span>，把</span><span>motor properties的速度改為0</span><span>，底下的</span><span>lock motor when target velocity is zero是</span><span><span color="#000000">馬達速度為零時鎖定馬達，可開可不開。</span></span></p>
<p><span><span color="#000000"><img alt="" height="171" src="/images/4%20wheel%20car%20%E5%BE%8C%E8%BC%AA%E9%A6%AC%E9%81%94.PNG" width="380"/></span></span></p>
<p>最後把方塊拖移至對應馬達下，再整個放進本體下，把對應的前輪馬達放置方塊下，本體新增一個控制腳本，選擇cuboid，點擊菜單欄的Add &gt; Associated child script &gt; Threaded，將寫好的腳本複製貼上，更改前輪馬達的名子，這樣腳本才能控制，下圖為整個最終結構。<br/><br/><img alt="" height="355" src="/images/4%20wheel%20car%20%E7%B5%90%E6%A7%8B.PNG" width="266"/></p>
<p><span><strong>四輪車鍵盤控制轉向程式碼:</strong></span></p>
<div>
<div class="syntaxhighlighter lua" id="highlighter_696434">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>
<div class="line number3 index2 alt2">3</div>
<div class="line number4 index3 alt1">4</div>
<div class="line number5 index4 alt2">5</div>
<div class="line number6 index5 alt1">6</div>
<div class="line number7 index6 alt2">7</div>
<div class="line number8 index7 alt1">8</div>
<div class="line number9 index8 alt2">9</div>
<div class="line number10 index9 alt1">10</div>
<div class="line number11 index10 alt2">11</div>
<div class="line number12 index11 alt1">12</div>
<div class="line number13 index12 alt2">13</div>
<div class="line number14 index13 alt1">14</div>
<div class="line number15 index14 alt2">15</div>
<div class="line number16 index15 alt1">16</div>
<div class="line number17 index16 alt2">17</div>
<div class="line number18 index17 alt1">18</div>
<div class="line number19 index18 alt2">19</div>
<div class="line number20 index19 alt1">20</div>
<div class="line number21 index20 alt2">21</div>
<div class="line number22 index21 alt1">22</div>
<div class="line number23 index22 alt2">23</div>
<div class="line number24 index23 alt1">24</div>
<div class="line number25 index24 alt2">25</div>
<div class="line number26 index25 alt1">26</div>
<div class="line number27 index26 alt2">27</div>
<div class="line number28 index27 alt1">28</div>
<div class="line number29 index28 alt2">29</div>
<div class="line number30 index29 alt1">30</div>
<div class="line number31 index30 alt2">31</div>
<div class="line number32 index31 alt1">32</div>
<div class="line number33 index32 alt2">33</div>
<div class="line number34 index33 alt1">34</div>
<div class="line number35 index34 alt2">35</div>
<div class="line number36 index35 alt1">36</div>
<div class="line number37 index36 alt2">37</div>
<div class="line number38 index37 alt1">38</div>
<div class="line number39 index38 alt2">39</div>
<div class="line number40 index39 alt1">40</div>
<div class="line number41 index40 alt2">41</div>
<div class="line number42 index41 alt1">42</div>
<div class="line number43 index42 alt2">43</div>
<div class="line number44 index43 alt1">44</div>
<div class="line number45 index44 alt2">45</div>
<div class="line number46 index45 alt1">46</div>
<div class="line number47 index46 alt2">47</div>
<div class="line number48 index47 alt1">48</div>
<div class="line number49 index48 alt2">49</div>
<div class="line number50 index49 alt1">50</div>
<div class="line number51 index50 alt2">51</div>
<div class="line number52 index51 alt1">52</div>
<div class="line number53 index52 alt2">53</div>
<div class="line number54 index53 alt1">54</div>
<div class="line number55 index54 alt2">55</div>
<div class="line number56 index55 alt1">56</div>
<div class="line number57 index56 alt2">57</div>
<div class="line number58 index57 alt1">58</div>
<div class="line number59 index58 alt2">59</div>
<div class="line number60 index59 alt1">60</div>
<div class="line number61 index60 alt2">61</div>
<div class="line number62 index61 alt1">62</div>
<div class="line number63 index62 alt2">63</div>
<div class="line number64 index63 alt1">64</div>
<div class="line number65 index64 alt2">65</div>
<div class="line number66 index65 alt1">66</div>
<div class="line number67 index66 alt2">67</div>
<div class="line number68 index67 alt1">68</div>
<div class="line number69 index68 alt2">69</div>
<div class="line number70 index69 alt1">70</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="lua comments">-- This script is threaded! It is a very simple example of how Ackermann steering can be handled.</code></div>
<div class="line number2 index1 alt1"><code class="lua comments">-- Normally, one would use a non-threaded script for that</code></div>
<div class="line number3 index2 alt2"> </div>
<div class="line number4 index3 alt1"><code class="lua plain">threadFunction=</code><code class="lua keyword">function</code><code class="lua plain">()</code></div>
<div class="line number5 index4 alt2"><code class="lua spaces">    </code><code class="lua keyword">while</code> <code class="lua plain">simGetSimulationState()~=sim_simulation_advancing_abouttostop </code><code class="lua keyword">do</code></div>
<div class="line number6 index5 alt1"><code class="lua spaces">        </code><code class="lua comments">-- Read the keyboard messages (make sure the focus is on the main window, scene view):</code></div>
<div class="line number7 index6 alt2"><code class="lua spaces">        </code><code class="lua plain">message,auxiliaryData=simGetSimulatorMessage()</code></div>
<div class="line number8 index7 alt1"><code class="lua spaces">        </code><code class="lua keyword">while</code> <code class="lua plain">message~=-1 </code><code class="lua keyword">do</code></div>
<div class="line number9 index8 alt2"><code class="lua spaces">            </code><code class="lua keyword">if</code> <code class="lua plain">(message==sim_message_keypress) </code><code class="lua keyword">then</code></div>
<div class="line number10 index9 alt1"><code class="lua spaces">                </code><code class="lua keyword">if</code> <code class="lua plain">(auxiliaryData[1]==2007) </code><code class="lua keyword">then</code></div>
<div class="line number11 index10 alt2"><code class="lua spaces">                    </code><code class="lua comments">-- up key</code></div>
<div class="line number12 index11 alt1"><code class="lua spaces">                    </code><code class="lua plain">desiredWheelRotSpeed=desiredWheelRotSpeed+wheelRotSpeedDx</code></div>
<div class="line number13 index12 alt2"><code class="lua spaces">                </code><code class="lua keyword">end</code></div>
<div class="line number14 index13 alt1"><code class="lua spaces">                </code><code class="lua keyword">if</code> <code class="lua plain">(auxiliaryData[1]==2008) </code><code class="lua keyword">then</code></div>
<div class="line number15 index14 alt2"><code class="lua spaces">                    </code><code class="lua comments">-- down key</code></div>
<div class="line number16 index15 alt1"><code class="lua spaces">                    </code><code class="lua plain">desiredWheelRotSpeed=desiredWheelRotSpeed-wheelRotSpeedDx</code></div>
<div class="line number17 index16 alt2"><code class="lua spaces">                </code><code class="lua keyword">end</code></div>
<div class="line number18 index17 alt1"><code class="lua spaces">                </code><code class="lua keyword">if</code> <code class="lua plain">(auxiliaryData[1]==2009) </code><code class="lua keyword">then</code></div>
<div class="line number19 index18 alt2"><code class="lua spaces">                    </code><code class="lua comments">-- left key</code></div>
<div class="line number20 index19 alt1"><code class="lua spaces">                    </code><code class="lua plain">desiredSteeringAngle=desiredSteeringAngle+steeringAngleDx</code></div>
<div class="line number21 index20 alt2"><code class="lua spaces">                    </code><code class="lua keyword">if</code> <code class="lua plain">(desiredSteeringAngle&gt;45*</code><code class="lua functions">math.pi</code><code class="lua plain">/180) </code><code class="lua keyword">then</code></div>
<div class="line number22 index21 alt1"><code class="lua spaces">                        </code><code class="lua plain">desiredSteeringAngle=45*</code><code class="lua functions">math.pi</code><code class="lua plain">/180</code></div>
<div class="line number23 index22 alt2"><code class="lua spaces">                    </code><code class="lua keyword">end</code></div>
<div class="line number24 index23 alt1"><code class="lua spaces">                </code><code class="lua keyword">end</code></div>
<div class="line number25 index24 alt2"><code class="lua spaces">                </code><code class="lua keyword">if</code> <code class="lua plain">(auxiliaryData[1]==2010) </code><code class="lua keyword">then</code></div>
<div class="line number26 index25 alt1"><code class="lua spaces">                    </code><code class="lua comments">-- right key</code></div>
<div class="line number27 index26 alt2"><code class="lua spaces">                    </code><code class="lua plain">desiredSteeringAngle=desiredSteeringAngle-steeringAngleDx</code></div>
<div class="line number28 index27 alt1"><code class="lua spaces">                    </code><code class="lua keyword">if</code> <code class="lua plain">(desiredSteeringAngle&lt;-45*</code><code class="lua functions">math.pi</code><code class="lua plain">/180) </code><code class="lua keyword">then</code></div>
<div class="line number29 index28 alt2"><code class="lua spaces">                        </code><code class="lua plain">desiredSteeringAngle=-45*</code><code class="lua functions">math.pi</code><code class="lua plain">/180</code></div>
<div class="line number30 index29 alt1"><code class="lua spaces">                    </code><code class="lua keyword">end</code></div>
<div class="line number31 index30 alt2"><code class="lua spaces">                </code><code class="lua keyword">end</code></div>
<div class="line number32 index31 alt1"><code class="lua spaces">            </code><code class="lua keyword">end</code></div>
<div class="line number33 index32 alt2"><code class="lua spaces">            </code><code class="lua plain">message,auxiliaryData=simGetSimulatorMessage()</code></div>
<div class="line number34 index33 alt1"><code class="lua spaces">        </code><code class="lua keyword">end</code></div>
<div class="line number35 index34 alt2"> </div>
<div class="line number36 index35 alt1"><code class="lua spaces">        </code><code class="lua comments">-- We handle the front left and right wheel steerings (Ackermann steering):</code></div>
<div class="line number37 index36 alt2"><code class="lua spaces">        </code><code class="lua plain">steeringAngleLeft=</code><code class="lua functions">math.atan</code><code class="lua plain">(l/(-d+l/</code><code class="lua functions">math.tan</code><code class="lua plain">(desiredSteeringAngle)))</code></div>
<div class="line number38 index37 alt1"><code class="lua spaces">        </code><code class="lua plain">steeringAngleRight=</code><code class="lua functions">math.atan</code><code class="lua plain">(l/(d+l/</code><code class="lua functions">math.tan</code><code class="lua plain">(desiredSteeringAngle)))</code></div>
<div class="line number39 index38 alt2"><code class="lua spaces">        </code><code class="lua plain">simSetJointTargetPosition(steeringLeft,steeringAngleLeft)</code></div>
<div class="line number40 index39 alt1"><code class="lua spaces">        </code><code class="lua plain">simSetJointTargetPosition(steeringRight,steeringAngleRight)</code></div>
<div class="line number41 index40 alt2"> </div>
<div class="line number42 index41 alt1"><code class="lua spaces">        </code><code class="lua comments">-- We take care of setting the desired wheel rotation speed:</code></div>
<div class="line number43 index42 alt2"><code class="lua spaces">        </code><code class="lua plain">simSetJointTargetVelocity(motorLeft,desiredWheelRotSpeed)</code></div>
<div class="line number44 index43 alt1"><code class="lua spaces">        </code><code class="lua plain">simSetJointTargetVelocity(motorRight,desiredWheelRotSpeed)</code></div>
<div class="line number45 index44 alt2"> </div>
<div class="line number46 index45 alt1"><code class="lua spaces">        </code><code class="lua comments">-- Since this script is threaded, don't waste time here:</code></div>
<div class="line number47 index46 alt2"><code class="lua spaces">        </code><code class="lua plain">simSwitchThread() </code><code class="lua comments">-- Resume the script at next simulation loop start</code></div>
<div class="line number48 index47 alt1"><code class="lua spaces">    </code><code class="lua keyword">end</code></div>
<div class="line number49 index48 alt2"><code class="lua keyword">end</code></div>
<div class="line number50 index49 alt1"> </div>
<div class="line number51 index50 alt2"><code class="lua comments">-- Put some initialization code here:</code></div>
<div class="line number52 index51 alt1"><code class="lua comments">-- Retrieving of some handles and setting of some initial values:</code></div>
<div class="line number53 index52 alt2"><code class="lua plain">steeringLeft=simGetObjectHandle(</code><code class="lua string">'Steer_left_joint'</code><code class="lua plain">)</code></div>
<div class="line number54 index53 alt1"><code class="lua plain">steeringRight=simGetObjectHandle(</code><code class="lua string">'Steer_right_joint'</code><code class="lua plain">)</code></div>
<div class="line number55 index54 alt2"><code class="lua plain">motorLeft=simGetObjectHandle(</code><code class="lua string">'Front_left_joint'</code><code class="lua plain">)</code></div>
<div class="line number56 index55 alt1"><code class="lua plain">motorRight=simGetObjectHandle(</code><code class="lua string">'Front_right_joint'</code><code class="lua plain">)</code></div>
<div class="line number57 index56 alt2"><code class="lua plain">desiredSteeringAngle=0</code></div>
<div class="line number58 index57 alt1"><code class="lua plain">desiredWheelRotSpeed=0</code></div>
<div class="line number59 index58 alt2"><code class="lua plain">steeringAngleDx=2*</code><code class="lua functions">math.pi</code><code class="lua plain">/180</code></div>
<div class="line number60 index59 alt1"><code class="lua plain">wheelRotSpeedDx=20*</code><code class="lua functions">math.pi</code><code class="lua plain">/180</code></div>
<div class="line number61 index60 alt2"><code class="lua plain">d=0.755 </code><code class="lua comments">-- 2*d=distance between left and right wheels</code></div>
<div class="line number62 index61 alt1"><code class="lua plain">l=2.5772 </code><code class="lua comments">-- l=distance between front and read wheels</code></div>
<div class="line number63 index62 alt2"> </div>
<div class="line number64 index63 alt1"><code class="lua comments">-- Here we execute the regular thread code:</code></div>
<div class="line number65 index64 alt2"><code class="lua plain">res,err=</code><code class="lua functions">xpcall</code><code class="lua plain">(threadFunction,</code><code class="lua keyword">function</code><code class="lua plain">(err) </code><code class="lua keyword">return</code> <code class="lua functions">debug.traceback</code><code class="lua plain">(err) </code><code class="lua keyword">end</code><code class="lua plain">)</code></div>
<div class="line number66 index65 alt1"><code class="lua keyword">if</code> <code class="lua keyword">not</code> <code class="lua plain">res </code><code class="lua keyword">then</code></div>
<div class="line number67 index66 alt2"><code class="lua spaces">    </code><code class="lua plain">simAddStatusbarMessage(</code><code class="lua string">'Lua runtime error: '</code><code class="lua plain">..err)</code></div>
<div class="line number68 index67 alt1"><code class="lua keyword">end</code></div>
<div class="line number69 index68 alt2"> </div>
<div class="line number70 index69 alt1"><code class="lua comments">-- Put some clean-up code here:</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p><span><span color="#000000"></span></span>教學影片連結:<a href="https://youtu.be/0W1wmC1tr4A">https://youtu.be/0W1wmC1tr4A</a></p>
<p><span><strong><span color="#000000"><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/0W1wmC1tr4A" width="560"></iframe></span></strong></span></p>
<h2>assignment3</h2>
<p></p>
<h1>CoppeliaSim</h1>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/CoppeliaSim.png"/></p>
<p align="center"><span><span>版本4.0.0</span></span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/welcome.jpg"/></p>
<p><span><span>具有集成開發環境的機器人模擬器CoppeliaSim基於分佈式控制體系結構：可以通過嵌入式腳本，插件，ROS節點，BlueZero節點，遠程API客戶端或自定義解決方案分別控制每個對象/模型。</span><span>這使CoppeliaSim非常通用，非常適合多機器人應用。</span><span>控制器可以用C / C ++，Python，Java，Lua，Matlab，Octave或Urbi編寫。</span></span></p>
<p><span><span>以下只是CoppeliaSim的部分應用程序：</span></span></p>
<p></p>
<ul>
<li><span><span>工廠自動化系統仿真</span></span></li>
<li><span><span>遠程監控</span></span></li>
<li><span><span>硬件控制</span></span></li>
<li><span><span>快速原型製作和驗證</span></span></li>
<li><span><span>安全監控</span></span></li>
<li><span><span>快速算法開發</span></span></li>
<li><span><span>機器人相關教育</span></span></li>
<li><span><span>產品介紹</span></span></li>
</ul>
<p></p>
<p><span><span>CoppeliaSim可以用作獨立應用程序，也可以輕鬆地嵌入到主客戶端應用程序中：它的佔用空間小且精心設計的API使CoppeliaSim成為嵌入更高級別應用程序的理想選擇。</span><span>集成的Lua腳本解釋器使CoppeliaSim成為了一種極其通用的應用程序，使用戶可以自由組合低級/高級功能以獲得新的高級功能。</span></span></p>
<p><span><span>快速入門CoppeliaSim的一個好方法是先看一下</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/tutorials.htm"><span><span>教程部分</span></span></a><span><span>。</span></span></p>
<h4 class="recommendedTopics"><span><span>推薦主題</span></span></h4>
<p></p>
<ul>
<li><a href="https://www.coppeliarobotics.com/helpFiles/en/coppeliaSimFeatures.htm"><span><span>CoppeliaSim主要功能</span></span></a></li>
<li><a href="https://www.coppeliarobotics.com/helpFiles/en/versionInfo.htm"><span><span>CoppeliaSim版本歷史</span></span></a></li>
<li><a href="https://www.coppeliarobotics.com/helpFiles/en/acknowledgments.htm"><span><span>致謝和鳴謝</span></span></a></li>
<li><a href="https://www.coppeliarobotics.com/helpFiles/en/tutorials.htm"><span><span>講解</span></span></a></li>
<li><a href="http://coppeliarobotics.com/contributions.html" target="_blank"><span><span>CoppeliaSim周圍的各種貢獻和外部資源</span></span></a></li>
<li><a href="http://forum.coppeliarobotics.com/" target="_blank"><span><span>CoppeliaSim / V-REP論壇</span></span></a></li>
</ul>
<p></p>
<p></p>
<h2>BubbleRob tutorial</h2>
<p>由40723210提供</p>
<p>個人操作影片連結:<a href="https://youtu.be/BStp8J-KXuY">https://youtu.be/BStp8J-KXuY</a></p>
<p>本教程將在設計簡單的移動機器人<em>BubbleRob</em>時嘗試介紹很多CoppeliaSim功能。與本教程相關的CoppeliaSim場景文件位於CoppeliaSim的安裝文件夾的<em>tutorials / BubbleRob</em>文件夾中。下圖說明了我們將設計的仿真場景：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/bubbleRobTut1.jpg"/></p>
<p></p>
<p>由於本教程將跨越許多不同的方面，因此請確保也看看<a href="https://www.coppeliarobotics.com/helpFiles/en/tutorials.htm">其他教程</a>，主要是<a href="https://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm">有關構建仿真模型</a>的<a href="https://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm">教程</a>。首先，重新啟動CoppeliaSim。模擬器顯示默認<a href="https://www.coppeliarobotics.com/helpFiles/en/scenes.htm">場景</a>。我們將從<em>BubbleRob</em>的主體開始。</p>
<p>我們使用[菜單欄-&gt;添加-&gt;基本形狀-&gt;球體]將直徑為0.2的基本球體添加到場景中。我們將X尺寸項目調整為0.2，然後點擊確定。默認情況下，創建的球體將顯示在<a href="https://www.coppeliarobotics.com/helpFiles/en/layerSelectionDialog.htm">可見性層</a> 1中，並且是<a href="https://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#staticAndRespondable">動態且可響應的</a>（因為我們已啟用“ 創建動態且可響應的形狀 ”項）。這意味著<em>BubbleRob的</em>身體將掉落，並且能夠對與其他可響應形狀的碰撞做出反應（即，由物理引擎模擬）。我們可以看到這是<a href="https://www.coppeliarobotics.com/helpFiles/en/shapeDynamicsProperties.htm">形狀動力學屬性</a>：項目身體是可響應的，身體是動態的已啟用。我們開始模擬（通過工具欄按鈕，或在場景窗口中按&lt;control-space&gt;），然後復制並粘貼創建的球體（使用[菜單欄-&gt;編輯-&gt;複製所選對象]，然後[菜單欄-&gt;編輯-&gt;粘貼緩衝區]，或者先按&lt;control-c&gt;，再按&lt;control-v&gt;）：這兩個球將對碰撞做出反應並滾動。我們停止模擬：重複的球體將自動刪除。可以在<a href="https://www.coppeliarobotics.com/helpFiles/en/simulationPropertiesDialog.htm">模擬對話框中</a>修改此默認行為。</p>
<p>我們還希望<em>BubbleRob的</em>主體可以被其他計算模塊（例如<a href="https://www.coppeliarobotics.com/helpFiles/en/distanceCalculation.htm">最小距離計算模塊</a>）使用。因此，如果尚未啟用，則在該形狀的<a href="https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm">對象公共屬性中</a>啟用<a href="https://www.coppeliarobotics.com/helpFiles/en/collidableObjects.htm">Collidable</a>，<a href="https://www.coppeliarobotics.com/helpFiles/en/measurableObjects.htm">Measurable</a>，<a href="https://www.coppeliarobotics.com/helpFiles/en/renderableObjects.htm">Renderable</a>和<a href="https://www.coppeliarobotics.com/helpFiles/en/detectableObjects.htm">Detectable</a>。如果需要，我們現在還可以在<a href="https://www.coppeliarobotics.com/helpFiles/en/shapeProperties.htm">形狀屬性中</a>更改球體的視覺外觀。<a href="https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/shapeProperties.htm"></a></p>
<p>現在，我們在“ 平移”選項卡上打開“ <a href="https://www.coppeliarobotics.com/helpFiles/en/positionDialog.htm">位置”對話框</a>，選擇表示<em>BubbleRob</em>身體的球體，然後為“ 沿著Z”輸入0.02 。我們確保將相對項設置為World。然後，單擊翻譯選擇。這會將所有選定對象沿絕對Z軸平移2 cm，並有效地將我們的球體抬高了一點。在<a href="https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy">場景層次結構中</a>，我們雙擊球體的名稱，以便我們可以編輯其名稱。我們輸入<em>bubbleRob</em>，然後按Enter。<em></em><a href="https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy"></a><em></em></p>
<p>接下來，我們將添加一個<a href="https://www.coppeliarobotics.com/helpFiles/en/proximitySensors.htm">接近傳感器，</a>以便<em>BubbleRob</em>知道它何時接近障礙物：我們選擇[菜單欄-&gt;添加-&gt;接近傳感器-&gt;圓錐類型]。在方向選項卡上的<a href="https://www.coppeliarobotics.com/helpFiles/en/orientationDialog.htm">方向對話框中</a>，我們為Y周圍和Z 周圍輸入90 ，然後單擊旋轉選擇。在<a href="https://www.coppeliarobotics.com/helpFiles/en/positionDialog.htm">位置對話框</a>的“ 位置”選項卡上，為X坐標輸入0.1 。Z坐標為0.12 。現在，接近傳感器已相對於<em>BubbleRob的</em>身體正確定位。我們在<a href="https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy">場景層次中</a>雙擊接近傳感器的圖標<a href="https://www.coppeliarobotics.com/helpFiles/en/positionDialog.htm"></a><em></em><a href="https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy"></a>打開<a href="https://www.coppeliarobotics.com/helpFiles/en/proximitySensorPropertiesDialog.htm">其屬性</a>對話框。我們單擊顯示體積參數以打開<a href="https://www.coppeliarobotics.com/helpFiles/en/proximitySensorVolumeDialog.htm">接近傳感器體積對話框</a>。我們將偏移量調整為0.005，角度調整為30，範圍調整為0.15。然後，在<a href="https://www.coppeliarobotics.com/helpFiles/en/proximitySensorPropertiesDialog.htm">接近傳感器屬性中</a>，單擊顯示檢測參數。這將打開<a href="https://www.coppeliarobotics.com/helpFiles/en/proximitySensorDetectionParameterDialog.htm">接近傳感器檢測參數對話框</a>。如果距離小於則取消選中“不允許檢測”項，然後再次關閉該對話框。在場景層次結構中，我們雙擊接近傳感器的名稱，以便我們可以編輯其名稱。我們輸入<em>bubbleRob_sensingNose</em>並按回車鍵。</p>
<p>我們選擇<em>bubbleRob_sensingNose</em>，然後<em>按住</em> Control鍵選擇<em>bubbleRob</em>，然後單擊[菜單欄-&gt;編輯-&gt;將最後選擇的對象設為父對象]。這會將傳感器連接到機器人的身體。我們也可以拖<em>bubbleRob_sensingNose</em>到<em>bubbleRob</em>在場景層次。這就是我們現在擁有的：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/bubbleRobTut2.jpg"/></p>
<p class="imageLabel">[接近傳感器連接到<em>bubbleRob的</em>身體]</p>
<p>接下來，我們將照顧<em>BubbleRob的</em>車輪。我們使用[菜單欄-&gt;文件-&gt;新場景]創建一個新場景。跨多個場景工作通常非常方便，以便可視化並僅對特定元素進行工作。我們添加一個尺寸為（0.08,0.08,0.02）的純原始圓柱體。至於<em>BubbleRob</em>的主體，如果尚未啟用，則在該圓柱的<a href="https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm">對象通用屬性中</a>啟用 <a href="https://www.coppeliarobotics.com/helpFiles/en/collidableObjects.htm">Collidable</a>，<a href="https://www.coppeliarobotics.com/helpFiles/en/measurableObjects.htm">Measurable</a>，<a href="https://www.coppeliarobotics.com/helpFiles/en/renderableObjects.htm">Renderable</a>和<a href="https://www.coppeliarobotics.com/helpFiles/en/detectableObjects.htm">Detectable</a>。然後，將圓柱的絕對位置設置為（0.05,0.1,0.04），並將其絕對方向設置為（-90,0,0）。我們將名稱更改為<em>bubbleRob_leftWheel</em><a href="https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm"></a><em></em>。我們複製並粘貼滾輪，然後將復制的絕對Y坐標設置為-0.1。我們將副本重命名為<em>bubbleRob_rightWheel</em>。我們選擇兩個輪子，複製它們，然後切換回場景1，然後粘貼輪子。</p>
<p>現在，我們需要為車輪添加<a href="https://www.coppeliarobotics.com/helpFiles/en/joints.htm">接頭</a>（或電動機）。我們單擊[菜單欄-&gt;添加-&gt;關節-&gt;旋轉]將旋轉關節添加到場景。在大多數情況下，將新對象添加到場景時，該對象將出現在世界的起源處。我們保持關節處於選中狀態，然後控制選擇<em>bubbleRob_leftWheel</em>。在“ <a href="https://www.coppeliarobotics.com/helpFiles/en/positionDialog.htm">位置”對話框</a>的“ 位置”選項卡上，單擊“ 應用到選擇”按鈕：這將關節定位在左輪的中心。然後，在“ <a href="https://www.coppeliarobotics.com/helpFiles/en/orientationDialog.htm">方向”對話框</a>的“ 方向”選項卡上，執行相同的操作：這將關節與左輪定向的方向相同。我們將關節重命名為<em>bubbleRob_leftMotor</em>。現在，我們在場景層次中雙擊關節的圖標以打開<a href="https://www.coppeliarobotics.com/helpFiles/en/jointProperties.htm">關節屬性</a>對話框。然後，單擊“ 顯示動態參數”以打開<a href="https://www.coppeliarobotics.com/helpFiles/en/jointDynamicsProperties.htm">關節動力學屬性</a>對話框。我們啟用電動機，並檢查項目“ 目標速度為零時鎖定電動機”。現在，我們對右馬達重複相同的過程，並將其重命名為<em>bubbleRob_rightMotor</em>。現在，我們將左輪連接到左馬達，將右輪連接到右馬達，然後將兩個馬達連接到<em>bubbleRob</em>。這就是我們所擁有的：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/bubbleRobTut3.jpg"/></p>
<p class="imageLabel">[接近傳感器，電動機和車輪]</p>
<p>我們運行模擬，並註意到機器人向後倒下。我們仍然缺少與地板的第三個聯繫點。現在，我們添加一個小的滑塊（或腳輪）。在一個新的場景，我們並添加純原始球體直徑為0.05，讓球<a href="https://www.coppeliarobotics.com/helpFiles/en/collidableObjects.htm">可碰撞</a>，<a href="https://www.coppeliarobotics.com/helpFiles/en/measurableObjects.htm">可衡量的</a>，<a href="https://www.coppeliarobotics.com/helpFiles/en/renderableObjects.htm">可渲染</a>和<a href="https://www.coppeliarobotics.com/helpFiles/en/detectableObjects.htm">檢測的</a>（如果尚未啟用），然後將其重命名為<em>bubbleRob_slider</em>。我們在<a href="https://www.coppeliarobotics.com/helpFiles/en/shapeDynamicsProperties.htm">形狀動力學屬性</a>中將Material設置為<em>noFrictionMaterial</em>。為了將滑塊與機器人的其餘部分牢固地鏈接在一起，我們使用[菜單欄-&gt;添加-&gt;力傳感器] 添加了<a href="https://www.coppeliarobotics.com/helpFiles/en/forceSensors.htm">力傳感器對象</a>。我們將其重命名為<a href="https://www.coppeliarobotics.com/helpFiles/en/shapeDynamicsProperties.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/forceSensors.htm"></a><em>bubbleRob_connection</em>並將其上移0.05。我們將滑塊連接到力傳感器，然後復制兩個對象，切換回場景1並粘貼它們。然後，我們將力傳感器沿絕對X軸移動-0.07，然後將其安裝到機器人主體上。如果現在運行模擬，我們會注意到滑塊相對於機器人主體略微移動：這是因為兩個對象（即<em>bubbleRob_slider</em>和<em>bubbleRob</em>）都相互碰撞。為了避免在動力學模擬過程中產生奇怪的影響，我們必須通知CoppeliaSim兩個對像不會相互碰撞，我們可以通過以下方式進行此操作：在<a href="https://www.coppeliarobotics.com/helpFiles/en/shapeDynamicsProperties.htm">shape dynamics屬性中</a>，為<em>bubbleRob_slider</em>設置了本地可響應蒙版設置為00001111，對於<em>bubbleRob</em>，我們將本地可響應掩碼設置為11110000。如果再次運行仿真，我們會注意到兩個對像不再乾涉。這就是我們現在擁有的：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/bubbleRobTut4.jpg"/></p>
<p class="imageLabel">[接近傳感器，電機，車輪和滑塊]</p>
<p>我們再次運行仿真，發現即使在電機鎖定的情況下，<em>BubbleRob也會</em>輕微移動。我們還嘗試使用不同的物理引擎運行仿真：結果將有所不同。動態仿真的穩定性與所涉及的非靜態形狀的質量和慣性緊密相關。有關此效果的說明，請務必仔細閱讀<a href="https://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#masses">本</a>節和<a href="https://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#inertias">該</a>節。現在，我們嘗試糾正這種不良影響。我們選擇兩個輪子和滑塊，然後在“形狀動力學”對話框中單擊3次M = M * 2（用於選擇）。效果是所有選定形狀的質量都將乘以8。我們對3個選定形狀的慣性進行相同的操作，然後再次運行仿真：穩定性得到了改善。在關節動力學對話框中，我們將兩個電機的目標速度都設置為50。我們運行模擬：<em>BubbleRob</em>現在向前移動並最終掉落在地板上。我們將兩個電機的目標速度項都重置為零。</p>
<p>對象<em>bubbleRob</em>是所有以後將形成<em>BubbleRob </em><a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm">模型的</a><a href="https://www.coppeliarobotics.com/helpFiles/en/objects.htm">對象</a>的基礎。我們將在稍後定義模型。同時，我們要定義代表<em>BubbleRob</em>的對象的集合。為此，我們定義了一個<a href="https://www.coppeliarobotics.com/helpFiles/en/collections.htm">集合對象</a>。我們單擊[菜單欄-&gt;工具-&gt;集合]以打開<a href="https://www.coppeliarobotics.com/helpFiles/en/collectionsDialog.htm">集合對話框</a>。或者，我們也可以通過單擊相應的工具欄按鈕來打開對話框：<em></em><a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm"></a><em></em><a href="https://www.coppeliarobotics.com/helpFiles/en/collections.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/collectionsDialog.htm"></a></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/collectionDialog1.jpg"/></p>
<p></p>
<p>在集合對話框中，點擊添加新集合。一個新的集合對像出現在下面的列表中。目前，新添加的集合仍為空（未定義）。在列表中選擇新的收藏項時，在場景層次中選擇<em>bubbleRob</em>，然後在收藏對話框中單擊“ 添加 ”。現在，我們的集合被定義為包含層次結構樹的所有對象（從<em>bubbleRob</em>對<em>像</em>開始）（集合的組成顯示在“ 組成元素和屬性”部分中）。要編輯集合名稱，請雙擊它，然後將其重命名為<em>bubbleRob_collection</em>。我們關閉收集對話框。</p>
<p>在此階段，我們希望能夠跟踪BubbleRob與任何其他對象之間的最小距離。為此，我們使用[菜單欄-&gt;工具-&gt;計算模塊屬性] 打開<a href="https://www.coppeliarobotics.com/helpFiles/en/distanceCalculation.htm">距離對話框</a>。或者，我們也可以使用相應的工具欄按鈕打開計算模塊屬性對話框：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/calculationModuleButton.jpg"/></p>
<p></p>
<p>在距離對話框中，單擊添加新的距離對象，然後選擇一個距離對：<em>[collection] bubbleRob_collection-場景中的所有其他可測量對象</em>。這只是添加了一個距離對象，該距離對象將測量集合<em>bubbleRob_collection</em>（即該集合中的任何<a href="https://www.coppeliarobotics.com/helpFiles/en/measurableObjects.htm">可測量對象</a>）與場景中任何其他可測量對象之間的最小距離。我們通過雙擊其名稱將距離對象重命名為<em>bubbleRob_distance</em>。我們關閉距離對話框。現在運行模擬時，我們看不到任何區別，因為距離對象將嘗試測量（並顯示）<em>BubbleRob</em>之間的最小距離段<em></em>以及場景中的其他任何可測量對象。問題在於，在此階段，場景中沒有其他可測量的對象（定義地板的形狀默認情況下已禁用其可測量的屬性）。在本教程的後續階段，我們將為場景添加障礙。</p>
<p>接下來，我們將向<em>BubbleRob</em>添加一個<a href="https://www.coppeliarobotics.com/helpFiles/en/graphs.htm">圖形對象</a>，以顯示最小距離以上的距離，同時還顯示<em>BubbleRob</em>隨時間<em>的</em>軌跡。我們單擊[菜單欄-&gt;添加-&gt;圖]並將其重命名為<em>bubbleRob_graph</em>。我們將圖形附加到<em>bubbleRob</em>，並將圖形的絕對坐標設置為（0,0,0.005）。現在，通過在場景層次結構中雙擊其圖標來打開<a href="https://www.coppeliarobotics.com/helpFiles/en/graphPropertiesDialog.htm">圖形屬性</a>對話框。我們取消選中“ 顯示XYZ平面”，然後單擊“ 添加新數據流”以進行記錄，然後選擇“ 對象：數據流類型的絕對x位置 ” 和<em>bubbleRob_graph</em><em></em><em></em><em></em><em></em><a href="https://www.coppeliarobotics.com/helpFiles/en/graphPropertiesDialog.htm"></a><em></em>用於記錄的對象/項目。數據流記錄列表中出現了一個項目。該項目是<em>bubbleRob_graph的</em>絕對X坐標的數據流（即，將記錄<em>bubbleRobGraph的</em>對象的絕對X位置）。現在，我們還想記錄y和z位置：我們以與上述類似的方式添加這些數據流。現在，我們有3個數據流，分別表示BubbleRob的x，y和z軌跡。我們將添加更多的數據流，使我們能夠跟踪我們的機器人與環境之間的最小距離：我們點擊添加新的數據流記錄，並選擇距離：段長度的數據流類型，並<em>bubbleRob_distance</em>用於記錄的對象/項目。在數據流記錄列表中，我們現在將Data重命名為bubbleRob_x_pos，將Data0重命名為bubbleRob_y_pos，將Data1重命名為bubbleRob_z_pos，將Data2重命名為bubbleRob_obstacle_dist。</p>
<p>我們在“ 數據流”記錄列表中和“ 時間圖屬性”部分中選擇<em>bubbleRob_x_pos</em>，取消選中“ 可見”。我們對<em>bubbleRob_y_pos</em>和<em>bubbleRob_z_pos</em>都執行相同的<em>操作</em>。這樣，在時間圖中只能看到<em>bubbleRob_obstacle_dist</em>數據流。以下是我們應該擁有的：<em></em><em></em><em></em></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/bubbleRobTut5.jpg"/></p>
<p class="imageLabel">[圖形屬性]</p>
<p>接下來，我們將建立一個顯示<em>BubbleRob</em>軌蹟的3D曲線：單擊編輯3D曲線打開<a href="https://www.coppeliarobotics.com/helpFiles/en/graphCurvePropertiesDialog.htm">XY圖和3D曲線對話框</a>，然後單擊添加新曲線。在對話框彈出打開，我們選擇<em>bubbleRob_x_pos</em>為X-值項，<em>bubbleRob_y_pos</em>為Y值項，<em>bubbleRob_z_pos</em>的Z值項目。我們將新添加的曲線從<em>Curve</em>重命名為bubbleRob_path。最後，我們檢查“ 相對於世界”項目並將“ 曲線寬度”設置為4：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/bubbleRobTut6.jpg"/></p>
<p class="imageLabel">[3D曲線屬性]</p>
<p></p>
<p>我們關閉與圖有關的所有對話框。現在我們將一個電機目標速度設置為50，運行模擬，然後將看到<em>BubbleRob的</em>軌跡顯示在場景中。然後，我們停止仿真並將電動機目標速度重置為零。</p>
<p>我們添加具有以下尺寸的純原始圓柱體：（0.1，0.1，0.2）。我們希望此圓柱體是靜態的（即不受重力或碰撞的影響），但仍會對非靜態的可響應形狀施加一些碰撞響應。為此，我們在<a href="https://www.coppeliarobotics.com/helpFiles/en/shapeDynamicsProperties.htm">形狀動力學屬性中</a>禁用“ 主體是動態的” 。我們也希望我們的汽缸是 <a href="https://www.coppeliarobotics.com/helpFiles/en/collidableObjects.htm">可碰撞</a>，<a href="https://www.coppeliarobotics.com/helpFiles/en/measurableObjects.htm">可衡量的</a>，<a href="https://www.coppeliarobotics.com/helpFiles/en/renderableObjects.htm">可渲染</a>和<a href="https://www.coppeliarobotics.com/helpFiles/en/detectableObjects.htm">檢測的</a>。我們在<a href="https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm">對象的通用屬性中</a>執行此操作。現在，在仍選擇圓柱體的情況下，我們單擊對象平移工具欄按鈕：<a href="https://www.coppeliarobotics.com/helpFiles/en/shapeDynamicsProperties.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/collidableObjects.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/measurableObjects.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/renderableObjects.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/detectableObjects.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm"></a></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/objectShiftButton.jpg"/></p>
<p></p>
<p>現在我們可以拖動場景中的任何點：圓柱體將跟隨運動，同時始終受約束以保持相同的Z坐標。我們複製並粘貼圓柱幾次，然後將它們移動到<em>BubbleRob</em>周圍的<em>位置</em>（從頂部查看場景時執行該操作最方便）。在對象移動期間，按住Shift鍵可以執行較小的移動步驟。按住ctrl鍵可以在與<em>常規</em>方向正交的方向上移動。完成後，再次選擇相機平移工具欄按鈕：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/cameraShiftButton.jpg"/></p>
<p></p>
<p>我們將左馬達的目標速度設置為50並運行模擬：現在，圖形視圖顯示了到最近障礙物的距離，並且該距離段在場景中也可見。我們停止模擬並將目標速度重置為零。</p>
<p>現在，我們需要完成BubbleRob作為<a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm">模型</a>定義。我們選擇模型庫（即對象<em>bubbleRob</em>），然後檢查項目Object是模型庫，並且Object / model可以轉移或接受<a href="https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm">對象</a>共有<a href="https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm">屬性</a>中的DNA：現在有一個點畫框，它包圍了模型層次結構中的所有對象。我們選擇兩個關節，即接近傳感器和圖形，然後啟用項目“不顯示為內部模型選擇”，然後在同一對話框中單擊“ 應用於選擇”：模型邊界框現在忽略了兩個關節和接近傳感器。仍在同一對話框中，我們禁用相機可見性圖層2，並為兩個關節和力傳感器啟用攝像機可見性層 10：這有效地隱藏了兩個關節和力傳感器，因為默認情況下禁用9-16層。任何時候我們都可以<a href="https://www.coppeliarobotics.com/helpFiles/en/layerSelectionDialog.htm">修改整個場景的可見性層</a>。要完成模型定義，我們選擇視覺傳感器，兩個輪子，滑塊和圖形，然後啟用“ 選擇模型基礎”項：如果現在嘗試在場景中的模型中選擇一個對象，則將選擇整個模型，這是一種將整個模型作為單個對象進行處理和操作的便捷方法。此外，這可以防止模型受到意外修改。仍然可以通過在按住Shift的同時單擊選擇對像或在場景層次結構中正常選擇它們，來在場景中選擇模型中的單個對象。最後，我們將模型樹折疊到場景層次中。這就是我們所擁有的：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/bubbleRobTut7.jpg"/></p>
<p class="imageLabel">[ <em>BubbleRob</em>模型定義]</p>
<p>接下來，我們將在與<em>BubbleRob</em>接近傳感器相同的位置和方向上添加<a href="https://www.coppeliarobotics.com/helpFiles/en/visionSensors.htm">視覺</a>傳感器。我們再次打開模型層次結構，然後單擊[菜單欄-&gt;添加-&gt;視覺傳感器-&gt;透視類型]，然後將視覺傳感器連接到接近傳感器，並將視覺傳感器的本地位置和方向設置為（0,0,0）。我們還確保視覺傳感器不可見，不是模型邊界框的一部分，並且如果單擊該模型，則會選擇模型。為了自定義視覺傳感器，我們打開<a href="https://www.coppeliarobotics.com/helpFiles/en/visionSensorPropertiesDialog.htm">其屬性</a>對話框。我們將遠裁剪平面項設置為1，將分辨率x和分辨率y設置為<em></em><a href="https://www.coppeliarobotics.com/helpFiles/en/visionSensorPropertiesDialog.htm"></a> 項目分別為256和256。我們向場景中添加了一個浮動視圖，然後在新添加的浮動視圖上，右鍵單擊[彈出菜單-&gt;視圖-&gt;將視圖與選定的視覺傳感器關聯]（我們確保視覺傳感器在該過程中被選中）。</p>
<p>通過單擊[菜單欄-&gt;添加-&gt;關聯的子腳本-&gt;非線程]，將非線程子腳本附加到視覺傳感器。我們雙擊場景層次結構中視覺傳感器旁邊出現的小圖標：這將打開我們剛剛添加的子腳本。我們將以下代碼複製並粘貼到<a href="https://www.coppeliarobotics.com/helpFiles/en/scriptEditor.htm">腳本編輯器中</a>，然後將其關閉：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">function sysCall_vision(inData)
    simVision.sensorImgToWorkImg(inData.handle) -- copy the vision sensor image to the work image
    simVision.edgeDetectionOnWorkImg(inData.handle,0.2) -- perform edge detection on the work image
    simVision.workImgToSensorImg(inData.handle) -- copy the work image to the vision sensor image buffer
end

function sysCall_init()
end</pre>
<p>為了能夠看到視覺傳感器的圖像，我們開始模擬，然後再次停止。</p>
<p>我們場景所需的最後一件事是一個小的<a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm">子腳本</a>，它將控制<em>BubbleRob的</em>行為。我們選擇<em>bubbleRob</em>並單擊[菜單欄-&gt;添加-&gt;關聯的子腳本-&gt;非線程]。我們雙擊場景層次結構中<em>bubbleRob</em>名稱旁邊顯示的腳本圖標，然後將以下代碼複製並粘貼到<a href="https://www.coppeliarobotics.com/helpFiles/en/scriptEditor.htm">腳本編輯器中</a>，然後將其關閉：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">function speedChange_callback(ui,id,newVal)
    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100
end

function sysCall_init()
    -- This is executed exactly once, the first time this script is executed
    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self) -- this is bubbleRob's handle
    leftMotor=sim.getObjectHandle("bubbleRob_leftMotor") -- Handle of the left motor
    rightMotor=sim.getObjectHandle("bubbleRob_rightMotor") -- Handle of the right motor
    noseSensor=sim.getObjectHandle("bubbleRob_sensingNose") -- Handle of the proximity sensor
    minMaxSpeed={50*math.pi/180,300*math.pi/180} -- Min and max speeds for each motor
    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode
    -- Create the custom UI:
        xml = '&lt;ui title="'..sim.getObjectName(bubbleRobBase)..' speed" closeable="false" resizeable="false" activate="false"&gt;'..[[
        &lt;hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/&gt;
        &lt;label text="" style="* {margin-left: 300px;}"/&gt;
        &lt;/ui&gt;
        ]]
    ui=simUI.create(xml)
    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5
    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))
end

function sysCall_actuation()
    result=sim.readProximitySensor(noseSensor) -- Read the proximity sensor
    -- If we detected something, we set the backward mode:
    if (result&gt;0) then backUntilTime=sim.getSimulationTime()+4 end 

    if (backUntilTime&lt;sim.getSimulationTime()) then
        -- When in forward mode, we simply move forward at the desired speed
        sim.setJointTargetVelocity(leftMotor,speed)
        sim.setJointTargetVelocity(rightMotor,speed)
    else
        -- When in backward mode, we simply backup in a curve at reduced speed
        sim.setJointTargetVelocity(leftMotor,-speed/2)
        sim.setJointTargetVelocity(rightMotor,-speed/8)
    end
end

function sysCall_cleanup()
	simUI.destroy(ui)
end</pre>
<pre class="lightRedBox"><br/><br/></pre>
<p>我們運行模擬。<em>BubbleRob</em>現在在嘗試避開障礙物的同時向前移動（以非常基本的方式）。在模擬仍在運行時，更改<em>BubbleRob的</em>速度，然後將其複制/粘貼幾次。在模擬仍在運行時，也嘗試擴展其中的一些。請注意，根據環境的不同，最小距離計算功能可能會嚴重降低仿真速度。您可以通過選中/取消選中“ 啟用所有距離計算”項，在“ <a href="https://www.coppeliarobotics.com/helpFiles/en/distanceCalculation.htm">距離”對話框中</a>打開和關閉該功能。</p>
<p>使用腳本控制機器人或模型只是一種方法。CoppeliaSim提供了許多不同的方法（也可以結合使用），請參閱<a href="https://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm">外部控制器教程</a>。</p>
<h2>Line following BubbleRob</h2>
<p><span>由40723210提供</span></p>
<p>在本教程中，我們旨在擴展BubbleRob的功能，以使他/她遵循地面上的規則。確保您已完全閱讀並理解第<a href="https://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm">一個BubbleRob教程</a>。本教程由Eric Rohmer提供。</p>
<p>在CoppeliaSim的安裝文件夾中的<em>tutorials / BubbleRob中</em>加載第一個BubbleRob教程的場景。與本教程相關的場景文件位於<em>tutorials / LineFollowingBubbleRob中</em>。下圖說明了我們將設計的仿真場景：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/lbubbleRobTut1.jpg"/></p>
<p></p>
<p>我們首先創建3個<a href="https://www.coppeliarobotics.com/helpFiles/en/visionSensors.htm">視覺傳感器</a>中的第一個，並將其附加到<em>bubbleRob</em>對象。選擇[菜單欄-&gt;添加-&gt;視覺傳感器-&gt;正交類型]。雙擊<a href="https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy">場景層次結構中</a>新創建的視覺傳感器圖標，編輯其屬性，然後更改參數以反映以下對話框：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/lbubbleRobTut2.jpg"/></p>
<p></p>
<p>視覺傳感器必鬚麵向地面，因此選擇它，然後在“ <a href="https://www.coppeliarobotics.com/helpFiles/en/orientationDialog.htm">方向”對話框</a>的“ 方向”選項卡上，將“ <em>Alpha</em> - <em>Beta</em> - <em>Gamma”</em>項設置為[180; 0; 0] 。</p>
<p>我們有幾種可能性可以讀取視覺傳感器。由於我們的視覺傳感器只有一個像素，並且操作簡單，因此我們只需查詢視覺傳感器讀取的圖像的平均強度值即可。對於更複雜的情況，我們可以設置<a href="https://www.coppeliarobotics.com/helpFiles/en/visionCallbackFunctions.htm">視覺回調函數</a>。現在，將視覺傳感器複製並粘貼兩次，並將其名稱調整為<em>leftSensor</em>，<em>middleSensor</em>和<em>rightSensor</em>。將<em>bubbleRob設置為</em>其父級（<em>即將</em>其附加到<em>bubbleRob</em>對象）。現在，您的傳感器在場景層次中應如下所示：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/lbubbleRobTut4.jpg"/></p>
<p></p>
<p>讓我們正確放置傳感器。對於使用<a href="https://www.coppeliarobotics.com/helpFiles/en/positionDialog.htm">位置對話框</a>中，在位置選項卡，並設置以下的絕對坐標：</p>
<p></p>
<ul>
<li>左傳感器：[0.2; 0.042; 0.018]</li>
<li>中間傳感器：[0.2; 0; 0.018]</li>
<li>右傳感器：[0.2; -0.042; 0.018]</li>
</ul>
<p></p>
<p>現在讓我們修改環境。我們可以移去BubbleRob前面的幾個圓柱體。接下來，我們將構建機器人將嘗試遵循的<a href="https://www.coppeliarobotics.com/helpFiles/en/paths.htm">路徑</a>。現在最好切換到頂視圖：通過<a href="https://www.coppeliarobotics.com/helpFiles/en/pagesAndViews.htm#pageSelector">頁面選擇器工具欄按鈕</a>選擇<a href="https://www.coppeliarobotics.com/helpFiles/en/pagesAndViews.htm">頁面</a> 4 。然後單擊[菜單欄-&gt;添加-&gt;路徑-&gt;圓圈類型]。<a href="https://www.coppeliarobotics.com/helpFiles/en/objectMovement.htm">使用鼠標</a>啟用<a href="https://www.coppeliarobotics.com/helpFiles/en/objectMovement.htm">對象移動</a>。您可以通過兩種方式調整路徑的形狀：<a href="https://www.coppeliarobotics.com/helpFiles/en/pagesAndViews.htm#pageSelector"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/objectMovement.htm"></a></p>
<p></p>
<ul>
<li>選擇路徑（並且只有路徑）後，按住Ctrl並單擊其<a href="https://www.coppeliarobotics.com/helpFiles/en/pathsControlPointsAndBezierPoints.htm">控制點之一</a>。然後可以將它們拖動到正確的位置。</li>
<li>選擇路徑後，進入<a href="https://www.coppeliarobotics.com/helpFiles/en/pathEditMode.htm">路徑編輯模式</a>。在那裡，您可以靈活地調整各個路徑控制點。</li>
</ul>
<p></p>
<p>對路徑的幾何形狀滿意（您隨時可以在以後的階段對其進行修改）後，選擇它，然後取消選中<a href="https://www.coppeliarobotics.com/helpFiles/en/pathPropertiesDialog.htm">路徑屬性</a>中的“ 顯示點的方向”，“ 顯示路徑線”和“ 顯示路徑上的當前位置”。然後單擊“ 顯示路徑整形對話框”。這將打開<a href="https://www.coppeliarobotics.com/helpFiles/en/pathShaping.htm">路徑整形對話框</a>。單擊“ 啟用路徑整形”，將類型設置為“ 水平線段”，然後將“ 縮放比例”<a href="https://www.coppeliarobotics.com/helpFiles/en/pathPropertiesDialog.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/pathShaping.htm"></a>到4.0。最後將顏色調整為黑色。我們必須對路徑進行最後一個重要的調整：當前，路徑的z位置與地板的z位置重合。結果是有時我們會看到路徑，有時會看到地板（這種效果在openGl行話中被稱為“ <em>z-fighting</em> ”）。這不僅影響我們所看到的，而且還會影響視覺傳感器所看到的。為了避免與z戰鬥有關的問題，只需將路徑對象的位置向上移動0.5毫米即可。</p>
<p>最後一步是調整BubbleRob的控制器，使其也將遵循黑色路徑。打開附著於<em>bubbleRob</em>的<a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm">子腳本</a>，並將其替換為以下代碼：<em></em></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">function speedChange_callback(ui,id,newVal)
    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100
end

function sysCall_init()
    -- This is executed exactly once, the first time this script is executed
    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self)
    leftMotor=sim.getObjectHandle("leftMotor")
    rightMotor=sim.getObjectHandle("rightMotor")
    noseSensor=sim.getObjectHandle("sensingNose")
    minMaxSpeed={50*math.pi/180,300*math.pi/180}
    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode
    floorSensorHandles={-1,-1,-1}
    floorSensorHandles[1]=sim.getObjectHandle("leftSensor")
    floorSensorHandles[2]=sim.getObjectHandle("middleSensor")
    floorSensorHandles[3]=sim.getObjectHandle("rightSensor")
    -- Create the custom UI:
        xml = '&lt;ui title="'..sim.getObjectName(bubbleRobBase)..' speed" closeable="false" resizeable="false" activate="false"&gt;'..[[
        &lt;hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/&gt;
        &lt;label text="" style="* {margin-left: 300px;}"/&gt;
        &lt;/ui&gt;
        ]]
    ui=simUI.reate(xml)
    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5
    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))
end

function sysCall_actuation()
    result=sim.readProximitySensor(noseSensor)
    if (result&gt;0) then backUntilTime=sim.getSimulationTime()+4 end

    -- read the line detection sensors:
    sensorReading={false,false,false}
    for i=1,3,1 do
        result,data=sim.readVisionSensor(floorSensorHandles[i])
        if (result&gt;=0) then
            sensorReading[i]=(data[11]&lt;0.3) -- data[11] is the average of intensity of the image
        end
        print(sensorReading[i])
    end

    -- compute left and right velocities to follow the detected line:
    rightV=speed
    leftV=speed
    if sensorReading[1] then
        leftV=0.03*speed
    end
    if sensorReading[3] then
        rightV=0.03*speed
    end
    if sensorReading[1] and sensorReading[3] then
        backUntilTime=sim.getSimulationTime()+2
    end

    if (backUntilTime&lt;sim.getSimulationTime()) then
        -- When in forward mode, we simply move forward at the desired speed
        sim.setJointTargetVelocity(leftMotor,leftV)
        sim.setJointTargetVelocity(rightMotor,rightV)
    else
        -- When in backward mode, we simply backup in a curve at reduced speed
        sim.setJointTargetVelocity(leftMotor,-speed/2)
        sim.setJointTargetVelocity(rightMotor,-speed/8)
    end
end

function sysCall_cleanup()
	simUI.destroy(ui)
end</pre>
<pre class="lightRedBox"><br/><br/></pre>
<p>您可以輕鬆地調試以下視覺傳感器的生產線：選擇一個，然後在場景視圖中選擇[右鍵-&gt;添加-&gt;浮動視圖]，然後在新添加的浮動視圖中選擇[右鍵-&gt;視圖- -&gt;將視圖與選定的視覺傳感器關聯]。</p>
<p>最後，刪除在第<a href="https://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm">一個BubbleRob教程</a>中添加的輔助項：刪除圖像處理視覺傳感器及其關聯的浮動視圖，該浮動視圖表示障礙物的清除。通過<a href="https://www.coppeliarobotics.com/helpFiles/en/distanceCalculation.htm">距離對話框</a>也刪除距離計算對象。而已！</p>
<h2>External controller tutorial</h2>
<p><span>由40723210提供</span></p>
<p><span><span>在CoppeliaSim中，有幾種方法可以控制機器人或仿真：</span></span></p>
<ul>
<li>The most convenient way is to write a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm">child script</a><span> </span>that will handle the behaviour of a given robot or<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm">model</a>. It is the most convenient way, because child scripts are directly attached to<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/objects.htm">scene objects</a>, they will be duplicated together with their associated scene objects, they do not need any compilation with an external tool, they can run in<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#threaded">threaded</a><span> </span>or<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#nonThreaded">non-threaded</a><span> </span>mode, they can be extended via<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiFunctionListCategory.htm#customizingLuaFunctions">custom Lua function</a><span> </span>or via a<span> </span><a href="http://luaforge.net/projects/">Lua extension library</a>. Another major advantage in using child scripts: there is no communication lag as with the last 3 methods mentioned in this section (i.e. the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm">regular API</a><span> </span>is used), and child scripts are part of the application main thread (inherent synchronous operation). There are several drawback to writing scripts however: you don't have the choice of the programming language, you can't have the fastest code, and you can't directly access external function libraries, except the Lua extension libraries.</li>
</ul>
<p></p>
<ul>
<li><span><span>最方便的方法是編寫一個</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm"><span><span>子腳本</span></span></a><span><span>，以處理給定機器人或</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm"><span><span>模型</span></span></a><span><span>的行為</span><span>。</span><span>這是最便捷的方式，因為孩子的腳本直接連接到</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/objects.htm"><span><span>場景中的對象</span></span></a><span><span>，他們將與它們相關的場景對象進行複製，他們不需要任何編譯與外部的工具，它們可以在運行</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#threaded"><span><span>線程</span></span></a><span><span>還是</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#nonThreaded"><span><span>非線程</span></span></a><span><span>模式，可以通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiFunctionListCategory.htm#customizingLuaFunctions"><span><span>自定義Lua函數</span></span></a><span><span>或</span></span><a href="http://luaforge.net/projects/"><span><span>Lua擴展庫對其進行擴展</span></span></a><span><span>。</span><span>使用子腳本的另一個主要優點：與本節中提到的後三種方法（即</span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm"><span>常規API）</span></a><span>一樣，沒有通信延遲</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm"><span></span></a><span><span>，並且子腳本是應用程序主線程的一部分（固有的同步操作）。</span><span>但是，編寫腳本有幾個缺點：您無法選擇編程語言，不能擁有最快的代碼，並且除了Lua擴展庫之外，您無法直接訪問外部函數庫。</span></span></li>
</ul>
<ul>
<li>Another way one can control a robot or a simulation is by writing a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/plugins.htm">plugin</a>. The plugin mechanism allows for callback mechanisms,<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiFunctionListCategory.htm#customizingLuaFunctions">custom Lua function registration</a>, and of course access to external function libraries. A plugin is often used in conjunction with child scripts (e.g. the plugin registers custom Lua functions, that, when called from a child script, will call back a specific plugin function). A major advantage in using plugins is also that there is no communication lag as with the last 3 methods mentioned in this section (i.e. the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm">regular API</a><span> </span>is used), and that a plugin is part of the application main thread (inherent synchronous operation). The drawbacks with plugins are: they are more complicated to program, and they need to be compiled with an external too. Refer also to the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/pluginTutorial.htm">plugin tutorial</a>.</li>
</ul>
<ul>
<li><span><span>可以控制機器人或模擬的另一種方法是編寫</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/plugins.htm"><span><span>插件</span></span></a><span><span>。</span><span>插件機制允許回調機制，</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiFunctionListCategory.htm#customizingLuaFunctions"><span><span>自定義Lua函數註冊</span></span></a><span><span>，當然還可以訪問外部函數庫。</span><span>插件通常與子腳本結合使用（例如，插件註冊自定義Lua函數，當從子腳本中調用時，該Lua函數將回調特定的插件函數）。</span><span>使用插件的一個主要優點是，與本節中提到的後3種方法（即</span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm"><span>常規API）</span></a><span>一樣，沒有通信延遲</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm"><span></span></a><span><span>（使用），並且插件是應用程序主線程的一部分（固有的同步操作）。</span><span>插件的缺點是：它們的編程更加複雜，並且也需要使用外部編譯。</span><span>另請參閱</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/pluginTutorial.htm"><span><span>插件教程</span></span></a><span><span>。</span></span><span><span></span></span></li>
</ul>
<ul>
<li>A third and forth way one can control a robot or a simulation is by writing an external client application that relies on the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm">remote API</a>. This is a very convenient and easy way, if you need to run the control code from an external application, from a robot or from another computer. This also allows you to control a simulation or a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm">model</a><span> </span>(e.g. a virtual robot) with the exact same code as the one that runs the real robot. The remote API comes in two versions: the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm">B0-based remote API</a>, and the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/legacyRemoteApiOverview.htm">legacy remote API</a>.</li>
</ul>
<ul>
<li><span><span>控制機器人或模擬的第三種方式是編寫依賴於</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm"><span><span>遠程API</span></span></a><span><span>的外部客戶端應用程序</span><span>。</span><span>如果您需要從外部應用程序，機器人或另一台計算機運行控制代碼，這是一種非常便捷的方法。</span><span>這還允許您</span><span>使用與運行真實機器人完全相同的代碼</span><span>來控制仿真或</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm"><span><span>模型</span></span></a><span><span>（例如，虛擬機器人）。</span><span>遠程API有兩個版本：</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm"><span><span>基於B0的遠程API</span></span></a><span><span>和</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/legacyRemoteApiOverview.htm"><span><span>舊版遠程API</span></span></a><span><span>。</span></span></li>
</ul>
<ul>
<li>A fifth way to control a robot or a simulation is via a<span> </span><a href="http://www.ros.org/">ROS</a><span> </span>node. In a similar way as the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm">remote API</a>, ROS is a convenient way to have several distributed processes communicate with each other. While the remote API is very lightweight and fast, it allows only communication with CoppeliaSim. ROS on the other hand allows connecting virtually any number of processes with each other, and a large amount of compatible libraries are available. It is however heavier and more complicated than the remote API. Refer to the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterfaces.htm">ROS interfaces</a><span> </span>for details.</li>
</ul>
<ul>
<li><span><span>控制機器人或仿真的第五種方法是通過</span></span><a href="http://www.ros.org/"><span><span>ROS</span></span></a><span><span>節點。</span><span>ROS<span> </span></span><span>與</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm"><span><span>遠程API</span></span></a><span><span>相似</span><span>，是使多個分佈式進程相互通信的便捷方法。</span><span>儘管遠程API非常輕巧且快速，但它僅允許與CoppeliaSim通信。</span><span>另一方面，ROS允許幾乎將任意數量的進程相互連接，並且提供了大量兼容的庫。</span><span>但是，它比遠程API重並且更複雜。</span><span>有關詳細信息，</span><span>請參閱</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterfaces.htm"><span><span>ROS接口</span></span></a><span><span>。</span></span></li>
</ul>
<ul>
<li>A sixth way to control a robot or a simulation is via a<span> </span><a href="https://github.com/CoppeliaRobotics/bluezero" target="_blank">BlueZero</a><span> </span>(BØ) node. In a similar way as ROS, BlueZero is a convenient way to have several distributed processes communicate with each other, and is a lightweight and cross-platform solution. Refer to the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/blueZeroPlugin.htm">BlueZero interface</a><span> </span>for details.</li>
</ul>
<ul>
<li><span><span>控制機器人或模擬的第六種方法是通過</span></span><a href="https://github.com/CoppeliaRobotics/bluezero" target="_blank"><span><span>BlueZero</span></span></a><span><span>（BØ）節點。</span><span>與ROS類似，BlueZero是使多個分佈式進程相互通信的一種便捷方法，並且是一種輕量級的跨平台解決方案。</span><span>有關詳細信息，</span><span>請參考</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/blueZeroPlugin.htm"><span><span>BlueZero界面</span></span></a><span><span>。</span></span><span><span></span></span></li>
</ul>
<ul>
<li>A seventh way to control a robot or a simulation is by writing an external application that communicates via various means (e.g. pipes, sockets, serial port, etc.) with a CoppeliaSim plugin or CoppeliaSim script. Two major advantages are the choice of programming language, which can be just any language, and the flexibility. Here also, the control code can run on a robot, or a different computer. This way of controlling a simulation or a model is however more tedious that the methods with the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm">remote API</a>.</li>
</ul>
<ul>
<li><span><span>控制機器人或模擬的第七種方法是編寫一個外部應用程序，該應用程序通過各種方式（例如管道，套接字，串行端口等）與CoppeliaSim插件或CoppeliaSim腳本進行通信。</span><span>選擇編程語言（可以是任何一種語言）和靈活性是兩個主要優點。</span><span>同樣，控制代碼也可以在機器人或其他計算機上運行。</span><span>但是，與使用</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm"><span><span>遠程API</span></span></a><span><span>的方法相比，這種控制仿真或模型的方法更加乏味</span><span>。</span></span><span><span></span></span></li>
</ul>
<hr/>
<p><span><span>有8個與本教程相關的場景文件：</span></span></p>
<ul>
<li><em>scenes/controlTypeExamples/controlledViaScript</em>: one robot is controlled via a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#nonThreaded">non-threaded child script</a>, the other is controlled via a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#threaded">threaded child script</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaPlugin</em>: the robot is controlled via a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/plugins.htm">plugin</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaB0RemoteApi</em>: the robot is controlled via the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm">B0-based remote API</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaLegacyRemoteApi</em>: the robot is controlled via the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/legacyRemoteApiOverview.htm">legacy remote API</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaB0</em>: the robot is controlled via the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/blueZeroPlugin.htm">BlueZero interface</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaRos</em>: the robot is controlled via the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterf.htm">ROS interface</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaRos2</em>: the robot is controlled via the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterf.htm">ROS2 interface</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaTcp</em>: the robot is controlled via<span> </span><a href="http://w3.impa.br/~diego/software/luasocket/">LuaSocket</a><span> </span>and TCP.</li>
</ul>
<hr/>
<p></p>
<ul>
<li><span><span><em>scenes/controlTypeExamples/controlledViaScript</em><span>:</span>一個機器人通過控制</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#nonThreaded"><span><span>非螺紋子腳本</span></span></a><span><span>，另一種是通過受控的</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#threaded"><span><span>螺紋子腳本</span></span></a><span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaPlugin</em>：機器人是通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/plugins.htm"><span><span>插件</span></span></a><span><span>控制的</span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaB0RemoteApi</em>：通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm"><span><span>基於B0的遠程API</span></span></a><span><span>來控制機器人</span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaLegacyRemoteApi</em>：通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/legacyRemoteApiOverview.htm"><span><span>舊版遠程API</span></span></a><span><span>控制機器人</span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaB0</em>：通過</span><a href="https://www.coppeliarobotics.com/helpFiles/en/blueZeroPlugin.htm"><span>BlueZero界面</span></a><span>控制機器人</span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaRos</em>：通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterf.htm"><span><span>ROS接口</span></span></a><span><span>控制機器人</span><span>。</span></span></li>
<li><span><span><em>cenes/controlTypeExamples/controlledViaRos2</em>：通過</span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterf.htm"><span>ROS2接口</span></a><span>控制機器人</span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaTcp</em>：機器人是通過</span><a href="http://w3.impa.br/~diego/software/luasocket/"><span>LuaSocket</span></a><span>和TCP<span> </span></span><span>控制的</span><span>。</span></span></li>
</ul>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/externalControllerTut1.jpg"/></p>
<p><span><span>在所有8種情況下，</span><span>都使用</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm"><span><span>子腳本</span></span></a><span><span>，主要是為了與外界建立鏈接（例如，啟動正確的客戶端應用程序，並將正確的對象句柄傳遞給它）。</span><span>有兩種方法可以控制機器人，仿真程序或仿真程序本身：通過使用</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/customizationScripts.htm"><span><span>自定義腳本</span></span></a><span><span>或</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/addOns.htm"><span><span>加載項</span></span></a><span><span>。</span><span>但是，不建議將它們用於控制，而應在不運行模擬時將其用於處理功能。</span></span></p>
<p><span><span>例如，鏈接到場景</span></span><em><span><span>控制</span></span></em><span><span>的ViaB0RemoteApi.ttt中的機器人的子腳本</span><span>具有以下主要任務：</span></span></p>
<ul>
<li><span><span>使用某些對象句柄作為參數</span><span>啟動控制器應用程序（</span></span><a href="https://github.com/CoppeliaRobotics/b0RemoteApiBindings/tree/master/cpp/bubbleRobClient" target="_blank"><span><span>bubbleRobClient_b0RemoteApi</span></span></a><span><span>）。</span><span>基於對象B0的遠程API的服務器功能由對象</span></span><em><span><span>b0RemoteApiServer</span></span></em><span><span>提供</span><span>。</span></span></li>
</ul>
<p><span><span>作為另一個示例，鏈接到場景</span></span><em><span><span>控制</span></span></em><span><span>的ViaRos.ttt中的機器人的子腳本</span><span>具有以下主要任務：</span></span></p>
<ul>
<li><span><span>檢查是否</span><span>已加載CoppeliaSim<span> </span></span><span>的</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterf.htm"><span><span>ROS接口</span></span></a><span></span></li>
<li><span><span>使用某些主題名稱或對象句柄作為參數</span><span>啟動控制器應用程序（</span></span><a href="https://github.com/CoppeliaRobotics/ros_bubble_rob" target="_blank"><span><span>rosBubbleRob</span></span></a><span><span>）</span></span></li>
</ul>
<p><span><span>然而，作為另一個示例，鏈接到場景</span></span><em><span><span>控制</span></span></em><span><span>的ViaTcp.ttt中的機器人的子腳本</span><span>具有以下主要任務：</span></span></p>
<ul>
<li><span><span>搜索空閒的套接字連接端口</span></span></li>
<li><span><span>使用所選的連接端口作為參數</span><span>啟動控制器應用程序（</span></span><a href="https://github.com/CoppeliaRobotics/bubbleRobServer" target="_blank"><span><span>bubbleRobServer</span></span></a><span><span>）</span></span></li>
<li><span><span>本地連接到控制器應用程序</span></span></li>
<li><span><span>在每次仿真過程中，將傳感器值發送到控制器，並從控制器讀取所需的電機值</span></span></li>
<li><span><span>在每次模擬過程中，將所需的電機值應用於機器人的關節</span></span></li>
</ul>
<p><span><span>運行模擬，然後復制並粘貼機器人：您將看到重複的機器人將直接運行，因為附加的子腳本負責啟動各自外部應用程序的新實例，或調用適當的插件函數。</span></span></p>
<h2>Simulation</h2>
<p><span>由40723210提供</span></p>
<p><span>可以使用[菜單欄-&gt;模擬-&gt;開始/暫停/停止模擬]或通過相關的工具欄按鈕來啟動，暫停和停止CoppeliaSim中的模擬：</span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulation1.jpg"/></p>
<p class="imageLabel"><span><span>[模擬開始/暫停/停止工具欄按鈕]</span></span></p>
<p><span><span>在內部，模擬器將使用其他中間狀態，以正確告知</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/scripts.htm"><span><span>腳本</span></span></a><span><span>或程序接下來將發生的情況。</span><span>以下狀態圖說明了模擬器的內部狀態：</span></span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulation2.jpg"/></p>
<p class="imageLabel"><span><span>[模擬狀態圖]</span></span></p>
<p><span><span>腳本和程序應始終根據當前系統調用功能以及可能的</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/regularApi/simGetSimulationState.htm"><span><span>模擬狀態進行反應</span></span></a><span><span>，以便正確運行。</span><span>優良作法是將每個控制代碼分成至少4個系統調用函數（例如，用於</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#nonThreaded"><span><span>非線程子腳本</span></span></a><span><span>）：</span></span></p>
<p></p>
<ul>
<li><strong><span><span>初始化函數</span></span></strong><span><span>：</span><strong><strong><span>sysCall_init</span></strong></strong><span>：僅在腳本初始化時才調用該函數。</span></span><strong><strong><span></span></strong></strong><span></span></li>
<li><strong><span></span></strong><span><strong><strong><span>激勵</span></strong></strong><strong><span>函數</span></strong><span>：</span><strong><strong><span>sysCall_actuation</span></strong></strong><span>：應在發生激勵時調用該函數。</span></span><strong><strong><span></span></strong></strong><span></span></li>
<li><strong><span><span>Sensing函數</span></span></strong><span><span>：</span><strong><strong><span>sysCall_sensing</span></strong></strong><span>：應在發生傳感時調用此函數。</span></span><strong><strong><span></span></strong></strong><span></span></li>
<li><strong><span><span>清理函數</span></span></strong><span><span>：</span><strong><strong><span>sysCall_cleanup</span></strong></strong><span>：在取消初始化腳本之前（例如，在模擬結束時或銷毀腳本時）調用該函數。</span></span><strong><strong><span></span></strong></strong><span></span></li>
</ul>
<p></p>
<p><span><span>有關如何安排典型腳本的示例，請參考</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/mainScript.htm"><span><span>main腳本</span></span></a><span><span>，</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm"><span><span>子腳本</span></span></a><span><span>和</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/customizationScripts.htm"><span><span>自定義腳本</span></span></a><span><span>頁面。</span></span></p>
<h4><span><strong>仿真循環</strong></span></h4>
<p><span><span>模擬器通過以恆定的時間步長推進模擬時間來進行操作。</span><span>下圖說明了主要的仿真循環：</span></span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulation3.jpg"/></p>
<p class="imageLabel"><span><span>[主仿真循環]</span></span></p>
<p><span><span>通過嘗試使仿真時間與實時保持同步來支持實時仿真：</span></span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulation4.jpg"/></p>
<p class="imageLabel"><span><span>[實時仿真循環]</span></span></p>
<p><span><span>以下是一個非常簡化的</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/mainClientApplication.htm"><span><span>主客戶端應用程序</span></span></a><span><span>（</span><span>為清晰起見，已省略了</span><span>消息，</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/plugins.htm"><span><span>插件</span></span></a><span><span>處理和其他詳細信息）：</span></span></p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">void initializationCallback
{
    // do some initialization here
}

void loopCallback
{
    if ( (simGetSimulationState()&amp;sim_simulation_advancing)!=0 )
    {
        if ( (simGetRealTimeSimulation()!=1)||(simIsRealTimeSimulationStepNeeded()==1) )
        {
            if ((simHandleMainScript()&amp;sim_script_main_script_not_called)==0)
                simAdvanceSimulationByOneStep();
        }
    }
}

void deinitializationCallback
{
    // do some clean-up here
}</pre>
<p><span><span>取決於仿真的複雜性，計算機的性能和</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/simulationPropertiesDialog.htm"><span><span>仿真設置</span></span></a><span><span>，實時仿真可能並不總是可能的。</span></span></p>
<h4><strong><span>仿真速度</span></strong></h4>
<p><span><span>在非實時仿真中，仿真速度（即感知速度）主要取決於兩個因素：仿真時間步長和一個渲染通道的仿真通道數量（</span><span>有關更多詳細信息，</span><span>請參見</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/simulationPropertiesDialog.htm"><span><span>仿真對話框</span></span></a><span><span>）。</span><span>在實時仿真的情況下，仿真速度主要取決於實時乘法係數，而且在一定程度上取決於仿真時間步長（太小的仿真時間步長可能與實時時間不兼容）。由於計算機的計算能力有限，因此無法進行仿真。</span><span>在模擬過程中，可以使用以下工具欄按鈕來調整模擬速度：</span></span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulation5.jpg"/></p>
<p class="imageLabel"><span><span>[模擬速度調整工具欄按鈕]</span></span></p>
<p><span><span>以某種方式調整模擬速度，以使初始模擬時間步長永遠不會增加（例如，這可能因此而導致機制中斷）。</span><span>以下兩個圖說明了仿真速度調整機制：</span></span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulation6.jpg"/></p>
<p class="imageLabel"><span><span>[<span> </span></span></span><strong><span><span>非實時</span></span></strong><span><span>模擬的模擬速度調整機制</span><span>]</span></span></p>
<p></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulation7.jpg"/></p>
<p class="imageLabel"><span><span>[用於</span></span><strong><span><span>實時</span></span></strong><span><span>仿真的仿真速度調整機制</span><span>]</span></span></p>
<p><span><span>默認情況下，每個模擬週期由以下</span></span><strong><span><span>順序</span></span></strong><span><span>操作</span><span>組成</span><span>：</span></span></p>
<p></p>
<ul>
<li><span><span>執行</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/mainScript.htm"><span><span>主腳本</span></span></a></li>
<li><span><span>渲染場景</span></span></li>
</ul>
<h4><strong><span>螺紋渲染</span></strong></h4>
<p></p>
<p><span><span>渲染操作將始終增加仿真週期的持續時間，從而也降低了仿真速度。</span><span>可以定義每個場景渲染的主腳本執行次數（請參閱後面的內容），但這在某些情況下還不夠，因為渲染仍然會減慢每個第x個模擬週期的時間（這可能會限制實時性）。</span><span>在這種情況下，可以通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/settings.htm"><span><span>用戶設置</span></span></a><span><span>或以下工具欄按鈕</span><span>激活線程渲染模式</span><span>：</span></span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/threadedRenderingButton.jpg"/></p>
<p class="imageLabel"><span><span>[線程渲染工具欄按鈕]</span></span></p>
<p><span><span>激活線程渲染模式後，模擬週期將僅包括執行</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/mainScript.htm"><span><span>主腳本</span></span></a><span><span>，因此模擬將以最大速度運行。</span><span>渲染將通過不同的線程進行，並且不會減慢模擬任務的速度。</span><span>然而，必須考慮缺點。</span><span>激活線程渲染後，：</span></span></p>
<p></p>
<ul>
<li><span><span>渲染將與模擬循環異步進行，並且可能會出現視覺故障</span></span></li>
<li><span><span>該</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/aviRecorder.htm"><span><span>錄像機</span></span></a><span><span>將不以恆定速度運轉（某些幀可能會跳過）</span></span></li>
<li><span><span>應用程序的穩定性可能會降低</span></span></li>
<li><span><span>某些操作（例如擦除對像等）需要等待渲染線程完成工作才能執行，反之亦然。</span><span>在那些情況下，循環可能比順序渲染模式花費更多的時間。</span></span></li>
</ul>
<p></p>
<h2>Simulation dialog</h2>
<p><span>由40723210提供</span></p>
<p><span>可以通過[菜單欄-&gt;模擬-&gt;模擬設置]或單擊以下工具欄按鈕來訪問模擬對話框：</span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulationDialog1.jpg"/></p>
<p class="imageLabel"><span><span>[模擬工具欄按鈕]</span></span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulationDialog2.jpg"/></p>
<p class="imageLabel"><span><span>[模擬設置對話框]</span></span></p>
<ul>
<li><strong><span><span>時間步</span></span></strong><span><span>：</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/simulation.htm"><span><span>模擬</span></span></a><span><span>時間步。</span><span>每次</span><span>執行</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/mainScript.htm"><span><span>主腳本</span></span></a><span><span>時，仿真時間都會增加仿真時間步長。</span><span>使用較大的時間步會導致快速但不准確/不穩定的仿真。</span><span>另一方面，較小的時間步長（通常）會導致更精確的仿真，但是會花費更多時間。</span><span>強烈建議保留默認時間步長。</span></span></li>
<li><strong><span><span>每幀模擬遍數（ppf）</span></span></strong><span><span>：一個渲染遍的模擬遍數。</span><span>值為10表示刷新屏幕之前，主腳本已執行10次（10個模擬步驟）。</span><span>如果您的圖形卡較慢，則可以選擇僅顯示兩幅中的一幅。</span></span></li>
<li><strong><span><span>當仿真時間高於時暫停</span></span></strong><span><span>：允許指定仿真時間，在該時間暫停仿真（例如，能夠在特定仿真時間分析某些結果）。</span></span></li>
<li><strong><span><span>暫停腳本錯誤</span></span></strong><span><span>：如果啟用，則在發生</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/scripts.htm"><span><span>腳本</span></span></a><span><span>錯誤時</span><span>將暫停仿真</span><span>。</span></span></li>
<li><strong><span><span>模擬開始時全屏</span></span></strong><span><span>：如果啟用，則模擬以全屏模式開始。</span><span>請注意，在全屏模式下，對話框和消息將不會出現或不可見，只有鼠標左鍵處於活動狀態。</span><span>因此，僅在正確配置場景並最終確定場景後才建議使用該模式。</span><span>可以使用esc鍵保留全屏模式，並</span><span>在仿真過程中</span><span>通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiConstants.htm#booleanParameters"><span><span>布爾參數</span></span></a><span> </span><em><span><span>sim_booparam_fullscreen</span></span></em><span><span>進行</span><span>切換<span> </span></span><span>。</span><span>Unler Linux和MacOS可能僅部分支持全屏模式，並且在某些系統上切換回普通模式可能會失敗。</span></span></li>
<li><strong><span><span>實時仿真，倍增係數</span></span></strong><span><span>：如果選擇，則仿真時間將嘗試跟隨實時。</span><span>X的乘數將使仿真運行比實時快X倍。</span></span></li>
<li><strong><span><span>落後時嘗試趕上</span></span></strong><span><span>：在實時仿真過程中，仿真時間可能無法實時跟踪（例如，由於某些瞬間繁重的計算）。</span><span>在這種情況下，如果選中此復選框，則模擬時間將嘗試趕上損失的時間（例如，當計算負載再次減少時），這會明顯提高速度。</span></span></li>
<li><strong><span><span>復位場景初始狀態</span></span></strong><span><span>：當被選擇時，那麼所有</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/objects.htm"><span><span>的對象</span></span></a><span><span>將被復位到它們的初始狀態：包括對象的本地位置，局部方向和它的父（只要該對象沒有另外修飾的（例如縮放）），</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/joints.htm"><span><span>關節</span></span></a><span><span>以及</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/paths.htm"><span><span>路徑的</span></span></a><span><span>固有位置，浮動</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/pagesAndViews.htm"><span><span>視圖</span></span></a><span><span>位置和大小等。這意味著除非進行了重大更改（</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/shapes.htm"><span><span>形狀</span></span></a><span><span>縮放，對象移除等）</span><span>，否則下一次模擬運行將以與上一次相同的方式執行</span><span>。</span><span>此項目將忽略一些次要設置。</span></span></li>
<li><strong><span><span>刪除新對象</span></span></strong><span><span>：選中該選項後，在仿真運行期間添加的場景對象將在仿真結束時被刪除。</span></span></li>
</ul>