<h1>Weeks</h1>
<p><a href="https://s40723210.github.io/cd2020/content/Week1-5.html">Week1-5</a></p>
<p><a href="https://s40723210.github.io/cd2020/content/Week6-9.html">Week6-9</a></p>
<p><a href="https://s40723210.github.io/cd2020/content/Week10-14.html">Week10-14</a></p>
<p><a href="https://s40723210.github.io/cd2020/content/Week15-18.html">Week15-18</a></p>
<h2>Week1-5</h2>
<h4 class="post-title entry-title" itemprop="name"><strong>建立個人cd2020倉儲</strong></h4>
<p><span>1.下載<a href="https://drive.google.com/file/d/1fxMdqdCoCL__O1IpZ-Sv-A_4-c77Wx4E/view?usp=sharing">2019Fall可攜套件.7z</a>，完成後開啟start。</span><span><br/></span><span></span><span><span>2.先登入自己的github帳號，</span><span>創建一個新的倉儲cd2020。</span></span><span><span><br/></span><span>3.進入要存放該資料的資料夾tmp。</span></span><span><span><br/></span></span><span></span><span><span>4.git clone </span><span>https://github.com/s40723210/cd2020 。</span><span><br/></span><span>5.</span><span>git submodule add https://github.com/mdecourse/cmsimde.git。</span></span><span><span><br/>6.再進入cmsimde，將up_dir的所有項目複<span>製到cd2020</span>。</span></span><span><span><br/>7.完成後，python wsgi.py 開始編輯倉儲。<br/></span></span><span><span>8.login密碼為admin，gitconfig要有帳號密碼。</span></span><span><span><br/>9.處理完，git status &gt; git add . &gt; git commit -m "標題" &gt; git push。</span></span><span><span><br/>10.開啟github倉儲設定，點選要推送的branch即可。<br/></span></span></p>
<p><span>我的教學影片:<a href="https://youtu.be/jBFzju1F43s">https://youtu.be/jBFzju1F43s<br/><br/><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/jBFzju1F43s" width="560"></iframe></a></span></p>
<hr color="00ffee"/>
<h4><strong>Updated Python 3.8.2</strong></h4>
<p>1.從Python<a href="https://www.python.org/">官方網站</a>，下載3.8.2版本的<a href="https://www.python.org/ftp/python/3.8.2/python-3.8.2.exe">安裝檔</a>。</p>
<p>2.完成後開啟，點選<span>Customize installation(定制安裝)。</span></p>
<p>3.將第二個選項的pip取消勾選，其他都可以勾選起來。</p>
<p>4.使用預設勾選，將路徑改為y槽的py382資料夾(自己創建)。</p>
<p>5.用編輯器來開啟<span>start_mdecourse.bat檔案。</span></p>
<p>6.<span>將</span><span>檔中的py373全部都改成py382後，重新啟動。</span></p>
<p>7.直接在y槽中執行，python <span>get-pip.py 來安裝pip軟件。</span></p>
<p><span>8.完成之後，來安裝軟件包，輸入 pip install <span style="color: #ff0000;">Flask</span> 依此類推。</span></p>
<p>9.安裝的有<span style="color: #ff0000;">Flask</span>、<span style="color: #ff0000;">Markdown</span>、<span style="color: #ff0000;">lxml</span>、<span style="color: #ff0000;">bs4</span>、<span style="color: #ff0000;">flask_cors</span>、<span style="color: #ff0000;">pelican</span>、<span style="color: #ff0000;">leo</span>。</p>
<p>我的教學影片:<a class="style-scope ytcp-video-share-dialog" href="https://youtu.be/Im6e8ZD1-Xo" id="watch-url" target="_blank">https://youtu.be/Im6e8ZD1-Xo</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/Im6e8ZD1-Xo" width="560"></iframe></p>
<hr color="00ffee"/>
<h4><strong>分配工作和問題討論</strong></h4>
<p>40623115 亂數分組程式<br/>40623251 可攜系統<br/>40723204 可攜系統<br/>42723210 四輪車<br/>40723212 四輪車<br/>40723225 四輪車<br/>40723232 亂數分組程式<br/>40723234 可攜系統<br/>40723238 四輪車<br/>40723245 亂數分組程式<br/>40723250 亂數分組程式</p>
<p>負責各主題的人，主要以課堂上的進度，來更新個人的倉儲，每次更新進度時要做一下紀錄。所有的主題必須要在<span>2020年3月26日之前完成，提交3-5頁的兩欄pdf報告，並在youtube上保存3-5分鐘的影片，將pdf文件放在個人倉儲 downloads / assignment1.pdf。最後整合的作業以assignment1放在自己的網站連結加/ assignment1內。有問題可以在我的 <a href="https://gitter.im/40723210/cd2020">gitter</a> 以及 老師的 <a href="https://gitter.im/mdecourse/cd2020">gitter</a> 上面發問，會的人也可以幫忙回答。<br/></span><br/>直播影片:<a href="https://www.youtube.com/watch?v=r0AABAp474U">https://www.youtube.com/watch?v=r0AABAp474U</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/r0AABAp474U" width="560"></iframe></p>
<hr color="00ffee"/>
<h4>New pull request</h4>
<p>1.先登入github，點進去想要fork的倉儲。<br/><br/>2.點選右上角的Fork，再選擇自己的github。<br/><br/>3.git clone --recurse-submodules (倉儲網址)。<br/><br/>4.更新git push完成，點選New pull request，等組長同意。<br/><br/>5.組員要進行更新時，要記得先git pull (分組網址) 檢查版本。<br/><br/>6.有衝突的話，組長要處理和整合分支並且解決衝突。<br/><br/>我的教學影片:<a href="https://youtu.be/1bZ16BgmF8c">https://youtu.be/1bZ16BgmF8c</a><a href="https://youtu.be/1bZ16BgmF8c"></a></p>
<p><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/1bZ16BgmF8c" width="560"></iframe></p>
<hr color="00ffee"/>
<p></p>
<h1>assignment1</h1>
<p></p>
<p><iframe height="600" src="http://www.wibibi.com/info.php?tid=366" width="800"></iframe></p><h2>亂數分組程式</h2>
<p>1.請描述如何針對該課程進行有效的隨機分組，或者隨機進行點名？</p>
<p>可以去這裡測試程式:<a href="https://repl.it/languages/python3" target="_blank">https://repl.it/languages/python3</a></p>
<h4><strong><span style="color: #0000ff;">抽查的python程式</span></strong></h4>
<p>如果要使用python來進行亂數分組抽查的話，可以導入random來從列表中隨機抽出所需要的n個不同元素，如下面的程式執行之後，就可以亂數抽出4位。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import random 

group = [4, 10, 12, 25, 32, 34, 38, 45, 50] 

team = random.sample(group, 4) 
print (team)</pre>
<p>再來是要讀取網頁資料的話，就要導入requests，使用get請求即可直接下載，例如member = requests.get("網址")，再用print(member.text)就可以印出來了如下。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import requests

web = "https://mdecourse.github.io/cd2020/downloads/2b_group_list.txt"

member = requests.get(web)

print(member.text)</pre>
<p>如果使用讀取出的資料，還是無法使用的，因為member.text的性質是str字串，所以我就要將它變回原本的list列表，才可以進行亂數分組，改這個非常的簡單如下。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">x = eval(member.text)</pre>
<p>最後我整理出來的程式，雖然沒有老師這麼精美，但是也是可以進行亂數分組的抽查的，如果要改抽查人數，改y = random.sample(i,2)的數字即可。</p>
<h4><span style="color: #ff6600;"><span color="#0000ff"><b>最終程式碼</b></span></span></h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import requests
import random
 
web = "https://mdecourse.github.io/cd2020/downloads/2b_group_list.txt"
member = requests.get(web)
#print(memder.text)
x=0
for i in eval(member.text):
    y = random.sample(i,2)
    x+=1
    print("group"+ str(x))
    print(y)</pre>
<h4><strong><span style="color: #0000ff;">亂數分組的的python程式</span></strong></h4>
<p><strong></strong>一開始先從網頁上抓人員，這次跟上面的不太一樣，抓出來的本來就是str字串，所以必須把每個學號轉變為<span>list列表，直接將f.text加上 .split() 來轉換，完成之後就可以使用，random.shuffle()來將整個順序打亂，再來設定一共要分幾組，再使用while迴圈來判斷每一組要有幾個人，使用if判斷是來中斷迴圈，len()是指一共有幾個數量的意思，要加組別的話就要再多寫一列，接著使用for 迴圈來從，剛剛算好的每組人數，例如:13、12、12、12，再使用一個for迴圈，來一個一個配置組人員，這時候直接使用迭代iter()的next()，來抓人員這樣之就不會重複了，最後再加上一些說明、分格、標題，就可以開始進行亂數分組了。</span></p>
<h4><span style="color: #ff6600;"><span color="#0000ff"><b>最終程式碼</b></span></span></h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import requests
import random

web = "http://s1.mde.nfu.edu.tw:8000/?semester=1082&amp;courseno=0780"
f = requests.get(web)
#print(type(f.text))
x = f.text.split()
#print(len(x))
#print(x)
random.shuffle(x)

group1,group2,group3,group4 = 0,0,0,0
while 1==1:
    group1 += 1
    if (group1+group2+group3+group4) == len(x):
        break
    group2 += 1
    if (group1+group2+group3+group4) == len(x):
        break
    group3 += 1
    if (group1+group2+group3+group4) == len(x):
        break
    group4 += 1
    if (group1+group2+group3+group4) == len(x):
        break
#print(group1,group2,group3,group4)

print("全班人數有"+str(len(x))+"人")
print("="*20)
num = group1,group2,group3,group4
a = iter(x)
team = 0
for i in num:
    team += 1
    print("group"+str(team)+" 共 "+str(i)+" 人")
    for g in range(i):
        print(next(a))
    print("-" * 20)</pre>
<p></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace

# Brython 3.3.4 內建的 container 名稱為  'container' 且 turtle 輸出為 svg 必須使用 div 訂定 id
Ace = ace.Editor(editor_id="kw_editor", console_id="kw_console", container_id="kw__container", storage_id="kw_py_src" )

Ace.editor.setValue("""# 導入 sys 模組
import sys
# 導入 keyword 模組
import keyword

def helloWorld():
    print("Hello World!")

helloWorld()

# 利用 sys 模組中的 version_info 印出 Python 版次
print("Python version: ", sys.version_info)
# 利用 keyword 模組中的 kwlist 印出關鍵字
print("Python keywords: ", keyword.kwlist)
""")
Ace.editor.scrollToRow(0)
Ace.editor.gotoLine(0)

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run'].bind('click', Ace.run)
doc['kw_show_console'].bind('click', Ace.show_console)
doc['kw_clear_console'].bind('click', Ace.clear_console)
</script>
</p><h2>可攜編程系統</h2>
<p>2.描述如何為Windows 10 64位系統準備一個可移植的Python編程系統，以允許在Github上維護CMSiMDE網站，Pelican博客和Reveal.js演示文稿？</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">@echo off
set Disk=y
subst %Disk%: "data"

%Disk%:

set HomePath=%Disk%:\home_mdecourse
set HomeDrive=%Disk%:\home_mdecourse
set Home=%Disk%:\home_mdecourse
set USERPROFILE=%Disk%:\home_mdecourse

REM 將系統 Python 程式的 io 設為 utf-8
set PYTHONIOENCODING="utf-8"

set PYTHONPATH=%Disk%:\py382\DLLs;%Disk%:\py382\Lib;%Disk%:\py382\Lib\site-packages;
set PYTHONHOME=%Disk%:\py382

set path_python=%Disk%:\py382;%Disk%:\py382\Scripts;
set path_msys2=%Disk%:\msys64\mingw64\bin;
REM coreutils is for compiling fossil scm
set path_coreutils=%Disk%:\coreutils-5.3.0\bin;%Disk%:\depends22_x64;
set path_tcc=%Disk%:\tcc;
set path_cmake=%Disk%:\cmake-3.10.1-win64-x64\bin;
set path_nodejs=Disk%:\nodejs;%Disk%:\nodejs\appdata\roaming\npm;
set path_git=%Disk%:\portablegit\bin;
set path_xming=%Disk%:\Xming;
set path_latex=%%Disk%:\Pandoc;%Disk%:\TinyTeX\bin\win32;

set GIT_HOME=%Disk%:\portablegit\bin\
set GIT_SSH=%Disk%:\putty\plink.exe

path=%Disk%:;%path_python%;%path_msys2%;%path_tcc%;%path_git%;%path_cmake%;%path_coreutils%;%path%;

start /MIN cmd.exe
start /MIN cmd.exe
start /MIN cmd.exe

start /MIN %Disk%:\wscite415\wscite\SciTE.exe
start /MIN %Disk%:\wscite415\wscite\SciTE.exe

Exit</pre>
<p></p><h2>四輪車手冊</h2>
<p>我們從<a href="https://www.coppeliarobotics.com/helpFiles/index.html">CoppeliaSim用戶手冊</a>中尋找有關於四輪機器人的文章，找到了幾個相關的文章，分別是<span style="color: #000000;"><a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm" name="link194folder.9" style="color: #000000;">BubbleRob tutorial</a>、<a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/lineFollowingBubbleRobTutorial.htm" name="link196folder.9">Line following BubbleRob tutorial</a></span><span style="color: #000000;">、<a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm" name="link199folder.9">External controller tutorial</a></span><span style="color: #000000;">、<a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/simulation.htm" name="link184folder.7">Simulation</a>、<a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/simulationPropertiesDialog.htm" name="link185folder.7">Simulation dialog</a>，</span>一共五個有關四輪車的文章。</p>
<h4>其中的<span style="color: #000000;"><a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm" name="link199folder.9" style="color: #000000;">External controller tutorial</a></span>為:</h4>
<p><span><span>在CoppeliaSim中，有幾種方法可以控制機器人或仿真：</span></span></p>
<p><span><span></span></span></p>
<ul>
<li>The most convenient way is to write a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm">child script</a><span> </span>that will handle the behaviour of a given robot or<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm">model</a>. It is the most convenient way, because child scripts are directly attached to<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/objects.htm">scene objects</a>, they will be duplicated together with their associated scene objects, they do not need any compilation with an external tool, they can run in<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#threaded">threaded</a><span> </span>or<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#nonThreaded">non-threaded</a><span> </span>mode, they can be extended via<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiFunctionListCategory.htm#customizingLuaFunctions">custom Lua function</a><span> </span>or via a<span> </span><a href="http://luaforge.net/projects/">Lua extension library</a>. Another major advantage in using child scripts: there is no communication lag as with the last 3 methods mentioned in this section (i.e. the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm">regular API</a><span> </span>is used), and child scripts are part of the application main thread (inherent synchronous operation). There are several drawback to writing scripts however: you don't have the choice of the programming language, you can't have the fastest code, and you can't directly access external function libraries, except the Lua extension libraries.</li>
</ul>
<p></p>
<ul>
<li><span><span>最方便的方法是編寫一個</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm"><span><span>子腳本</span></span></a><span><span>，以處理給定機器人或</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm"><span><span>模型</span></span></a><span><span>的行為</span><span>。</span><span>這是最便捷的方式，因為孩子的腳本直接連接到</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/objects.htm"><span><span>場景中的對象</span></span></a><span><span>，他們將與它們相關的場景對象進行複製，他們不需要任何編譯與外部的工具，它們可以在運行</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#threaded"><span><span>線程</span></span></a><span><span>還是</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#nonThreaded"><span><span>非線程</span></span></a><span><span>模式，可以通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiFunctionListCategory.htm#customizingLuaFunctions"><span><span>自定義Lua函數</span></span></a><span><span>或</span></span><a href="http://luaforge.net/projects/"><span><span>Lua擴展庫對其進行擴展</span></span></a><span><span>。</span><span>使用子腳本的另一個主要優點：與本節中提到的後三種方法（即</span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm"><span>常規API）</span></a><span>一樣，沒有通信延遲</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm"><span></span></a><span><span>，並且子腳本是應用程序主線程的一部分（固有的同步操作）。</span><span>但是，編寫腳本有幾個缺點：您無法選擇編程語言，不能擁有最快的代碼，並且除了Lua擴展庫之外，您無法直接訪問外部函數庫。</span></span></li>
</ul>
<ul>
<li>Another way one can control a robot or a simulation is by writing a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/plugins.htm">plugin</a>. The plugin mechanism allows for callback mechanisms,<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiFunctionListCategory.htm#customizingLuaFunctions">custom Lua function registration</a>, and of course access to external function libraries. A plugin is often used in conjunction with child scripts (e.g. the plugin registers custom Lua functions, that, when called from a child script, will call back a specific plugin function). A major advantage in using plugins is also that there is no communication lag as with the last 3 methods mentioned in this section (i.e. the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm">regular API</a><span> </span>is used), and that a plugin is part of the application main thread (inherent synchronous operation). The drawbacks with plugins are: they are more complicated to program, and they need to be compiled with an external too. Refer also to the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/pluginTutorial.htm">plugin tutorial</a>.</li>
</ul>
<ul>
<li><span><span>可以控制機器人或模擬的另一種方法是編寫</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/plugins.htm"><span><span>插件</span></span></a><span><span>。</span><span>插件機制允許回調機制，</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiFunctionListCategory.htm#customizingLuaFunctions"><span><span>自定義Lua函數註冊</span></span></a><span><span>，當然還可以訪問外部函數庫。</span><span>插件通常與子腳本結合使用（例如，插件註冊自定義Lua函數，當從子腳本中調用時，該Lua函數將回調特定的插件函數）。</span><span>使用插件的一個主要優點是，與本節中提到的後3種方法（即</span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm"><span>常規API）</span></a><span>一樣，沒有通信延遲</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm"><span></span></a><span><span>（使用），並且插件是應用程序主線程的一部分（固有的同步操作）。</span><span>插件的缺點是：它們的編程更加複雜，並且也需要使用外部編譯。</span><span>另請參閱</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/pluginTutorial.htm"><span><span>插件教程</span></span></a><span><span>。</span></span><span><span></span></span></li>
</ul>
<ul>
<li>A third and forth way one can control a robot or a simulation is by writing an external client application that relies on the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm">remote API</a>. This is a very convenient and easy way, if you need to run the control code from an external application, from a robot or from another computer. This also allows you to control a simulation or a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm">model</a><span> </span>(e.g. a virtual robot) with the exact same code as the one that runs the real robot. The remote API comes in two versions: the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm">B0-based remote API</a>, and the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/legacyRemoteApiOverview.htm">legacy remote API</a>.</li>
</ul>
<ul>
<li><span><span>控制機器人或模擬的第三種方式是編寫依賴於</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm"><span><span>遠程API</span></span></a><span><span>的外部客戶端應用程序</span><span>。</span><span>如果您需要從外部應用程序，機器人或另一台計算機運行控制代碼，這是一種非常便捷的方法。</span><span>這還允許您</span><span>使用與運行真實機器人完全相同的代碼</span><span>來控制仿真或</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm"><span><span>模型</span></span></a><span><span>（例如，虛擬機器人）。</span><span>遠程API有兩個版本：</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm"><span><span>基於B0的遠程API</span></span></a><span><span>和</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/legacyRemoteApiOverview.htm"><span><span>舊版遠程API</span></span></a><span><span>。</span></span></li>
</ul>
<ul>
<li>A fifth way to control a robot or a simulation is via a<span> </span><a href="http://www.ros.org/">ROS</a><span> </span>node. In a similar way as the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm">remote API</a>, ROS is a convenient way to have several distributed processes communicate with each other. While the remote API is very lightweight and fast, it allows only communication with CoppeliaSim. ROS on the other hand allows connecting virtually any number of processes with each other, and a large amount of compatible libraries are available. It is however heavier and more complicated than the remote API. Refer to the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterfaces.htm">ROS interfaces</a><span> </span>for details.</li>
</ul>
<ul>
<li><span><span>控制機器人或仿真的第五種方法是通過</span></span><a href="http://www.ros.org/"><span><span>ROS</span></span></a><span><span>節點。</span><span>ROS<span> </span></span><span>與</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm"><span><span>遠程API</span></span></a><span><span>相似</span><span>，是使多個分佈式進程相互通信的便捷方法。</span><span>儘管遠程API非常輕巧且快速，但它僅允許與CoppeliaSim通信。</span><span>另一方面，ROS允許幾乎將任意數量的進程相互連接，並且提供了大量兼容的庫。</span><span>但是，它比遠程API重並且更複雜。</span><span>有關詳細信息，</span><span>請參閱</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterfaces.htm"><span><span>ROS接口</span></span></a><span><span>。</span></span></li>
</ul>
<ul>
<li>A sixth way to control a robot or a simulation is via a<span> </span><a href="https://github.com/CoppeliaRobotics/bluezero" target="_blank">BlueZero</a><span> </span>(BØ) node. In a similar way as ROS, BlueZero is a convenient way to have several distributed processes communicate with each other, and is a lightweight and cross-platform solution. Refer to the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/blueZeroPlugin.htm">BlueZero interface</a><span> </span>for details.</li>
</ul>
<ul>
<li><span><span>控制機器人或模擬的第六種方法是通過</span></span><a href="https://github.com/CoppeliaRobotics/bluezero" target="_blank"><span><span>BlueZero</span></span></a><span><span>（BØ）節點。</span><span>與ROS類似，BlueZero是使多個分佈式進程相互通信的一種便捷方法，並且是一種輕量級的跨平台解決方案。</span><span>有關詳細信息，</span><span>請參考</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/blueZeroPlugin.htm"><span><span>BlueZero界面</span></span></a><span><span>。</span></span><span><span></span></span></li>
</ul>
<ul>
<li>A seventh way to control a robot or a simulation is by writing an external application that communicates via various means (e.g. pipes, sockets, serial port, etc.) with a CoppeliaSim plugin or CoppeliaSim script. Two major advantages are the choice of programming language, which can be just any language, and the flexibility. Here also, the control code can run on a robot, or a different computer. This way of controlling a simulation or a model is however more tedious that the methods with the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm">remote API</a>.</li>
</ul>
<ul>
<li><span><span>控制機器人或模擬的第七種方法是編寫一個外部應用程序，該應用程序通過各種方式（例如管道，套接字，串行端口等）與CoppeliaSim插件或CoppeliaSim腳本進行通信。</span><span>選擇編程語言（可以是任何一種語言）和靈活性是兩個主要優點。</span><span>同樣，控制代碼也可以在機器人或其他計算機上運行。</span><span>但是，與使用</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm"><span><span>遠程API</span></span></a><span><span>的方法相比，這種控制仿真或模型的方法更加乏味</span><span>。</span></span><span><span></span></span></li>
</ul>
<hr/>
<p><span><span>有8個與本教程相關的場景文件：</span></span></p>
<ul>
<li><em>scenes/controlTypeExamples/controlledViaScript</em>: one robot is controlled via a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#nonThreaded">non-threaded child script</a>, the other is controlled via a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#threaded">threaded child script</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaPlugin</em>: the robot is controlled via a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/plugins.htm">plugin</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaB0RemoteApi</em>: the robot is controlled via the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm">B0-based remote API</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaLegacyRemoteApi</em>: the robot is controlled via the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/legacyRemoteApiOverview.htm">legacy remote API</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaB0</em>: the robot is controlled via the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/blueZeroPlugin.htm">BlueZero interface</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaRos</em>: the robot is controlled via the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterf.htm">ROS interface</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaRos2</em>: the robot is controlled via the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterf.htm">ROS2 interface</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaTcp</em>: the robot is controlled via<span> </span><a href="http://w3.impa.br/~diego/software/luasocket/">LuaSocket</a><span> </span>and TCP.</li>
</ul>
<hr/>
<p></p>
<ul>
<li><span><span><em>scenes/controlTypeExamples/controlledViaScript</em><span>:</span>一個機器人通過控制</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#nonThreaded"><span><span>非螺紋孩子腳本</span></span></a><span><span>，另一種是通過受控的</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#threaded"><span><span>螺紋孩子腳本</span></span></a><span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaPlugin</em>：機器人是通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/plugins.htm"><span><span>插件</span></span></a><span><span>控制的</span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaB0RemoteApi</em>：通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm"><span><span>基於B0的遠程API</span></span></a><span><span>來控制機器人</span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaLegacyRemoteApi</em>：通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/legacyRemoteApiOverview.htm"><span><span>舊版遠程API</span></span></a><span><span>控制機器人</span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaB0</em>：通過</span><a href="https://www.coppeliarobotics.com/helpFiles/en/blueZeroPlugin.htm"><span>BlueZero界面</span></a><span>控制機器人</span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaRos</em>：通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterf.htm"><span><span>ROS接口</span></span></a><span><span>控制機器人</span><span>。</span></span></li>
<li><span><span><em>cenes/controlTypeExamples/controlledViaRos2</em>：通過</span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterf.htm"><span>ROS2接口</span></a><span>控制機器人</span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaTcp</em>：機器人是通過</span><a href="http://w3.impa.br/~diego/software/luasocket/"><span>LuaSocket</span></a><span>和TCP<span> </span></span><span>控制的</span><span>。</span></span></li>
</ul>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/externalControllerTut1.jpg"/></p>
<p><span><span>在所有8種情況下，</span><span>都使用</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm"><span><span>子腳本</span></span></a><span><span>，主要是為了與外界建立鏈接（例如，啟動正確的客戶端應用程序，並將正確的對象句柄傳遞給它）。</span><span>有兩種方法可以控制機器人，仿真程序或仿真程序本身：通過使用</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/customizationScripts.htm"><span><span>自定義腳本</span></span></a><span><span>或</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/addOns.htm"><span><span>加載項</span></span></a><span><span>。</span><span>但是，不建議將它們用於控制，而應在不運行模擬時將其用於處理功能。</span></span></p>
<p><span><span>例如，鏈接到場景</span></span><em><span><span>控制</span></span></em><span><span>的ViaB0RemoteApi.ttt中的機器人的子腳本</span><span>具有以下主要任務：</span></span></p>
<ul>
<li><span><span>使用某些對象句柄作為參數</span><span>啟動控制器應用程序（</span></span><a href="https://github.com/CoppeliaRobotics/b0RemoteApiBindings/tree/master/cpp/bubbleRobClient" target="_blank"><span><span>bubbleRobClient_b0RemoteApi</span></span></a><span><span>）。</span><span>基於對象B0的遠程API的服務器功能由對象</span></span><em><span><span>b0RemoteApiServer</span></span></em><span><span>提供</span><span>。</span></span></li>
</ul>
<p><span><span>作為另一個示例，鏈接到場景</span></span><em><span><span>控制</span></span></em><span><span>的ViaRos.ttt中的機器人的子腳本</span><span>具有以下主要任務：</span></span></p>
<ul>
<li><span><span>檢查是否</span><span>已加載CoppeliaSim<span> </span></span><span>的</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterf.htm"><span><span>ROS接口</span></span></a><span></span></li>
<li><span><span>使用某些主題名稱或對象句柄作為參數</span><span>啟動控制器應用程序（</span></span><a href="https://github.com/CoppeliaRobotics/ros_bubble_rob" target="_blank"><span><span>rosBubbleRob</span></span></a><span><span>）</span></span></li>
</ul>
<p><span><span>然而，作為另一個示例，鏈接到場景</span></span><em><span><span>控制</span></span></em><span><span>的ViaTcp.ttt中的機器人的子腳本</span><span>具有以下主要任務：</span></span></p>
<ul>
<li><span><span>搜索空閒的套接字連接端口</span></span></li>
<li><span><span>使用所選的連接端口作為參數</span><span>啟動控制器應用程序（</span></span><a href="https://github.com/CoppeliaRobotics/bubbleRobServer" target="_blank"><span><span>bubbleRobServer</span></span></a><span><span>）</span></span></li>
<li><span><span>本地連接到控制器應用程序</span></span></li>
<li><span><span>在每次仿真過程中，將傳感器值發送到控制器，並從控制器讀取所需的電機值</span></span></li>
<li><span><span>在每次模擬過程中，將所需的電機值應用於機器人的關節</span></span></li>
</ul>
<p><span><span>運行模擬，然後復制並粘貼機器人：您將看到重複的機器人將直接運行，因為附加的子腳本負責啟動各自外部應用程序的新實例，或調用適當的插件函數。</span></span></p><h1>About</h1>
<p>此內容管理系統以 <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作.</p>
<h4>利用 cmsimde 建立靜態網誌方法:</h4>
<p>1. 在 github 建立倉儲, git clone 到近端</p>
<p>2. 參考 <a href="https://github.com/mdecourse/newcms">https://github.com/mdecourse/newcms</a>, 加入除了 cmsimde 目錄外的所有內容</p>
<p>以 git submodule add <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> cmsimde</p>
<p>建立 cmsimde 目錄, 並從 github 取下子模組內容.</p>
<p>3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器.</p>
<p>動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端.</p>
<p>4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行:</p>
<p>git clone --recurse-submodules <a href="https://github.com/mdecourse/newcms.git">https://github.com/mdecourse/newcms.git</a></p>
<h1>Develop</h1>
<p><a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443 就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容.</p>
<p>cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版.</p>
<p>init.py 位於  up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.</p>