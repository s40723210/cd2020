<h1>Weeks</h1>
<p><a href="https://s40723210.github.io/cd2020/content/Week1-5.html">Week1-5</a></p>
<p><a href="https://s40723210.github.io/cd2020/content/Week6-9.html">Week6-9</a></p>
<p><a href="https://s40723210.github.io/cd2020/content/Week10-14.html">Week10-14</a></p>
<p><a href="https://s40723210.github.io/cd2020/content/Week15-18.html">Week15-18</a></p>
<hr/>
<p></p>
<p><iframe height="600px" iframe="" src="https://s40723210.github.io/cd2020/downloads/assignment1.pdf" width="100%"></iframe></p><h2>Week1-5</h2>
<h4 class="post-title entry-title" itemprop="name"><strong>建立個人cd2020倉儲</strong></h4>
<p><span>1.下載<a href="https://drive.google.com/file/d/1fxMdqdCoCL__O1IpZ-Sv-A_4-c77Wx4E/view?usp=sharing">2019Fall可攜套件.7z</a>，完成後開啟start。</span><span><br/></span><span></span><span><span>2.先登入自己的github帳號，</span><span>創建一個新的倉儲cd2020。</span></span><span><span><br/></span><span>3.進入要存放該資料的資料夾tmp。</span></span><span><span><br/></span></span><span></span><span><span>4.git clone </span><span>https://github.com/s40723210/cd2020 。</span><span><br/></span><span>5.</span><span>git submodule add https://github.com/mdecourse/cmsimde.git。</span></span><span><span><br/>6.再進入cmsimde，將up_dir的所有項目複<span>製到cd2020</span>。</span></span><span><span><br/>7.完成後，python wsgi.py 開始編輯倉儲。<br/></span></span><span><span>8.login密碼為admin，gitconfig要有帳號密碼。</span></span><span><span><br/>9.處理完，git status &gt; git add . &gt; git commit -m "標題" &gt; git push。</span></span><span><span><br/>10.開啟github倉儲設定，點選要推送的branch即可。<br/></span></span></p>
<p><span>我的教學影片:<a href="https://youtu.be/jBFzju1F43s">https://youtu.be/jBFzju1F43s<br/><br/><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/jBFzju1F43s" width="560"></iframe></a></span></p>
<hr color="00ffee"/>
<h4><strong>Updated Python 3.8.2</strong></h4>
<p>1.從Python<a href="https://www.python.org/">官方網站</a>，下載3.8.2版本的<a href="https://www.python.org/ftp/python/3.8.2/python-3.8.2.exe">安裝檔</a>。</p>
<p>2.完成後開啟，點選<span>Customize installation(定制安裝)。</span></p>
<p>3.將第二個選項的pip取消勾選，其他都可以勾選起來。</p>
<p>4.使用預設勾選，將路徑改為y槽的py382資料夾(自己創建)。</p>
<p>5.用編輯器來開啟<span>start_mdecourse.bat檔案。</span></p>
<p>6.<span>將</span><span>檔中的py373全部都改成py382後，重新啟動。</span></p>
<p>7.直接在y槽中執行，python <span>get-pip.py 來安裝pip軟件。</span></p>
<p><span>8.完成之後，來安裝軟件包，輸入python pip install <span style="color: #ff0000;">Flask</span> 依此類推。</span></p>
<p>9.安裝的有<span style="color: #ff0000;">Flask</span>、<span style="color: #ff0000;">Markdown</span>、<span style="color: #ff0000;">lxml</span>、<span style="color: #ff0000;">bs4</span>、<span style="color: #ff0000;">flask_cors</span>、<span style="color: #ff0000;">pelican</span>、<span style="color: #ff0000;">leo</span>。</p>
<p>我的教學影片:<a class="style-scope ytcp-video-share-dialog" href="https://youtu.be/Im6e8ZD1-Xo" id="watch-url" target="_blank">https://youtu.be/Im6e8ZD1-Xo</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/Im6e8ZD1-Xo" width="560"></iframe></p>
<hr color="00ffee"/>
<h4><strong>分配工作和問題討論</strong></h4>
<p>40623115 亂數分組程式<br/>40623251 可攜系統<br/>40723204 可攜系統<br/>42723210 四輪車<br/>40723212 四輪車<br/>40723225 四輪車<br/>40723232 亂數分組程式<br/>40723234 可攜系統<br/>40723238 四輪車<br/>40723245 亂數分組程式<br/>40723250 亂數分組程式</p>
<p>負責各主題的人，主要以課堂上的進度，來更新個人的倉儲，每次更新進度時要做一下紀錄。所有的主題必須要在<span>2020年3月26日之前完成，提交3-5頁的兩欄pdf報告，並在youtube上保存3-5分鐘的影片，將pdf文件放在個人倉儲 downloads / assignment1.pdf。最後整合的作業以assignment1放在自己的網站連結加/ assignment1內。有問題可以在我的 <a href="https://gitter.im/40723210/cd2020">gitter</a> 以及 老師的 <a href="https://gitter.im/mdecourse/cd2020">gitter</a> 上面發問，會的人也可以幫忙回答。<br/></span><br/>直播影片:<a href="https://www.youtube.com/watch?v=r0AABAp474U">https://www.youtube.com/watch?v=r0AABAp474U</a></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/r0AABAp474U" width="560"></iframe></p>
<hr color="00ffee"/>
<h4>New pull request</h4>
<p>1.先登入github，點進去想要fork的倉儲。<br/><br/>2.點選右上角的Fork，再選擇自己的github。<br/><br/>3.git clone --recurse-submodules (倉儲網址)。<br/><br/>4.更新git push完成，點選New pull request，等組長同意。<br/><br/>5.組員要進行更新時，要記得先git pull (分組網址) 檢查版本。<br/><br/>6.有衝突的話，組長要處理和整合分支並且解決衝突。<br/><br/>我的教學影片:<a href="https://youtu.be/1bZ16BgmF8c">https://youtu.be/1bZ16BgmF8c</a><a href="https://youtu.be/1bZ16BgmF8c"></a></p>
<p><iframe allowfullscreen="allowfullscreen" data-mce-fragment="1" height="314" src="https://www.youtube.com/embed/1bZ16BgmF8c" width="560"></iframe></p>
<hr color="00ffee"/>
<p></p>
<h1>assignment1</h1>
<p>Due March 25, 2020 for class 2a and March 26, 2020 for class 2b.</p>
<ol>
<li>
<p>Describe how to do an efficient random grouping for this course or do the roll calling randomly?</p>
</li>
<li>
<p>Describe how to prepare a portable Python programming system for Windows 10 64bit system to allow one the maintain CMSiMDE website, Pelican blog and Reveal.js presentation on Github?</p>
</li>
<li>
<p>What do you need to know from<span> </span><a href="http://www.coppeliarobotics.com/helpFiles/index.html" rel="nofollow">http://www.coppeliarobotics.com/helpFiles/index.html</a><span> </span>to implement a four-wheeled robot?</p>
</li>
</ol>
<hr/>
<p>報告連結:<a href="/downloads/assignment1.pdf">assignment1.pdf</a></p>
<p><iframe height="600px" iframe="" src="https://s40723210.github.io/cd2020/downloads/assignment1.pdf" width="100%"></iframe></p><h2>Random grouping</h2>
<p>請描述如何針對該課程進行有效的隨機分組，或者隨機進行點名？</p>
<h4><strong>測試程式(點選程式連結再貼上即可):</strong></h4>
<p><iframe allowfullscreen="allowfullscreen" allowtransparency="true" frameborder="no" height="400px" sandbox="allow-forms allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-modals" scrolling="no" src="https://repl.it/repls/LightLikelyDominspector?lite=true" width="100%"></iframe></p>
<h4><strong><span style="color: #0000ff;">抽查的python程式</span></strong></h4>
<p>如果要使用python來進行亂數分組抽查的話，可以導入random來從列表中隨機抽出所需要的n個不同元素，如下面的程式執行之後，就可以亂數抽出4位。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import random 

group = [4, 10, 12, 25, 32, 34, 38, 45, 50] 

team = random.sample(group, 4) 
print (team)</pre>
<p>再來是要讀取網頁資料的話，就要導入requests，使用get請求即可直接下載，例如member = requests.get("網址")，再用print(member.text)就可以印出來了如下。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import requests

web = "https://mdecourse.github.io/cd2020/downloads/2b_group_list.txt"

member = requests.get(web)

print(member.text)</pre>
<p>如果使用讀取出的資料，還是無法使用的，因為member.text的性質是str字串，所以我就要將它變回原本的list列表，才可以進行亂數分組，改這個非常的簡單如下。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">x = eval(member.text)</pre>
<p>最後我整理出來的程式，雖然沒有老師這麼精美，但是也是可以進行亂數分組的抽查的，如果要改抽查人數，改y = random.sample(i,2)的數字即可。</p>
<h4><span style="color: #ff6600;"><span color="#0000ff"><b>最終程式碼</b></span></span></h4>
<p>程式碼連結:<a href="https://github.com/s40723210/cd2020/blob/master/downloads/%E6%8A%BD%E6%9F%A5%E7%A8%8B%E5%BC%8F.py" target="_blank">抽查程式.py</a></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import requests
import random
  
web = "https://mdecourse.github.io/cd2020/downloads/2b_group_list.txt"
member = requests.get(web)
#print(memder.text)
x=0
for i in eval(member.text):
    y = random.sample(i,2)
    x+=1
    print("group"+ str(x))
    print(y)</pre>
<h4><strong><span style="color: #0000ff;">亂數分組的的python程式</span></strong></h4>
<p><strong></strong>一開始先從網頁上抓人員，這次跟上面的不太一樣，抓出來的本來就是str字串，所以必須把每個學號轉變為<span>list列表，直接將f.text加上 .split() 來轉換，完成之後就可以使用，random.shuffle()來將整個順序打亂，再來設定一共要分幾組，再使用while迴圈來判斷每一組要有幾個人，使用if判斷是來中斷迴圈，len()是指一共有幾個數量的意思，要加組別的話就要再多寫一列，接著使用for 迴圈來從，剛剛算好的每組人數，例如:13、12、12、12，再使用一個for迴圈，來一個一個配置組人員，這時候直接使用迭代iter()的next()，來抓人員這樣子就不會重複了，最後再加上一些說明、分格、標題，就可以開始進行亂數分組了。</span></p>
<h4><span style="color: #ff6600;"><span color="#0000ff"><b>最終程式碼</b></span></span></h4>
<p>程式碼連結:<a href="https://github.com/s40723210/cd2020/blob/master/downloads/%E4%BA%82%E6%95%B8%E5%88%86%E7%B5%84.py">亂數分組.py</a></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import requests
import random

web = "http://s1.mde.nfu.edu.tw:8000/?semester=1082&amp;courseno=0780"
f = requests.get(web)
#print(type(f.text))
x = f.text.split()
#print(len(x))
#print(x)
random.shuffle(x)

group1,group2,group3,group4 = 0,0,0,0
while 1==1:
    group1 += 1
    if (group1+group2+group3+group4) == len(x):
        break
    group2 += 1
    if (group1+group2+group3+group4) == len(x):
        break
    group3 += 1
    if (group1+group2+group3+group4) == len(x):
        break
    group4 += 1
    if (group1+group2+group3+group4) == len(x):
        break
#print(group1,group2,group3,group4)

print("全班人數有"+str(len(x))+"人")
print("="*20)
grp_num = group1,group2,group3,group4
a = iter(x)
team = 0
for i in grp_num:
    team += 1
    print("group"+str(team)+" 共 "+str(i)+" 人")
    for g in range(i):
        print(next(a))
    print("-" * 20)</pre>
<p></p><h2>Portable system</h2>
<p>2.描述如何為Windows 10 64位系統準備一個可移植的Python編程系統，以允許在Github上維護CMSiMDE網站，Pelican博客和Reveal.js演示文稿？</p>
<p>要創造可攜編程系統，首先需要的是start.bat以及stop.bat，放進system資料夾(自行創建)後，然後再創建一個data數據目錄資料夾(一樣放進<span>system資料夾內</span>)。</p>
<hr/>
<p style="top: 1595.4px;">start.bat 存放在system資料夾下</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">@echo off
set Disk=y
subst %Disk%: "data"

%Disk%:

set HomePath=%Disk%:\home_mdecourse
set HomeDrive=%Disk%:\home_mdecourse
set Home=%Disk%:\home_mdecourse
set USERPROFILE=%Disk%:\home_mdecourse

REM 將系統 Python 程式的 io 設為 utf-8
set PYTHONIOENCODING="utf-8"

set PYTHONPATH=%Disk%:\py382\DLLs;%Disk%:\py382\Lib;%Disk%:\py382\Lib\site-packages;
set PYTHONHOME=%Disk%:\py382

set path_python=%Disk%:\py382;%Disk%:\py382\Scripts;
set path_msys2=%Disk%:\msys64\mingw64\bin;
set path_tcc=%Disk%:\tcc;
set path_git=%Disk%:\portablegit\bin;

set GIT_HOME=%Disk%:\portablegit\bin\
set GIT_SSH=%Disk%:\putty\plink.exe

path=%Disk%:;%path_python%;%path_msys2%;%path_tcc%;%path_git%;%path_cmake%;%path_coreutils%;%path%;

start /MIN cmd.exe
start /MIN cmd.exe
start /MIN cmd.exe

start /MIN %Disk%:\wscite432\wscite\SciTE.exe
start /MIN %Disk%:\wscite432\wscite\SciTE.exe

Exit</pre>
<p>stop.bat <span>存放在system資料夾下</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">@echo off
set Disk=y
path=%PATH%;

taskkill /IM python.exe /F
taskkill /IM pythonw.exe /F
taskkill /IM SciTE.exe /F
REM 終止虛擬硬碟與目錄的對應
subst %Disk%: /D
REM 關閉 cmd 指令視窗
taskkill /IM cmd.exe /F
EXIT</pre>
<div>
<div class="syntaxhighlighter html" id="highlighter_96320"></div>
</div>
<h4><span style="color: #ff9900;"><strong>data的資料夾內:</strong></span></h4>
<p>編輯器，使用<span>SciTE :</span> <a href="https://www.scintilla.org/SciTEDownload.html">https://www.scintilla.org/SciTEDownload.html</a></p>
<p>下載<span>Windows 64-bit:</span> <span><a href="https://www.scintilla.org/wscite432.zip">full 64-bit download</a></span>，放進<span>data</span>目錄裡的<span>wscite432資料夾(自己創建)，接著</span><span>開啟<span>SciTE.exe</span><span>，點選 </span><span>Options下的</span><span><span style="text-decoration: underline;">Open Global Options File</span><span> ，使用ctrl + f 來收尋code.page=0，將code.page=65001的#刪掉，這樣才不會出現亂碼。</span></span><br/></span></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">code.page=65001
#code.page=0</pre>
<p></p>
<hr/>
<p>Git控制軟體 :<span> <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></span></p>
<p>下載Windows 64-bit: <span><a href="https://github.com/git-for-windows/git/releases/download/v2.25.1.windows.1/Git-2.25.1-64-bit.exe">64-bit Git for Windows Setup</a></span>，放進<span>data</span>目錄裡面並且重新命名為<span>portablegit 。</span></p>
<hr/>
<p><span>ssh</span>連線工具組，使用的<span>putty : </span><span><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/">https://www.chiark.greenend.org.uk/~sgtatham/putty/</a></span></p>
<p>直接下載老師之前給的:<span><a href="https://drive.google.com/file/d/1ISq1TJuaZyYZnfU33l-b7ifzmO3ejlEV/view">putty.7z</a></span>，解壓縮放入<span>data</span>目錄就可以了。</p>
<hr/>
<p>MSYS2：<a href="https://www.msys2.org/">https://www.msys2.org/ </a></p>
<p>下載的是<a href="http://repo.msys2.org/distrib/x86_64/msys2-x86_64-20190524.exe">msys2-x86</a><span><a href="http://repo.msys2.org/distrib/x86_64/msys2-x86_64-20190524.exe">_64-20190524.exe</a></span> ，安裝在<span> data </span>目錄裡的<span>msys64資料夾(自己創建)</span>。</p>
<hr/>
<p>Tiny C Compiler : <a href="https://github.com/TinyCC/tinycc">https://github.com/TinyCC/tinycc</a></p>
<p>直接在<span>data </span>目錄下進行<span>git clone </span><span><a href="https://github.com/TinyCC/tinycc">https://github.com/TinyCC/tinycc</a></span>  tcc </p>
<hr/>
<p>把現在再用的home_mdecourse，整個複製到data 目錄下。</p>
<hr/>
<p>Python : <a href="https://www.python.org/">https://www.python.org/</a>，下載3.8.2版本的<a href="https://www.python.org/ftp/python/3.8.2/python-3.8.2.exe">安裝檔</a>。</p>
<p>1.完成後開啟，點選<span>Customize installation(定制安裝)。</span></p>
<p>2.將第二個選項的pip取消勾選，其他都可以勾選起來。</p>
<p>3.使用預設勾選，將路徑改為data內的py382資料夾(自己創建)。</p>
<p>4.直接在y槽中執行，python <span>get-pip.py 來安裝pip軟件。</span></p>
<p><span>5.完成之後，來安裝軟件包，輸入python pip install<span> </span><span>Flask</span> 依此類推。</span></p>
<p>6.安裝的有<span>Flask</span>、<span>Markdown</span>、<span>lxml</span>、<span>bs4</span>、<span>flask_cors</span>、<span>pelican</span>、<span>leo</span>。</p>
<hr/>
<p>data目錄下的所有資料:</p>
<p><img alt="" height="193" src="/images/explorer_2020-03-21_21-05-25.png" width="519"/></p>
<p><span>system資料夾內:</span></p>
<p><span><img alt="" height="107" src="/images/explorer_2020-03-21_21-44-29.png" width="491"/></span></p>
<p><span>這樣子就完成了最簡單的</span>可攜編程系統了。</p>
<h2>Four wheel car</h2>
<p>我們從<a href="https://www.coppeliarobotics.com/helpFiles/index.html">CoppeliaSim用戶手冊</a>中尋找有關於四輪機器人的文章，找到了幾個相關的文章，分別是<a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm" name="link194folder.9">BubbleRob tutorial</a>、<a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/lineFollowingBubbleRobTutorial.htm" name="link196folder.9">Line following BubbleRob tutorial</a>、<a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm" name="link199folder.9">External</a><a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm" name="link199folder.9"> controller tutorial</a>、<a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/simulation.htm" name="link184folder.7">Simulation</a><span style="color: #000000;">、</span><a class="el" href="https://www.coppeliarobotics.com/helpFiles/en/simulationPropertiesDialog.htm" name="link185folder.7">Simulation dialog</a><span style="color: #000000;">，</span>一共五個有關四輪車的文章。</p>
<p><span><a href="https://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm">BubbleRob tutorial</a></span>:本章教程主要是透過，自己動手實際操作模擬，來了解許多功能以及<span>BubbleRob </span>機器人設置，我們上學期時就已經有親自使用<span>V-rep </span>來操作過一次了，本章使用了包括<span>:</span>基本形狀<span>(</span>機器人本體、輪子、障礙物<span>)</span>、感應器<span>(</span>接近型圓錐傳感器<span>)</span>、接頭或電動機<span>(</span>關節動力馬達<span>)</span>、力傳感器<span>(</span>滑塊<span>)</span>、圖表<span>(</span>運動軌跡<span>)</span>、腳本<span>(</span>模型定義<span>)</span>，使用以上這些功能，就可以實現<span>BubbleRob </span>機器人，能移動並且使用感應器，來感應障礙物，再使用腳本來迴避，最後再由圖表來顯示模擬路徑。</p>
<p><span><a href="https://www.coppeliarobotics.com/helpFiles/en/lineFollowingBubbleRobTutorial.htm">Line following BubbleRob tutorial</a></span>:這個教程是接續著上面的文章，可以使<span>BubbleRob </span>機器人按照規劃的路徑移動，讓我們可以有效的控制機器人，可以避免外部控制所產生的各種問題，這樣子就可以更快的達成需要的模擬狀況，可以提高不少的效率。</p>
<p><span><a href="https://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm">External controller tutorial</a></span>:本章屬於外部控制器的教程，讓我們可以使用遠端操控的方式，來控制四輪機器人，控制的方式有編寫腳本、編寫插件、遠程<span>API</span>、<span>ROS</span>節點、<span>BlueZero</span>節點、編寫外部應用程式，每種都要寫子腳本來進行鏈結。</p>
<p><span><a href="https://www.coppeliarobotics.com/helpFiles/en/simulation.htm">Simulation</a></span>:此教程為模擬案鍵，當我們建立好腳本時，就可以控制模擬的狀況，為了增加模擬的準確性，就可以使用仿真的速度與螺紋渲染，但是必須要適當的調整，才不會造成系統運行中斷。</p>
<p><span><a href="https://www.coppeliarobotics.com/helpFiles/en/simulationPropertiesDialog.htm">Simulation dialog</a></span>:此教程是上篇的進階設定，<strong>時間步</strong>為調整模擬時間，運行越快準確度越差，<strong>每幀模擬遍數</strong>為屏幕刷新速度，刷新越快得到的情報越快，只是電腦很吃效能，<strong>當仿真時間高於時暫停</strong>為允許特定仿真時間暫停，<strong>暫停腳本錯誤</strong>會在發生問題時暫停，<strong>模擬開始時全屏</strong>啟用時對話框和消息不會顯示，<strong>實時仿真-倍增係數</strong>使仿真運行快n倍，<strong>落後時嘗試趕上</strong>系統運行趕不上模擬時，會在低負載時趕上，<strong>復位場景初始狀態</strong>運行模擬結束時，所有設定將回歸初始狀態，<strong>刪除新對象</strong>模擬時，添加的東西將會在結束後移除，以上的各種設定，能讓我們在模擬時，更加的方便，進而提高許多效率。</p>
<h3>BubbleRob tutorial</h3>
<p>由40723210提供</p>
<p>本教程將在設計簡單的移動機器人<em>BubbleRob</em>時嘗試介紹很多CoppeliaSim功能。與本教程相關的CoppeliaSim場景文件位於CoppeliaSim的安裝文件夾的<em>tutorials / BubbleRob</em>文件夾中。下圖說明了我們將設計的仿真場景：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/bubbleRobTut1.jpg"/></p>
<p></p>
<p>由於本教程將跨越許多不同的方面，因此請確保也看看<a href="https://www.coppeliarobotics.com/helpFiles/en/tutorials.htm">其他教程</a>，主要是<a href="https://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm">有關構建仿真模型</a>的<a href="https://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm">教程</a>。首先，重新啟動CoppeliaSim。模擬器顯示默認<a href="https://www.coppeliarobotics.com/helpFiles/en/scenes.htm">場景</a>。我們將從<em>BubbleRob</em>的主體開始。</p>
<p>我們使用[菜單欄-&gt;添加-&gt;基本形狀-&gt;球體]將直徑為0.2的基本球體添加到場景中。我們將X尺寸項目調整為0.2，然後點擊確定。默認情況下，創建的球體將顯示在<a href="https://www.coppeliarobotics.com/helpFiles/en/layerSelectionDialog.htm">可見性層</a> 1中，並且是<a href="https://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#staticAndRespondable">動態且可響應的</a>（因為我們已啟用“ 創建動態且可響應的形狀 ”項）。這意味著<em>BubbleRob的</em>身體將掉落，並且能夠對與其他可響應形狀的碰撞做出反應（即，由物理引擎模擬）。我們可以看到這是<a href="https://www.coppeliarobotics.com/helpFiles/en/shapeDynamicsProperties.htm">形狀動力學屬性</a>：項目身體是可響應的，身體是動態的已啟用。我們開始模擬（通過工具欄按鈕，或在場景窗口中按&lt;control-space&gt;），然後復制並粘貼創建的球體（使用[菜單欄-&gt;編輯-&gt;複製所選對象]，然後[菜單欄-&gt;編輯-&gt;粘貼緩衝區]，或者先按&lt;control-c&gt;，再按&lt;control-v&gt;）：這兩個球將對碰撞做出反應並滾動。我們停止模擬：重複的球體將自動刪除。可以在<a href="https://www.coppeliarobotics.com/helpFiles/en/simulationPropertiesDialog.htm">模擬對話框中</a>修改此默認行為。</p>
<p>我們還希望<em>BubbleRob的</em>主體可以被其他計算模塊（例如<a href="https://www.coppeliarobotics.com/helpFiles/en/distanceCalculation.htm">最小距離計算模塊</a>）使用。因此，如果尚未啟用，則在該形狀的<a href="https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm">對象公共屬性中</a>啟用<a href="https://www.coppeliarobotics.com/helpFiles/en/collidableObjects.htm">Collidable</a>，<a href="https://www.coppeliarobotics.com/helpFiles/en/measurableObjects.htm">Measurable</a>，<a href="https://www.coppeliarobotics.com/helpFiles/en/renderableObjects.htm">Renderable</a>和<a href="https://www.coppeliarobotics.com/helpFiles/en/detectableObjects.htm">Detectable</a>。如果需要，我們現在還可以在<a href="https://www.coppeliarobotics.com/helpFiles/en/shapeProperties.htm">形狀屬性中</a>更改球體的視覺外觀。<a href="https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/shapeProperties.htm"></a></p>
<p>現在，我們在“ 平移”選項卡上打開“ <a href="https://www.coppeliarobotics.com/helpFiles/en/positionDialog.htm">位置”對話框</a>，選擇表示<em>BubbleRob</em>身體的球體，然後為“ 沿著Z”輸入0.02 。我們確保將相對項設置為World。然後，單擊翻譯選擇。這會將所有選定對象沿絕對Z軸平移2 cm，並有效地將我們的球體抬高了一點。在<a href="https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy">場景層次結構中</a>，我們雙擊球體的名稱，以便我們可以編輯其名稱。我們輸入<em>bubbleRob</em>，然後按Enter。<em></em><a href="https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy"></a><em></em></p>
<p>接下來，我們將添加一個<a href="https://www.coppeliarobotics.com/helpFiles/en/proximitySensors.htm">接近傳感器，</a>以便<em>BubbleRob</em>知道它何時接近障礙物：我們選擇[菜單欄-&gt;添加-&gt;接近傳感器-&gt;圓錐類型]。在方向選項卡上的<a href="https://www.coppeliarobotics.com/helpFiles/en/orientationDialog.htm">方向對話框中</a>，我們為Y周圍和Z 周圍輸入90 ，然後單擊旋轉選擇。在<a href="https://www.coppeliarobotics.com/helpFiles/en/positionDialog.htm">位置對話框</a>的“ 位置”選項卡上，為X坐標輸入0.1 。Z坐標為0.12 。現在，接近傳感器已相對於<em>BubbleRob的</em>身體正確定位。我們在<a href="https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy">場景層次中</a>雙擊接近傳感器的圖標<a href="https://www.coppeliarobotics.com/helpFiles/en/positionDialog.htm"></a><em></em><a href="https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy"></a>打開<a href="https://www.coppeliarobotics.com/helpFiles/en/proximitySensorPropertiesDialog.htm">其屬性</a>對話框。我們單擊顯示體積參數以打開<a href="https://www.coppeliarobotics.com/helpFiles/en/proximitySensorVolumeDialog.htm">接近傳感器體積對話框</a>。我們將偏移量調整為0.005，角度調整為30，範圍調整為0.15。然後，在<a href="https://www.coppeliarobotics.com/helpFiles/en/proximitySensorPropertiesDialog.htm">接近傳感器屬性中</a>，單擊顯示檢測參數。這將打開<a href="https://www.coppeliarobotics.com/helpFiles/en/proximitySensorDetectionParameterDialog.htm">接近傳感器檢測參數對話框</a>。如果距離小於則取消選中“不允許檢測”項，然後再次關閉該對話框。在場景層次結構中，我們雙擊接近傳感器的名稱，以便我們可以編輯其名稱。我們輸入<em>bubbleRob_sensingNose</em>並按回車鍵。</p>
<p>我們選擇<em>bubbleRob_sensingNose</em>，然後<em>按住</em> Control鍵選擇<em>bubbleRob</em>，然後單擊[菜單欄-&gt;編輯-&gt;將最後選擇的對象設為父對象]。這會將傳感器連接到機器人的身體。我們也可以拖<em>bubbleRob_sensingNose</em>到<em>bubbleRob</em>在場景層次。這就是我們現在擁有的：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/bubbleRobTut2.jpg"/></p>
<p class="imageLabel">[接近傳感器連接到<em>bubbleRob的</em>身體]</p>
<p>接下來，我們將照顧<em>BubbleRob的</em>車輪。我們使用[菜單欄-&gt;文件-&gt;新場景]創建一個新場景。跨多個場景工作通常非常方便，以便可視化並僅對特定元素進行工作。我們添加一個尺寸為（0.08,0.08,0.02）的純原始圓柱體。至於<em>BubbleRob</em>的主體，如果尚未啟用，則在該圓柱的<a href="https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm">對象通用屬性中</a>啟用 <a href="https://www.coppeliarobotics.com/helpFiles/en/collidableObjects.htm">Collidable</a>，<a href="https://www.coppeliarobotics.com/helpFiles/en/measurableObjects.htm">Measurable</a>，<a href="https://www.coppeliarobotics.com/helpFiles/en/renderableObjects.htm">Renderable</a>和<a href="https://www.coppeliarobotics.com/helpFiles/en/detectableObjects.htm">Detectable</a>。然後，將圓柱的絕對位置設置為（0.05,0.1,0.04），並將其絕對方向設置為（-90,0,0）。我們將名稱更改為<em>bubbleRob_leftWheel</em><a href="https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm"></a><em></em>。我們複製並粘貼滾輪，然後將復制的絕對Y坐標設置為-0.1。我們將副本重命名為<em>bubbleRob_rightWheel</em>。我們選擇兩個輪子，複製它們，然後切換回場景1，然後粘貼輪子。</p>
<p>現在，我們需要為車輪添加<a href="https://www.coppeliarobotics.com/helpFiles/en/joints.htm">接頭</a>（或電動機）。我們單擊[菜單欄-&gt;添加-&gt;關節-&gt;旋轉]將旋轉關節添加到場景。在大多數情況下，將新對象添加到場景時，該對象將出現在世界的起源處。我們保持關節處於選中狀態，然後控制選擇<em>bubbleRob_leftWheel</em>。在“ <a href="https://www.coppeliarobotics.com/helpFiles/en/positionDialog.htm">位置”對話框</a>的“ 位置”選項卡上，單擊“ 應用到選擇”按鈕：這將關節定位在左輪的中心。然後，在“ <a href="https://www.coppeliarobotics.com/helpFiles/en/orientationDialog.htm">方向”對話框</a>的“ 方向”選項卡上，執行相同的操作：這將關節與左輪定向的方向相同。我們將關節重命名為<em>bubbleRob_leftMotor</em>。現在，我們在場景層次中雙擊關節的圖標以打開<a href="https://www.coppeliarobotics.com/helpFiles/en/jointProperties.htm">關節屬性</a>對話框。然後，單擊“ 顯示動態參數”以打開<a href="https://www.coppeliarobotics.com/helpFiles/en/jointDynamicsProperties.htm">關節動力學屬性</a>對話框。我們啟用電動機，並檢查項目“ 目標速度為零時鎖定電動機”。現在，我們對右馬達重複相同的過程，並將其重命名為<em>bubbleRob_rightMotor</em>。現在，我們將左輪連接到左馬達，將右輪連接到右馬達，然後將兩個馬達連接到<em>bubbleRob</em>。這就是我們所擁有的：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/bubbleRobTut3.jpg"/></p>
<p class="imageLabel">[接近傳感器，電動機和車輪]</p>
<p>我們運行模擬，並註意到機器人向後倒下。我們仍然缺少與地板的第三個聯繫點。現在，我們添加一個小的滑塊（或腳輪）。在一個新的場景，我們並添加純原始球體直徑為0.05，讓球<a href="https://www.coppeliarobotics.com/helpFiles/en/collidableObjects.htm">可碰撞</a>，<a href="https://www.coppeliarobotics.com/helpFiles/en/measurableObjects.htm">可衡量的</a>，<a href="https://www.coppeliarobotics.com/helpFiles/en/renderableObjects.htm">可渲染</a>和<a href="https://www.coppeliarobotics.com/helpFiles/en/detectableObjects.htm">檢測的</a>（如果尚未啟用），然後將其重命名為<em>bubbleRob_slider</em>。我們在<a href="https://www.coppeliarobotics.com/helpFiles/en/shapeDynamicsProperties.htm">形狀動力學屬性</a>中將Material設置為<em>noFrictionMaterial</em>。為了將滑塊與機器人的其餘部分牢固地鏈接在一起，我們使用[菜單欄-&gt;添加-&gt;力傳感器] 添加了<a href="https://www.coppeliarobotics.com/helpFiles/en/forceSensors.htm">力傳感器對象</a>。我們將其重命名為<a href="https://www.coppeliarobotics.com/helpFiles/en/shapeDynamicsProperties.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/forceSensors.htm"></a><em>bubbleRob_connection</em>並將其上移0.05。我們將滑塊連接到力傳感器，然後復制兩個對象，切換回場景1並粘貼它們。然後，我們將力傳感器沿絕對X軸移動-0.07，然後將其安裝到機器人主體上。如果現在運行模擬，我們會注意到滑塊相對於機器人主體略微移動：這是因為兩個對象（即<em>bubbleRob_slider</em>和<em>bubbleRob</em>）都相互碰撞。為了避免在動力學模擬過程中產生奇怪的影響，我們必須通知CoppeliaSim兩個對像不會相互碰撞，我們可以通過以下方式進行此操作：在<a href="https://www.coppeliarobotics.com/helpFiles/en/shapeDynamicsProperties.htm">shape dynamics屬性中</a>，為<em>bubbleRob_slider</em>設置了本地可響應蒙版設置為00001111，對於<em>bubbleRob</em>，我們將本地可響應掩碼設置為11110000。如果再次運行仿真，我們會注意到兩個對像不再乾涉。這就是我們現在擁有的：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/bubbleRobTut4.jpg"/></p>
<p class="imageLabel">[接近傳感器，電機，車輪和滑塊]</p>
<p>我們再次運行仿真，發現即使在電機鎖定的情況下，<em>BubbleRob也會</em>輕微移動。我們還嘗試使用不同的物理引擎運行仿真：結果將有所不同。動態仿真的穩定性與所涉及的非靜態形狀的質量和慣性緊密相關。有關此效果的說明，請務必仔細閱讀<a href="https://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#masses">本</a>節和<a href="https://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#inertias">該</a>節。現在，我們嘗試糾正這種不良影響。我們選擇兩個輪子和滑塊，然後在“形狀動力學”對話框中單擊3次M = M * 2（用於選擇）。效果是所有選定形狀的質量都將乘以8。我們對3個選定形狀的慣性進行相同的操作，然後再次運行仿真：穩定性得到了改善。在關節動力學對話框中，我們將兩個電機的目標速度都設置為50。我們運行模擬：<em>BubbleRob</em>現在向前移動並最終掉落在地板上。我們將兩個電機的目標速度項都重置為零。</p>
<p>對象<em>bubbleRob</em>是所有以後將形成<em>BubbleRob </em><a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm">模型的</a><a href="https://www.coppeliarobotics.com/helpFiles/en/objects.htm">對象</a>的基礎。我們將在稍後定義模型。同時，我們要定義代表<em>BubbleRob</em>的對象的集合。為此，我們定義了一個<a href="https://www.coppeliarobotics.com/helpFiles/en/collections.htm">集合對象</a>。我們單擊[菜單欄-&gt;工具-&gt;集合]以打開<a href="https://www.coppeliarobotics.com/helpFiles/en/collectionsDialog.htm">集合對話框</a>。或者，我們也可以通過單擊相應的工具欄按鈕來打開對話框：<em></em><a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm"></a><em></em><a href="https://www.coppeliarobotics.com/helpFiles/en/collections.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/collectionsDialog.htm"></a></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/collectionDialog1.jpg"/></p>
<p></p>
<p>在集合對話框中，點擊添加新集合。一個新的集合對像出現在下面的列表中。目前，新添加的集合仍為空（未定義）。在列表中選擇新的收藏項時，在場景層次中選擇<em>bubbleRob</em>，然後在收藏對話框中單擊“ 添加 ”。現在，我們的集合被定義為包含層次結構樹的所有對象（從<em>bubbleRob</em>對<em>像</em>開始）（集合的組成顯示在“ 組成元素和屬性”部分中）。要編輯集合名稱，請雙擊它，然後將其重命名為<em>bubbleRob_collection</em>。我們關閉收集對話框。</p>
<p>在此階段，我們希望能夠跟踪BubbleRob與任何其他對象之間的最小距離。為此，我們使用[菜單欄-&gt;工具-&gt;計算模塊屬性] 打開<a href="https://www.coppeliarobotics.com/helpFiles/en/distanceCalculation.htm">距離對話框</a>。或者，我們也可以使用相應的工具欄按鈕打開計算模塊屬性對話框：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/calculationModuleButton.jpg"/></p>
<p></p>
<p>在距離對話框中，單擊添加新的距離對象，然後選擇一個距離對：<em>[collection] bubbleRob_collection-場景中的所有其他可測量對象</em>。這只是添加了一個距離對象，該距離對象將測量集合<em>bubbleRob_collection</em>（即該集合中的任何<a href="https://www.coppeliarobotics.com/helpFiles/en/measurableObjects.htm">可測量對象</a>）與場景中任何其他可測量對象之間的最小距離。我們通過雙擊其名稱將距離對象重命名為<em>bubbleRob_distance</em>。我們關閉距離對話框。現在運行模擬時，我們看不到任何區別，因為距離對象將嘗試測量（並顯示）<em>BubbleRob</em>之間的最小距離段<em></em>以及場景中的其他任何可測量對象。問題在於，在此階段，場景中沒有其他可測量的對象（定義地板的形狀默認情況下已禁用其可測量的屬性）。在本教程的後續階段，我們將為場景添加障礙。</p>
<p>接下來，我們將向<em>BubbleRob</em>添加一個<a href="https://www.coppeliarobotics.com/helpFiles/en/graphs.htm">圖形對象</a>，以顯示最小距離以上的距離，同時還顯示<em>BubbleRob</em>隨時間<em>的</em>軌跡。我們單擊[菜單欄-&gt;添加-&gt;圖]並將其重命名為<em>bubbleRob_graph</em>。我們將圖形附加到<em>bubbleRob</em>，並將圖形的絕對坐標設置為（0,0,0.005）。現在，通過在場景層次結構中雙擊其圖標來打開<a href="https://www.coppeliarobotics.com/helpFiles/en/graphPropertiesDialog.htm">圖形屬性</a>對話框。我們取消選中“ 顯示XYZ平面”，然後單擊“ 添加新數據流”以進行記錄，然後選擇“ 對象：數據流類型的絕對x位置 ” 和<em>bubbleRob_graph</em><em></em><em></em><em></em><em></em><a href="https://www.coppeliarobotics.com/helpFiles/en/graphPropertiesDialog.htm"></a><em></em>用於記錄的對象/項目。數據流記錄列表中出現了一個項目。該項目是<em>bubbleRob_graph的</em>絕對X坐標的數據流（即，將記錄<em>bubbleRobGraph的</em>對象的絕對X位置）。現在，我們還想記錄y和z位置：我們以與上述類似的方式添加這些數據流。現在，我們有3個數據流，分別表示BubbleRob的x，y和z軌跡。我們將添加更多的數據流，使我們能夠跟踪我們的機器人與環境之間的最小距離：我們點擊添加新的數據流記錄，並選擇距離：段長度的數據流類型，並<em>bubbleRob_distance</em>用於記錄的對象/項目。在數據流記錄列表中，我們現在將Data重命名為bubbleRob_x_pos，將Data0重命名為bubbleRob_y_pos，將Data1重命名為bubbleRob_z_pos，將Data2重命名為bubbleRob_obstacle_dist。</p>
<p>我們在“ 數據流”記錄列表中和“ 時間圖屬性”部分中選擇<em>bubbleRob_x_pos</em>，取消選中“ 可見”。我們對<em>bubbleRob_y_pos</em>和<em>bubbleRob_z_pos</em>都執行相同的<em>操作</em>。這樣，在時間圖中只能看到<em>bubbleRob_obstacle_dist</em>數據流。以下是我們應該擁有的：<em></em><em></em><em></em></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/bubbleRobTut5.jpg"/></p>
<p class="imageLabel">[圖形屬性]</p>
<p>接下來，我們將建立一個顯示<em>BubbleRob</em>軌蹟的3D曲線：單擊編輯3D曲線打開<a href="https://www.coppeliarobotics.com/helpFiles/en/graphCurvePropertiesDialog.htm">XY圖和3D曲線對話框</a>，然後單擊添加新曲線。在對話框彈出打開，我們選擇<em>bubbleRob_x_pos</em>為X-值項，<em>bubbleRob_y_pos</em>為Y值項，<em>bubbleRob_z_pos</em>的Z值項目。我們將新添加的曲線從<em>Curve</em>重命名為bubbleRob_path。最後，我們檢查“ 相對於世界”項目並將“ 曲線寬度”設置為4：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/bubbleRobTut6.jpg"/></p>
<p class="imageLabel">[3D曲線屬性]</p>
<p></p>
<p>我們關閉與圖有關的所有對話框。現在我們將一個電機目標速度設置為50，運行模擬，然後將看到<em>BubbleRob的</em>軌跡顯示在場景中。然後，我們停止仿真並將電動機目標速度重置為零。</p>
<p>我們添加具有以下尺寸的純原始圓柱體：（0.1，0.1，0.2）。我們希望此圓柱體是靜態的（即不受重力或碰撞的影響），但仍會對非靜態的可響應形狀施加一些碰撞響應。為此，我們在<a href="https://www.coppeliarobotics.com/helpFiles/en/shapeDynamicsProperties.htm">形狀動力學屬性中</a>禁用“ 主體是動態的” 。我們也希望我們的汽缸是 <a href="https://www.coppeliarobotics.com/helpFiles/en/collidableObjects.htm">可碰撞</a>，<a href="https://www.coppeliarobotics.com/helpFiles/en/measurableObjects.htm">可衡量的</a>，<a href="https://www.coppeliarobotics.com/helpFiles/en/renderableObjects.htm">可渲染</a>和<a href="https://www.coppeliarobotics.com/helpFiles/en/detectableObjects.htm">檢測的</a>。我們在<a href="https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm">對象的通用屬性中</a>執行此操作。現在，在仍選擇圓柱體的情況下，我們單擊對象平移工具欄按鈕：<a href="https://www.coppeliarobotics.com/helpFiles/en/shapeDynamicsProperties.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/collidableObjects.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/measurableObjects.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/renderableObjects.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/detectableObjects.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm"></a></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/objectShiftButton.jpg"/></p>
<p></p>
<p>現在我們可以拖動場景中的任何點：圓柱體將跟隨運動，同時始終受約束以保持相同的Z坐標。我們複製並粘貼圓柱幾次，然後將它們移動到<em>BubbleRob</em>周圍的<em>位置</em>（從頂部查看場景時執行該操作最方便）。在對象移動期間，按住Shift鍵可以執行較小的移動步驟。按住ctrl鍵可以在與<em>常規</em>方向正交的方向上移動。完成後，再次選擇相機平移工具欄按鈕：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/cameraShiftButton.jpg"/></p>
<p></p>
<p>我們將左馬達的目標速度設置為50並運行模擬：現在，圖形視圖顯示了到最近障礙物的距離，並且該距離段在場景中也可見。我們停止模擬並將目標速度重置為零。</p>
<p>現在，我們需要完成BubbleRob作為<a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm">模型</a>定義。我們選擇模型庫（即對象<em>bubbleRob</em>），然後檢查項目Object是模型庫，並且Object / model可以轉移或接受<a href="https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm">對象</a>共有<a href="https://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm">屬性</a>中的DNA：現在有一個點畫框，它包圍了模型層次結構中的所有對象。我們選擇兩個關節，即接近傳感器和圖形，然後啟用項目“不顯示為內部模型選擇”，然後在同一對話框中單擊“ 應用於選擇”：模型邊界框現在忽略了兩個關節和接近傳感器。仍在同一對話框中，我們禁用相機可見性圖層2，並為兩個關節和力傳感器啟用攝像機可見性層 10：這有效地隱藏了兩個關節和力傳感器，因為默認情況下禁用9-16層。任何時候我們都可以<a href="https://www.coppeliarobotics.com/helpFiles/en/layerSelectionDialog.htm">修改整個場景的可見性層</a>。要完成模型定義，我們選擇視覺傳感器，兩個輪子，滑塊和圖形，然後啟用“ 選擇模型基礎”項：如果現在嘗試在場景中的模型中選擇一個對象，則將選擇整個模型，這是一種將整個模型作為單個對象進行處理和操作的便捷方法。此外，這可以防止模型受到意外修改。仍然可以通過在按住Shift的同時單擊選擇對像或在場景層次結構中正常選擇它們，來在場景中選擇模型中的單個對象。最後，我們將模型樹折疊到場景層次中。這就是我們所擁有的：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/bubbleRobTut7.jpg"/></p>
<p class="imageLabel">[ <em>BubbleRob</em>模型定義]</p>
<p>接下來，我們將在與<em>BubbleRob</em>接近傳感器相同的位置和方向上添加<a href="https://www.coppeliarobotics.com/helpFiles/en/visionSensors.htm">視覺</a>傳感器。我們再次打開模型層次結構，然後單擊[菜單欄-&gt;添加-&gt;視覺傳感器-&gt;透視類型]，然後將視覺傳感器連接到接近傳感器，並將視覺傳感器的本地位置和方向設置為（0,0,0）。我們還確保視覺傳感器不可見，不是模型邊界框的一部分，並且如果單擊該模型，則會選擇模型。為了自定義視覺傳感器，我們打開<a href="https://www.coppeliarobotics.com/helpFiles/en/visionSensorPropertiesDialog.htm">其屬性</a>對話框。我們將遠裁剪平面項設置為1，將分辨率x和分辨率y設置為<em></em><a href="https://www.coppeliarobotics.com/helpFiles/en/visionSensorPropertiesDialog.htm"></a> 項目分別為256和256。我們向場景中添加了一個浮動視圖，然後在新添加的浮動視圖上，右鍵單擊[彈出菜單-&gt;視圖-&gt;將視圖與選定的視覺傳感器關聯]（我們確保視覺傳感器在該過程中被選中）。</p>
<p>通過單擊[菜單欄-&gt;添加-&gt;關聯的子腳本-&gt;非線程]，將非線程子腳本附加到視覺傳感器。我們雙擊場景層次結構中視覺傳感器旁邊出現的小圖標：這將打開我們剛剛添加的子腳本。我們將以下代碼複製並粘貼到<a href="https://www.coppeliarobotics.com/helpFiles/en/scriptEditor.htm">腳本編輯器中</a>，然後將其關閉：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">function sysCall_vision(inData)
    simVision.sensorImgToWorkImg(inData.handle) -- copy the vision sensor image to the work image
    simVision.edgeDetectionOnWorkImg(inData.handle,0.2) -- perform edge detection on the work image
    simVision.workImgToSensorImg(inData.handle) -- copy the work image to the vision sensor image buffer
end

function sysCall_init()
end</pre>
<p>為了能夠看到視覺傳感器的圖像，我們開始模擬，然後再次停止。</p>
<p>我們場景所需的最後一件事是一個小的<a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm">子腳本</a>，它將控制<em>BubbleRob的</em>行為。我們選擇<em>bubbleRob</em>並單擊[菜單欄-&gt;添加-&gt;關聯的子腳本-&gt;非線程]。我們雙擊場景層次結構中<em>bubbleRob</em>名稱旁邊顯示的腳本圖標，然後將以下代碼複製並粘貼到<a href="https://www.coppeliarobotics.com/helpFiles/en/scriptEditor.htm">腳本編輯器中</a>，然後將其關閉：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">function speedChange_callback(ui,id,newVal)
    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100
end

function sysCall_init()
    -- This is executed exactly once, the first time this script is executed
    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self) -- this is bubbleRob's handle
    leftMotor=sim.getObjectHandle("bubbleRob_leftMotor") -- Handle of the left motor
    rightMotor=sim.getObjectHandle("bubbleRob_rightMotor") -- Handle of the right motor
    noseSensor=sim.getObjectHandle("bubbleRob_sensingNose") -- Handle of the proximity sensor
    minMaxSpeed={50*math.pi/180,300*math.pi/180} -- Min and max speeds for each motor
    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode
    -- Create the custom UI:
        xml = '&lt;ui title="'..sim.getObjectName(bubbleRobBase)..' speed" closeable="false" resizeable="false" activate="false"&gt;'..[[
        &lt;hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/&gt;
        &lt;label text="" style="* {margin-left: 300px;}"/&gt;
        &lt;/ui&gt;
        ]]
    ui=simUI.create(xml)
    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5
    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))
end

function sysCall_actuation()
    result=sim.readProximitySensor(noseSensor) -- Read the proximity sensor
    -- If we detected something, we set the backward mode:
    if (result&gt;0) then backUntilTime=sim.getSimulationTime()+4 end 

    if (backUntilTime&lt;sim.getSimulationTime()) then
        -- When in forward mode, we simply move forward at the desired speed
        sim.setJointTargetVelocity(leftMotor,speed)
        sim.setJointTargetVelocity(rightMotor,speed)
    else
        -- When in backward mode, we simply backup in a curve at reduced speed
        sim.setJointTargetVelocity(leftMotor,-speed/2)
        sim.setJointTargetVelocity(rightMotor,-speed/8)
    end
end

function sysCall_cleanup()
	simUI.destroy(ui)
end</pre>
<pre class="lightRedBox"><br/><br/></pre>
<p>我們運行模擬。<em>BubbleRob</em>現在在嘗試避開障礙物的同時向前移動（以非常基本的方式）。在模擬仍在運行時，更改<em>BubbleRob的</em>速度，然後將其複制/粘貼幾次。在模擬仍在運行時，也嘗試擴展其中的一些。請注意，根據環境的不同，最小距離計算功能可能會嚴重降低仿真速度。您可以通過選中/取消選中“ 啟用所有距離計算”項，在“ <a href="https://www.coppeliarobotics.com/helpFiles/en/distanceCalculation.htm">距離”對話框中</a>打開和關閉該功能。</p>
<p>使用腳本控制機器人或模型只是一種方法。CoppeliaSim提供了許多不同的方法（也可以結合使用），請參閱<a href="https://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm">外部控制器教程</a>。</p>
<h3>Line following BubbleRob</h3>
<p><span>由40723210提供</span></p>
<p>在本教程中，我們旨在擴展BubbleRob的功能，以使他/她遵循地面上的規則。確保您已完全閱讀並理解第<a href="https://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm">一個BubbleRob教程</a>。本教程由Eric Rohmer提供。</p>
<p>在CoppeliaSim的安裝文件夾中的<em>tutorials / BubbleRob中</em>加載第一個BubbleRob教程的場景。與本教程相關的場景文件位於<em>tutorials / LineFollowingBubbleRob中</em>。下圖說明了我們將設計的仿真場景：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/lbubbleRobTut1.jpg"/></p>
<p></p>
<p>我們首先創建3個<a href="https://www.coppeliarobotics.com/helpFiles/en/visionSensors.htm">視覺傳感器</a>中的第一個，並將其附加到<em>bubbleRob</em>對象。選擇[菜單欄-&gt;添加-&gt;視覺傳感器-&gt;正交類型]。雙擊<a href="https://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy">場景層次結構中</a>新創建的視覺傳感器圖標，編輯其屬性，然後更改參數以反映以下對話框：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/lbubbleRobTut2.jpg"/></p>
<p></p>
<p>視覺傳感器必鬚麵向地面，因此選擇它，然後在“ <a href="https://www.coppeliarobotics.com/helpFiles/en/orientationDialog.htm">方向”對話框</a>的“ 方向”選項卡上，將“ <em>Alpha</em> - <em>Beta</em> - <em>Gamma”</em>項設置為[180; 0; 0] 。</p>
<p>我們有幾種可能性可以讀取視覺傳感器。由於我們的視覺傳感器只有一個像素，並且操作簡單，因此我們只需查詢視覺傳感器讀取的圖像的平均強度值即可。對於更複雜的情況，我們可以設置<a href="https://www.coppeliarobotics.com/helpFiles/en/visionCallbackFunctions.htm">視覺回調函數</a>。現在，將視覺傳感器複製並粘貼兩次，並將其名稱調整為<em>leftSensor</em>，<em>middleSensor</em>和<em>rightSensor</em>。將<em>bubbleRob設置為</em>其父級（<em>即將</em>其附加到<em>bubbleRob</em>對象）。現在，您的傳感器在場景層次中應如下所示：</p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/lbubbleRobTut4.jpg"/></p>
<p></p>
<p>讓我們正確放置傳感器。對於使用<a href="https://www.coppeliarobotics.com/helpFiles/en/positionDialog.htm">位置對話框</a>中，在位置選項卡，並設置以下的絕對坐標：</p>
<p></p>
<ul>
<li>左傳感器：[0.2; 0.042; 0.018]</li>
<li>中間傳感器：[0.2; 0; 0.018]</li>
<li>右傳感器：[0.2; -0.042; 0.018]</li>
</ul>
<p></p>
<p>現在讓我們修改環境。我們可以移去BubbleRob前面的幾個圓柱體。接下來，我們將構建機器人將嘗試遵循的<a href="https://www.coppeliarobotics.com/helpFiles/en/paths.htm">路徑</a>。現在最好切換到頂視圖：通過<a href="https://www.coppeliarobotics.com/helpFiles/en/pagesAndViews.htm#pageSelector">頁面選擇器工具欄按鈕</a>選擇<a href="https://www.coppeliarobotics.com/helpFiles/en/pagesAndViews.htm">頁面</a> 4 。然後單擊[菜單欄-&gt;添加-&gt;路徑-&gt;圓圈類型]。<a href="https://www.coppeliarobotics.com/helpFiles/en/objectMovement.htm">使用鼠標</a>啟用<a href="https://www.coppeliarobotics.com/helpFiles/en/objectMovement.htm">對象移動</a>。您可以通過兩種方式調整路徑的形狀：<a href="https://www.coppeliarobotics.com/helpFiles/en/pagesAndViews.htm#pageSelector"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/objectMovement.htm"></a></p>
<p></p>
<ul>
<li>選擇路徑（並且只有路徑）後，按住Ctrl並單擊其<a href="https://www.coppeliarobotics.com/helpFiles/en/pathsControlPointsAndBezierPoints.htm">控制點之一</a>。然後可以將它們拖動到正確的位置。</li>
<li>選擇路徑後，進入<a href="https://www.coppeliarobotics.com/helpFiles/en/pathEditMode.htm">路徑編輯模式</a>。在那裡，您可以靈活地調整各個路徑控制點。</li>
</ul>
<p></p>
<p>對路徑的幾何形狀滿意（您隨時可以在以後的階段對其進行修改）後，選擇它，然後取消選中<a href="https://www.coppeliarobotics.com/helpFiles/en/pathPropertiesDialog.htm">路徑屬性</a>中的“ 顯示點的方向”，“ 顯示路徑線”和“ 顯示路徑上的當前位置”。然後單擊“ 顯示路徑整形對話框”。這將打開<a href="https://www.coppeliarobotics.com/helpFiles/en/pathShaping.htm">路徑整形對話框</a>。單擊“ 啟用路徑整形”，將類型設置為“ 水平線段”，然後將“ 縮放比例”<a href="https://www.coppeliarobotics.com/helpFiles/en/pathPropertiesDialog.htm"></a><a href="https://www.coppeliarobotics.com/helpFiles/en/pathShaping.htm"></a>到4.0。最後將顏色調整為黑色。我們必須對路徑進行最後一個重要的調整：當前，路徑的z位置與地板的z位置重合。結果是有時我們會看到路徑，有時會看到地板（這種效果在openGl行話中被稱為“ <em>z-fighting</em> ”）。這不僅影響我們所看到的，而且還會影響視覺傳感器所看到的。為了避免與z戰鬥有關的問題，只需將路徑對象的位置向上移動0.5毫米即可。</p>
<p>最後一步是調整BubbleRob的控制器，使其也將遵循黑色路徑。打開附著於<em>bubbleRob</em>的<a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm">子腳本</a>，並將其替換為以下代碼：<em></em></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">function speedChange_callback(ui,id,newVal)
    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100
end

function sysCall_init()
    -- This is executed exactly once, the first time this script is executed
    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self)
    leftMotor=sim.getObjectHandle("leftMotor")
    rightMotor=sim.getObjectHandle("rightMotor")
    noseSensor=sim.getObjectHandle("sensingNose")
    minMaxSpeed={50*math.pi/180,300*math.pi/180}
    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode
    floorSensorHandles={-1,-1,-1}
    floorSensorHandles[1]=sim.getObjectHandle("leftSensor")
    floorSensorHandles[2]=sim.getObjectHandle("middleSensor")
    floorSensorHandles[3]=sim.getObjectHandle("rightSensor")
    -- Create the custom UI:
        xml = '&lt;ui title="'..sim.getObjectName(bubbleRobBase)..' speed" closeable="false" resizeable="false" activate="false"&gt;'..[[
        &lt;hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/&gt;
        &lt;label text="" style="* {margin-left: 300px;}"/&gt;
        &lt;/ui&gt;
        ]]
    ui=simUI.reate(xml)
    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5
    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))
end

function sysCall_actuation()
    result=sim.readProximitySensor(noseSensor)
    if (result&gt;0) then backUntilTime=sim.getSimulationTime()+4 end

    -- read the line detection sensors:
    sensorReading={false,false,false}
    for i=1,3,1 do
        result,data=sim.readVisionSensor(floorSensorHandles[i])
        if (result&gt;=0) then
            sensorReading[i]=(data[11]&lt;0.3) -- data[11] is the average of intensity of the image
        end
        print(sensorReading[i])
    end

    -- compute left and right velocities to follow the detected line:
    rightV=speed
    leftV=speed
    if sensorReading[1] then
        leftV=0.03*speed
    end
    if sensorReading[3] then
        rightV=0.03*speed
    end
    if sensorReading[1] and sensorReading[3] then
        backUntilTime=sim.getSimulationTime()+2
    end

    if (backUntilTime&lt;sim.getSimulationTime()) then
        -- When in forward mode, we simply move forward at the desired speed
        sim.setJointTargetVelocity(leftMotor,leftV)
        sim.setJointTargetVelocity(rightMotor,rightV)
    else
        -- When in backward mode, we simply backup in a curve at reduced speed
        sim.setJointTargetVelocity(leftMotor,-speed/2)
        sim.setJointTargetVelocity(rightMotor,-speed/8)
    end
end

function sysCall_cleanup()
	simUI.destroy(ui)
end</pre>
<pre class="lightRedBox"><br/><br/></pre>
<p>您可以輕鬆地調試以下視覺傳感器的生產線：選擇一個，然後在場景視圖中選擇[右鍵-&gt;添加-&gt;浮動視圖]，然後在新添加的浮動視圖中選擇[右鍵-&gt;視圖- -&gt;將視圖與選定的視覺傳感器關聯]。</p>
<p>最後，刪除在第<a href="https://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm">一個BubbleRob教程</a>中添加的輔助項：刪除圖像處理視覺傳感器及其關聯的浮動視圖，該浮動視圖表示障礙物的清除。通過<a href="https://www.coppeliarobotics.com/helpFiles/en/distanceCalculation.htm">距離對話框</a>也刪除距離計算對象。而已！</p>
<h3>External controller tutorial</h3>
<p><span>由40723210提供</span></p>
<p><span><span>在CoppeliaSim中，有幾種方法可以控制機器人或仿真：</span></span></p>
<ul>
<li>The most convenient way is to write a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm">child script</a><span> </span>that will handle the behaviour of a given robot or<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm">model</a>. It is the most convenient way, because child scripts are directly attached to<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/objects.htm">scene objects</a>, they will be duplicated together with their associated scene objects, they do not need any compilation with an external tool, they can run in<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#threaded">threaded</a><span> </span>or<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#nonThreaded">non-threaded</a><span> </span>mode, they can be extended via<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiFunctionListCategory.htm#customizingLuaFunctions">custom Lua function</a><span> </span>or via a<span> </span><a href="http://luaforge.net/projects/">Lua extension library</a>. Another major advantage in using child scripts: there is no communication lag as with the last 3 methods mentioned in this section (i.e. the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm">regular API</a><span> </span>is used), and child scripts are part of the application main thread (inherent synchronous operation). There are several drawback to writing scripts however: you don't have the choice of the programming language, you can't have the fastest code, and you can't directly access external function libraries, except the Lua extension libraries.</li>
</ul>
<p></p>
<ul>
<li><span><span>最方便的方法是編寫一個</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm"><span><span>子腳本</span></span></a><span><span>，以處理給定機器人或</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm"><span><span>模型</span></span></a><span><span>的行為</span><span>。</span><span>這是最便捷的方式，因為孩子的腳本直接連接到</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/objects.htm"><span><span>場景中的對象</span></span></a><span><span>，他們將與它們相關的場景對象進行複製，他們不需要任何編譯與外部的工具，它們可以在運行</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#threaded"><span><span>線程</span></span></a><span><span>還是</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#nonThreaded"><span><span>非線程</span></span></a><span><span>模式，可以通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiFunctionListCategory.htm#customizingLuaFunctions"><span><span>自定義Lua函數</span></span></a><span><span>或</span></span><a href="http://luaforge.net/projects/"><span><span>Lua擴展庫對其進行擴展</span></span></a><span><span>。</span><span>使用子腳本的另一個主要優點：與本節中提到的後三種方法（即</span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm"><span>常規API）</span></a><span>一樣，沒有通信延遲</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm"><span></span></a><span><span>，並且子腳本是應用程序主線程的一部分（固有的同步操作）。</span><span>但是，編寫腳本有幾個缺點：您無法選擇編程語言，不能擁有最快的代碼，並且除了Lua擴展庫之外，您無法直接訪問外部函數庫。</span></span></li>
</ul>
<ul>
<li>Another way one can control a robot or a simulation is by writing a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/plugins.htm">plugin</a>. The plugin mechanism allows for callback mechanisms,<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiFunctionListCategory.htm#customizingLuaFunctions">custom Lua function registration</a>, and of course access to external function libraries. A plugin is often used in conjunction with child scripts (e.g. the plugin registers custom Lua functions, that, when called from a child script, will call back a specific plugin function). A major advantage in using plugins is also that there is no communication lag as with the last 3 methods mentioned in this section (i.e. the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm">regular API</a><span> </span>is used), and that a plugin is part of the application main thread (inherent synchronous operation). The drawbacks with plugins are: they are more complicated to program, and they need to be compiled with an external too. Refer also to the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/pluginTutorial.htm">plugin tutorial</a>.</li>
</ul>
<ul>
<li><span><span>可以控制機器人或模擬的另一種方法是編寫</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/plugins.htm"><span><span>插件</span></span></a><span><span>。</span><span>插件機制允許回調機制，</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiFunctionListCategory.htm#customizingLuaFunctions"><span><span>自定義Lua函數註冊</span></span></a><span><span>，當然還可以訪問外部函數庫。</span><span>插件通常與子腳本結合使用（例如，插件註冊自定義Lua函數，當從子腳本中調用時，該Lua函數將回調特定的插件函數）。</span><span>使用插件的一個主要優點是，與本節中提到的後3種方法（即</span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm"><span>常規API）</span></a><span>一樣，沒有通信延遲</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiOverview.htm"><span></span></a><span><span>（使用），並且插件是應用程序主線程的一部分（固有的同步操作）。</span><span>插件的缺點是：它們的編程更加複雜，並且也需要使用外部編譯。</span><span>另請參閱</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/pluginTutorial.htm"><span><span>插件教程</span></span></a><span><span>。</span></span><span><span></span></span></li>
</ul>
<ul>
<li>A third and forth way one can control a robot or a simulation is by writing an external client application that relies on the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm">remote API</a>. This is a very convenient and easy way, if you need to run the control code from an external application, from a robot or from another computer. This also allows you to control a simulation or a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm">model</a><span> </span>(e.g. a virtual robot) with the exact same code as the one that runs the real robot. The remote API comes in two versions: the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm">B0-based remote API</a>, and the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/legacyRemoteApiOverview.htm">legacy remote API</a>.</li>
</ul>
<ul>
<li><span><span>控制機器人或模擬的第三種方式是編寫依賴於</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm"><span><span>遠程API</span></span></a><span><span>的外部客戶端應用程序</span><span>。</span><span>如果您需要從外部應用程序，機器人或另一台計算機運行控制代碼，這是一種非常便捷的方法。</span><span>這還允許您</span><span>使用與運行真實機器人完全相同的代碼</span><span>來控制仿真或</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/models.htm"><span><span>模型</span></span></a><span><span>（例如，虛擬機器人）。</span><span>遠程API有兩個版本：</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm"><span><span>基於B0的遠程API</span></span></a><span><span>和</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/legacyRemoteApiOverview.htm"><span><span>舊版遠程API</span></span></a><span><span>。</span></span></li>
</ul>
<ul>
<li>A fifth way to control a robot or a simulation is via a<span> </span><a href="http://www.ros.org/">ROS</a><span> </span>node. In a similar way as the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm">remote API</a>, ROS is a convenient way to have several distributed processes communicate with each other. While the remote API is very lightweight and fast, it allows only communication with CoppeliaSim. ROS on the other hand allows connecting virtually any number of processes with each other, and a large amount of compatible libraries are available. It is however heavier and more complicated than the remote API. Refer to the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterfaces.htm">ROS interfaces</a><span> </span>for details.</li>
</ul>
<ul>
<li><span><span>控制機器人或仿真的第五種方法是通過</span></span><a href="http://www.ros.org/"><span><span>ROS</span></span></a><span><span>節點。</span><span>ROS<span> </span></span><span>與</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm"><span><span>遠程API</span></span></a><span><span>相似</span><span>，是使多個分佈式進程相互通信的便捷方法。</span><span>儘管遠程API非常輕巧且快速，但它僅允許與CoppeliaSim通信。</span><span>另一方面，ROS允許幾乎將任意數量的進程相互連接，並且提供了大量兼容的庫。</span><span>但是，它比遠程API重並且更複雜。</span><span>有關詳細信息，</span><span>請參閱</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterfaces.htm"><span><span>ROS接口</span></span></a><span><span>。</span></span></li>
</ul>
<ul>
<li>A sixth way to control a robot or a simulation is via a<span> </span><a href="https://github.com/CoppeliaRobotics/bluezero" target="_blank">BlueZero</a><span> </span>(BØ) node. In a similar way as ROS, BlueZero is a convenient way to have several distributed processes communicate with each other, and is a lightweight and cross-platform solution. Refer to the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/blueZeroPlugin.htm">BlueZero interface</a><span> </span>for details.</li>
</ul>
<ul>
<li><span><span>控制機器人或模擬的第六種方法是通過</span></span><a href="https://github.com/CoppeliaRobotics/bluezero" target="_blank"><span><span>BlueZero</span></span></a><span><span>（BØ）節點。</span><span>與ROS類似，BlueZero是使多個分佈式進程相互通信的一種便捷方法，並且是一種輕量級的跨平台解決方案。</span><span>有關詳細信息，</span><span>請參考</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/blueZeroPlugin.htm"><span><span>BlueZero界面</span></span></a><span><span>。</span></span><span><span></span></span></li>
</ul>
<ul>
<li>A seventh way to control a robot or a simulation is by writing an external application that communicates via various means (e.g. pipes, sockets, serial port, etc.) with a CoppeliaSim plugin or CoppeliaSim script. Two major advantages are the choice of programming language, which can be just any language, and the flexibility. Here also, the control code can run on a robot, or a different computer. This way of controlling a simulation or a model is however more tedious that the methods with the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm">remote API</a>.</li>
</ul>
<ul>
<li><span><span>控制機器人或模擬的第七種方法是編寫一個外部應用程序，該應用程序通過各種方式（例如管道，套接字，串行端口等）與CoppeliaSim插件或CoppeliaSim腳本進行通信。</span><span>選擇編程語言（可以是任何一種語言）和靈活性是兩個主要優點。</span><span>同樣，控制代碼也可以在機器人或其他計算機上運行。</span><span>但是，與使用</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/remoteApiOverview.htm"><span><span>遠程API</span></span></a><span><span>的方法相比，這種控制仿真或模型的方法更加乏味</span><span>。</span></span><span><span></span></span></li>
</ul>
<hr/>
<p><span><span>有8個與本教程相關的場景文件：</span></span></p>
<ul>
<li><em>scenes/controlTypeExamples/controlledViaScript</em>: one robot is controlled via a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#nonThreaded">non-threaded child script</a>, the other is controlled via a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#threaded">threaded child script</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaPlugin</em>: the robot is controlled via a<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/plugins.htm">plugin</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaB0RemoteApi</em>: the robot is controlled via the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm">B0-based remote API</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaLegacyRemoteApi</em>: the robot is controlled via the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/legacyRemoteApiOverview.htm">legacy remote API</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaB0</em>: the robot is controlled via the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/blueZeroPlugin.htm">BlueZero interface</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaRos</em>: the robot is controlled via the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterf.htm">ROS interface</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaRos2</em>: the robot is controlled via the<span> </span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterf.htm">ROS2 interface</a>.</li>
<li><em>scenes/controlTypeExamples/controlledViaTcp</em>: the robot is controlled via<span> </span><a href="http://w3.impa.br/~diego/software/luasocket/">LuaSocket</a><span> </span>and TCP.</li>
</ul>
<hr/>
<p></p>
<ul>
<li><span><span><em>scenes/controlTypeExamples/controlledViaScript</em><span>:</span>一個機器人通過控制</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#nonThreaded"><span><span>非螺紋孩子腳本</span></span></a><span><span>，另一種是通過受控的</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#threaded"><span><span>螺紋孩子腳本</span></span></a><span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaPlugin</em>：機器人是通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/plugins.htm"><span><span>插件</span></span></a><span><span>控制的</span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaB0RemoteApi</em>：通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm"><span><span>基於B0的遠程API</span></span></a><span><span>來控制機器人</span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaLegacyRemoteApi</em>：通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/legacyRemoteApiOverview.htm"><span><span>舊版遠程API</span></span></a><span><span>控制機器人</span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaB0</em>：通過</span><a href="https://www.coppeliarobotics.com/helpFiles/en/blueZeroPlugin.htm"><span>BlueZero界面</span></a><span>控制機器人</span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaRos</em>：通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterf.htm"><span><span>ROS接口</span></span></a><span><span>控制機器人</span><span>。</span></span></li>
<li><span><span><em>cenes/controlTypeExamples/controlledViaRos2</em>：通過</span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterf.htm"><span>ROS2接口</span></a><span>控制機器人</span><span>。</span></span></li>
<li><span><span><em>scenes/controlTypeExamples/controlledViaTcp</em>：機器人是通過</span><a href="http://w3.impa.br/~diego/software/luasocket/"><span>LuaSocket</span></a><span>和TCP<span> </span></span><span>控制的</span><span>。</span></span></li>
</ul>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/externalControllerTut1.jpg"/></p>
<p><span><span>在所有8種情況下，</span><span>都使用</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm"><span><span>子腳本</span></span></a><span><span>，主要是為了與外界建立鏈接（例如，啟動正確的客戶端應用程序，並將正確的對象句柄傳遞給它）。</span><span>有兩種方法可以控制機器人，仿真程序或仿真程序本身：通過使用</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/customizationScripts.htm"><span><span>自定義腳本</span></span></a><span><span>或</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/addOns.htm"><span><span>加載項</span></span></a><span><span>。</span><span>但是，不建議將它們用於控制，而應在不運行模擬時將其用於處理功能。</span></span></p>
<p><span><span>例如，鏈接到場景</span></span><em><span><span>控制</span></span></em><span><span>的ViaB0RemoteApi.ttt中的機器人的子腳本</span><span>具有以下主要任務：</span></span></p>
<ul>
<li><span><span>使用某些對象句柄作為參數</span><span>啟動控制器應用程序（</span></span><a href="https://github.com/CoppeliaRobotics/b0RemoteApiBindings/tree/master/cpp/bubbleRobClient" target="_blank"><span><span>bubbleRobClient_b0RemoteApi</span></span></a><span><span>）。</span><span>基於對象B0的遠程API的服務器功能由對象</span></span><em><span><span>b0RemoteApiServer</span></span></em><span><span>提供</span><span>。</span></span></li>
</ul>
<p><span><span>作為另一個示例，鏈接到場景</span></span><em><span><span>控制</span></span></em><span><span>的ViaRos.ttt中的機器人的子腳本</span><span>具有以下主要任務：</span></span></p>
<ul>
<li><span><span>檢查是否</span><span>已加載CoppeliaSim<span> </span></span><span>的</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/rosInterf.htm"><span><span>ROS接口</span></span></a><span></span></li>
<li><span><span>使用某些主題名稱或對象句柄作為參數</span><span>啟動控制器應用程序（</span></span><a href="https://github.com/CoppeliaRobotics/ros_bubble_rob" target="_blank"><span><span>rosBubbleRob</span></span></a><span><span>）</span></span></li>
</ul>
<p><span><span>然而，作為另一個示例，鏈接到場景</span></span><em><span><span>控制</span></span></em><span><span>的ViaTcp.ttt中的機器人的子腳本</span><span>具有以下主要任務：</span></span></p>
<ul>
<li><span><span>搜索空閒的套接字連接端口</span></span></li>
<li><span><span>使用所選的連接端口作為參數</span><span>啟動控制器應用程序（</span></span><a href="https://github.com/CoppeliaRobotics/bubbleRobServer" target="_blank"><span><span>bubbleRobServer</span></span></a><span><span>）</span></span></li>
<li><span><span>本地連接到控制器應用程序</span></span></li>
<li><span><span>在每次仿真過程中，將傳感器值發送到控制器，並從控制器讀取所需的電機值</span></span></li>
<li><span><span>在每次模擬過程中，將所需的電機值應用於機器人的關節</span></span></li>
</ul>
<p><span><span>運行模擬，然後復制並粘貼機器人：您將看到重複的機器人將直接運行，因為附加的子腳本負責啟動各自外部應用程序的新實例，或調用適當的插件函數。</span></span></p>
<h3>Simulation</h3>
<p><span>由40723210提供</span></p>
<p><span>可以使用[菜單欄-&gt;模擬-&gt;開始/暫停/停止模擬]或通過相關的工具欄按鈕來啟動，暫停和停止CoppeliaSim中的模擬：</span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulation1.jpg"/></p>
<p class="imageLabel"><span><span>[模擬開始/暫停/停止工具欄按鈕]</span></span></p>
<p><span><span>在內部，模擬器將使用其他中間狀態，以正確告知</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/scripts.htm"><span><span>腳本</span></span></a><span><span>或程序接下來將發生的情況。</span><span>以下狀態圖說明了模擬器的內部狀態：</span></span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulation2.jpg"/></p>
<p class="imageLabel"><span><span>[模擬狀態圖]</span></span></p>
<p><span><span>腳本和程序應始終根據當前系統調用功能以及可能的</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/regularApi/simGetSimulationState.htm"><span><span>模擬狀態進行反應</span></span></a><span><span>，以便正確運行。</span><span>優良作法是將每個控制代碼分成至少4個系統調用函數（例如，用於</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#nonThreaded"><span><span>非線程子腳本</span></span></a><span><span>）：</span></span></p>
<p></p>
<ul>
<li><strong><span><span>初始化函數</span></span></strong><span><span>：</span><strong><strong><span>sysCall_init</span></strong></strong><span>：僅在腳本初始化時才調用該函數。</span></span><strong><strong><span></span></strong></strong><span></span></li>
<li><strong><span></span></strong><span><strong><strong><span>激勵</span></strong></strong><strong><span>函數</span></strong><span>：</span><strong><strong><span>sysCall_actuation</span></strong></strong><span>：應在發生激勵時調用該函數。</span></span><strong><strong><span></span></strong></strong><span></span></li>
<li><strong><span><span>Sensing函數</span></span></strong><span><span>：</span><strong><strong><span>sysCall_sensing</span></strong></strong><span>：應在發生傳感時調用此函數。</span></span><strong><strong><span></span></strong></strong><span></span></li>
<li><strong><span><span>清理函數</span></span></strong><span><span>：</span><strong><strong><span>sysCall_cleanup</span></strong></strong><span>：在取消初始化腳本之前（例如，在模擬結束時或銷毀腳本時）調用該函數。</span></span><strong><strong><span></span></strong></strong><span></span></li>
</ul>
<p></p>
<p><span><span>有關如何安排典型腳本的示例，請參考</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/mainScript.htm"><span><span>main腳本</span></span></a><span><span>，</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/childScripts.htm"><span><span>子腳本</span></span></a><span><span>和</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/customizationScripts.htm"><span><span>自定義腳本</span></span></a><span><span>頁面。</span></span></p>
<h4><span style="color: #000000;"><strong>仿真循環</strong></span></h4>
<p><span><span>模擬器通過以恆定的時間步長推進模擬時間來進行操作。</span><span>下圖說明了主要的仿真循環：</span></span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulation3.jpg"/></p>
<p class="imageLabel"><span><span>[主仿真循環]</span></span></p>
<p><span><span>通過嘗試使仿真時間與實時保持同步來支持實時仿真：</span></span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulation4.jpg"/></p>
<p class="imageLabel"><span><span>[實時仿真循環]</span></span></p>
<p><span><span>以下是一個非常簡化的</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/mainClientApplication.htm"><span><span>主客戶端應用程序</span></span></a><span><span>（</span><span>為清晰起見，已省略了</span><span>消息，</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/plugins.htm"><span><span>插件</span></span></a><span><span>處理和其他詳細信息）：</span></span></p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">void initializationCallback
{
    // do some initialization here
}

void loopCallback
{
    if ( (simGetSimulationState()&amp;sim_simulation_advancing)!=0 )
    {
        if ( (simGetRealTimeSimulation()!=1)||(simIsRealTimeSimulationStepNeeded()==1) )
        {
            if ((simHandleMainScript()&amp;sim_script_main_script_not_called)==0)
                simAdvanceSimulationByOneStep();
        }
    }
}

void deinitializationCallback
{
    // do some clean-up here
}</pre>
<p><span><span>取決於仿真的複雜性，計算機的性能和</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/simulationPropertiesDialog.htm"><span><span>仿真設置</span></span></a><span><span>，實時仿真可能並不總是可能的。</span></span></p>
<h4><strong><span style="color: #000000;">仿真速度</span></strong></h4>
<p><span><span>在非實時仿真中，仿真速度（即感知速度）主要取決於兩個因素：仿真時間步長和一個渲染通道的仿真通道數量（</span><span>有關更多詳細信息，</span><span>請參見</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/simulationPropertiesDialog.htm"><span><span>仿真對話框</span></span></a><span><span>）。</span><span>在實時仿真的情況下，仿真速度主要取決於實時乘法係數，而且在一定程度上取決於仿真時間步長（太小的仿真時間步長可能與實時時間不兼容）。由於計算機的計算能力有限，因此無法進行仿真。</span><span>在模擬過程中，可以使用以下工具欄按鈕來調整模擬速度：</span></span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulation5.jpg"/></p>
<p class="imageLabel"><span><span>[模擬速度調整工具欄按鈕]</span></span></p>
<p><span><span>以某種方式調整模擬速度，以使初始模擬時間步長永遠不會增加（例如，這可能因此而導致機制中斷）。</span><span>以下兩個圖說明了仿真速度調整機制：</span></span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulation6.jpg"/></p>
<p class="imageLabel"><span><span>[<span> </span></span></span><strong><span><span>非實時</span></span></strong><span><span>模擬的模擬速度調整機制</span><span>]</span></span></p>
<p></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulation7.jpg"/></p>
<p class="imageLabel"><span><span>[用於</span></span><strong><span><span>實時</span></span></strong><span><span>仿真的仿真速度調整機制</span><span>]</span></span></p>
<p><span><span>默認情況下，每個模擬週期由以下</span></span><strong><span><span>順序</span></span></strong><span><span>操作</span><span>組成</span><span>：</span></span></p>
<p></p>
<ul>
<li><span><span>執行</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/mainScript.htm"><span><span>主腳本</span></span></a></li>
<li><span><span>渲染場景</span></span></li>
</ul>
<h4><strong><span style="color: #000000;">螺紋渲染</span></strong></h4>
<p></p>
<p><span><span>渲染操作將始終增加仿真週期的持續時間，從而也降低了仿真速度。</span><span>可以定義每個場景渲染的主腳本執行次數（請參閱後面的內容），但這在某些情況下還不夠，因為渲染仍然會減慢每個第x個模擬週期的時間（這可能會限制實時性）。</span><span>在這種情況下，可以通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/settings.htm"><span><span>用戶設置</span></span></a><span><span>或以下工具欄按鈕</span><span>激活線程渲染模式</span><span>：</span></span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/threadedRenderingButton.jpg"/></p>
<p class="imageLabel"><span><span>[線程渲染工具欄按鈕]</span></span></p>
<p><span><span>激活線程渲染模式後，模擬週期將僅包括執行</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/mainScript.htm"><span><span>主腳本</span></span></a><span><span>，因此模擬將以最大速度運行。</span><span>渲染將通過不同的線程進行，並且不會減慢模擬任務的速度。</span><span>然而，必須考慮缺點。</span><span>激活線程渲染後，：</span></span></p>
<p></p>
<ul>
<li><span><span>渲染將與模擬循環異步進行，並且可能會出現視覺故障</span></span></li>
<li><span><span>該</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/aviRecorder.htm"><span><span>錄像機</span></span></a><span><span>將不以恆定速度運轉（某些幀可能會跳過）</span></span></li>
<li><span><span>應用程序的穩定性可能會降低</span></span></li>
<li><span><span>某些操作（例如擦除對像等）需要等待渲染線程完成工作才能執行，反之亦然。</span><span>在那些情況下，循環可能比順序渲染模式花費更多的時間。</span></span></li>
</ul>
<p></p>
<p></p>
<h3>Simulation dialog</h3>
<p><span>由40723210提供</span></p>
<p><span>可以通過[菜單欄-&gt;模擬-&gt;模擬設置]或單擊以下工具欄按鈕來訪問模擬對話框：</span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulationDialog1.jpg"/></p>
<p class="imageLabel"><span><span>[模擬工具欄按鈕]</span></span></p>
<p align="center"><img src="https://www.coppeliarobotics.com/helpFiles/en/images/simulationDialog2.jpg"/></p>
<p class="imageLabel"><span><span>[模擬設置對話框]</span></span></p>
<ul>
<li><strong><span><span>時間步</span></span></strong><span><span>：</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/simulation.htm"><span><span>模擬</span></span></a><span><span>時間步。</span><span>每次</span><span>執行</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/mainScript.htm"><span><span>主腳本</span></span></a><span><span>時，仿真時間都會增加仿真時間步長。</span><span>使用較大的時間步會導致快速但不准確/不穩定的仿真。</span><span>另一方面，較小的時間步長（通常）會導致更精確的仿真，但是會花費更多時間。</span><span>強烈建議保留默認時間步長。</span></span></li>
<li><strong><span><span>每幀模擬遍數（ppf）</span></span></strong><span><span>：一個渲染遍的模擬遍數。</span><span>值為10表示刷新屏幕之前，主腳本已執行10次（10個模擬步驟）。</span><span>如果您的圖形卡較慢，則可以選擇僅顯示兩幅中的一幅。</span></span></li>
<li><strong><span><span>當仿真時間高於時暫停</span></span></strong><span><span>：允許指定仿真時間，在該時間暫停仿真（例如，能夠在特定仿真時間分析某些結果）。</span></span></li>
<li><strong><span><span>暫停腳本錯誤</span></span></strong><span><span>：如果啟用，則在發生</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/scripts.htm"><span><span>腳本</span></span></a><span><span>錯誤時</span><span>將暫停仿真</span><span>。</span></span></li>
<li><strong><span><span>模擬開始時全屏</span></span></strong><span><span>：如果啟用，則模擬以全屏模式開始。</span><span>請注意，在全屏模式下，對話框和消息將不會出現或不可見，只有鼠標左鍵處於活動狀態。</span><span>因此，僅在正確配置場景並最終確定場景後才建議使用該模式。</span><span>可以使用esc鍵保留全屏模式，並</span><span>在仿真過程中</span><span>通過</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/apiConstants.htm#booleanParameters"><span><span>布爾參數</span></span></a><span> </span><em><span><span>sim_booparam_fullscreen</span></span></em><span><span>進行</span><span>切換<span> </span></span><span>。</span><span>Unler Linux和MacOS可能僅部分支持全屏模式，並且在某些系統上切換回普通模式可能會失敗。</span></span></li>
<li><strong><span><span>實時仿真，倍增係數</span></span></strong><span><span>：如果選擇，則仿真時間將嘗試跟隨實時。</span><span>X的乘數將使仿真運行比實時快X倍。</span></span></li>
<li><strong><span><span>落後時嘗試趕上</span></span></strong><span><span>：在實時仿真過程中，仿真時間可能無法實時跟踪（例如，由於某些瞬間繁重的計算）。</span><span>在這種情況下，如果選中此復選框，則模擬時間將嘗試趕上損失的時間（例如，當計算負載再次減少時），這會明顯提高速度。</span></span></li>
<li><strong><span><span>復位場景初始狀態</span></span></strong><span><span>：當被選擇時，那麼所有</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/objects.htm"><span><span>的對象</span></span></a><span><span>將被復位到它們的初始狀態：包括對象的本地位置，局部方向和它的父（只要該對象沒有另外修飾的（例如縮放）），</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/joints.htm"><span><span>關節</span></span></a><span><span>以及</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/paths.htm"><span><span>路徑的</span></span></a><span><span>固有位置，浮動</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/pagesAndViews.htm"><span><span>視圖</span></span></a><span><span>位置和大小等。這意味著除非進行了重大更改（</span></span><a href="https://www.coppeliarobotics.com/helpFiles/en/shapes.htm"><span><span>形狀</span></span></a><span><span>縮放，對象移除等）</span><span>，否則下一次模擬運行將以與上一次相同的方式執行</span><span>。</span><span>此項目將忽略一些次要設置。</span></span></li>
<li><strong><span><span>刪除新對象</span></span></strong><span><span>：選中該選項後，在仿真運行期間添加的場景對象將在仿真結束時被刪除。</span></span></li>
</ul>
<h1>About</h1>
<p>此內容管理系統以 <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作.</p>
<h4>利用 cmsimde 建立靜態網誌方法:</h4>
<p>1. 在 github 建立倉儲, git clone 到近端</p>
<p>2. 參考 <a href="https://github.com/mdecourse/newcms">https://github.com/mdecourse/newcms</a>, 加入除了 cmsimde 目錄外的所有內容</p>
<p>以 git submodule add <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> cmsimde</p>
<p>建立 cmsimde 目錄, 並從 github 取下子模組內容.</p>
<p>3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器.</p>
<p>動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端.</p>
<p>4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行:</p>
<p>git clone --recurse-submodules <a href="https://github.com/mdecourse/newcms.git">https://github.com/mdecourse/newcms.git</a></p>
<h1>Develop</h1>
<p><a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443 就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容.</p>
<p>cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版.</p>
<p>init.py 位於  up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.</p>