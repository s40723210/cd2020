var tipuesearch = {"pages": [{'title': 'Weeks', 'text': 'Week1-5 \n Week6-9 \n Week10-14 \n Week15-18 \n Weeks Meeting \n \n 倉儲網址: https://github.com/s40723210/cd2020 \n youtube: https://www.youtube.com/channel/UC8l7lxn3l0ENuxYDhLjgxRw \n 分組倉儲網址: https://s40723210.github.io/cd2020bg4 \n gitter :\xa0 https://gitter.im/40723210/cd2020', 'tags': '', 'url': 'Weeks.html'}, {'title': 'Week1-5', 'text': '建立個人cd2020倉儲 \n 1.下載 2019Fall可攜套件.7z ，完成後開啟start。 2.先登入自己的github帳號， 創建一個新的倉儲cd2020。 3.進入要存放該資料的資料夾tmp。 4.git clone\xa0 https://github.com/s40723210/cd2020 。 5. git submodule add https://github.com/mdecourse/cmsimde.git。 6.再進入cmsimde，將up_dir的所有項目複 製到cd2020 。 7.完成後，python wsgi.py 開始編輯倉儲。 8.login密碼為admin，gitconfig要有帳號密碼。 9.處理完，git status > git add . > git commit -m "標題" > git push。 10.開啟github倉儲設定，點選要推送的branch即可。 \n 我的教學影片: https://youtu.be/jBFzju1F43s \n \n Updated Python 3.8.2 \n 1.從Python 官方網站 ，下載3.8.2版本的 安裝檔 。 \n 2.完成後開啟，點選 Customize installation(定制安裝)。 \n 3.將第二個選項的pip取消勾選，其他都可以勾選起來。 \n 4.使用預設勾選，將路徑改為y槽的py382資料夾(自己創建)。 \n 5.用編輯器來開啟 start_mdecourse.bat檔案。 \n 6. 將 檔中的py373全部都改成py382後，重新啟動。 \n 7.直接在y槽中執行，python\xa0 get-pip.py 來安裝pip軟件。 \n 8.完成之後，來安裝軟件包，輸入python pip install  Flask \xa0依此類推。 \n 9.安裝的有 Flask 、 Markdown 、 lxml 、 bs4 、 flask_cors 、 pelican 、 leo 。 \n 我的教學影片: https://youtu.be/Im6e8ZD1-Xo \n \n \n 分配工作和問題討論 \n 40623115 亂數分組程式 40623251 可攜系統 40723204 可攜系統 42723210 四輪車\xa0 可攜系統 亂數分組程式 40723212 四輪車 40723225 四輪車 40723232 亂數分組程式 40723234 可攜系統 40723238 四輪車 40723245 亂數分組程式 40723250 亂數分組程式 \n 負責各主題的人，主要以課堂上的進度，來更新個人的倉儲，每次更新進度時要做一下紀錄。所有的主題必須要在 2020年3月26日之前完成，提交3-5頁的兩欄pdf報告，並在youtube上保存3-5分鐘的影片，將pdf文件放在個人倉儲 downloads / assignment1.pdf。最後整合的作業以assignment1放在自己的網站連結加/ assignment1內。有問題可以在我的\xa0 gitter \xa0以及 老師的  gitter \xa0上面發問，會的人也可以幫忙回答。 直播影片: https://www.youtube.com/watch?v=r0AABAp474U \n \n \n Fork分組倉儲 \n 1.先登入github，在搜尋自己組的倉儲，點進去。 2.點選右上角的Fork，選擇自己的github。 3.git clone --recurse-submodules\xa0(倉儲網址)。 4.git push完成，點選New pull request，等組長同意。 5.有衝突的話，進行git pull (分組網址)\xa0。 6.整合完成之後即可git push，等待組長同意。 \n 我的教學影片(有字幕): https://youtu.be/1bZ16BgmF8c \n \n \n New pull request \n 1.先登入github，點進去想要fork的倉儲。 2.點選右上角的Fork，再選擇自己的github。 3.git clone --recurse-submodules\xa0(倉儲網址)。 4.更新git push完成，點選New pull request，等組長同意。 5.組員要進行更新時，要記得先git pull (分組網址) 檢查版本。 6.有衝突的話，組長要處理和整合分支並且解決衝突。 我的教學影片: https://youtu.be/1bZ16BgmF8c \n \n \n Random grouping \n 測試程式可以到: Random grouping \n 抽查的python程式 \n 如果要使用python來進行亂數分組抽查的話，可以導入random來從列表中隨機抽出所需要的n個不同元素，如下面的程式執行之後，就可以亂數抽出4位。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n \n \n \n import   random  \n \xa0 \n group  =   [ 4 ,  10 ,  12 ,  25 ,  32 ,  34 ,  38 ,  45 ,  50 ]  \n \xa0 \n team  =   random.sample(group,  4 )  \n print   (team) \n \n \n \n \n \n \n \n 再來是要讀取網頁資料的話，就要導入requests，使用get請求即可直接下載，例如member = requests.get("網址")，再用print(member.text)就可以印出來了如下。 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n \n \n \n import   requests \n \xa0 \n web  =   "https://mdecourse.github.io/cd2020/downloads/2b_group_list.txt" \n \xa0 \n member  =   requests.get(web) \n \xa0 \n print (member.text) \n \n \n \n \n \n \n \n 如果使用讀取出的資料，還是無法使用的，因為member.text的性質是str字串，所以我就要將它變回原本的list列表，才可以進行亂數分組，改這個非常的簡單如下。 \n \n \n \n \n \n \n 1 \n \n \n \n x  =   eval (member.text) \n \n \n \n \n \n \n \n 最後我整理出來的程式，雖然沒有老師這麼精美，但是也是可以進行亂數分組的抽查的，如果要改抽查人數，改y = random.sample(i,2)的數字即可。 \n 最終程式碼 \n 程式碼連結: 抽查程式.py \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n \n \n \n import   requests \n import   random \n \xa0\xa0 \xa0 \n web  =   "https://mdecourse.github.io/cd2020/downloads/2b_group_list.txt" \n member  =   requests.get(web) \n #print(memder.text) \n x = 0 \n for   i  in   eval (member.text): \n \xa0\xa0\xa0\xa0 y  =   random.sample(i, 2 ) \n \xa0\xa0\xa0\xa0 x + = 1 \n \xa0\xa0\xa0\xa0 print ( "group" +   str (x)) \n \xa0\xa0\xa0\xa0 print (y) \n \n \n \n \n \n \n \n 亂數分組的的python程式 \n 一開始先從網頁上抓人員，這次跟上面的不太一樣，抓出來的本來就是str字串，所以必須把每個學號轉變為 list列表，直接將f.text加上 .split() 來轉換，完成之後就可以使用，random.shuffle()來將整個順序打亂，再來設定一共要分幾組，再使用while迴圈來判斷每一組要有幾個人，使用if判斷是來中斷迴圈，len()是指一共有幾個數量的意思，要加組別的話就要再多寫一列，接著使用for 迴圈來從，剛剛算好的每組人數，例如:13、12、12、12，再使用一個for迴圈，來一個一個配置組人員，這時候直接使用迭代iter()的next()，來抓人員這樣子就不會重複了，最後再加上一些說明、分格、標題，就可以開始進行亂數分組了。 \n 最終程式碼 \n 程式碼連結: 亂數分組.py \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n \n \n \n import   requests \n import   random \n \xa0 \n web  =   "http://s1.mde.nfu.edu.tw:8000/?semester=1082&courseno=0780" \n f  =   requests.get(web) \n #print(type(f.text)) \n x  =   f.text.split() \n #print(len(x)) \n #print(x) \n random.shuffle(x) \n \xa0 \n group1,group2,group3,group4  =   0 , 0 , 0 , 0 \n while   1 = = 1 : \n \xa0\xa0\xa0\xa0 group1  + =   1 \n \xa0\xa0\xa0\xa0 if   (group1 + group2 + group3 + group4)  = =   len (x): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 break \n \xa0\xa0\xa0\xa0 group2  + =   1 \n \xa0\xa0\xa0\xa0 if   (group1 + group2 + group3 + group4)  = =   len (x): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 break \n \xa0\xa0\xa0\xa0 group3  + =   1 \n \xa0\xa0\xa0\xa0 if   (group1 + group2 + group3 + group4)  = =   len (x): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 break \n \xa0\xa0\xa0\xa0 group4  + =   1 \n \xa0\xa0\xa0\xa0 if   (group1 + group2 + group3 + group4)  = =   len (x): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 break \n #print(group1,group2,group3,group4) \n \xa0 \n print ( "全班人數有" + str ( len (x)) + "人" ) \n print ( "=" * 20 ) \n grp_num  =   group1,group2,group3,group4 \n a  =   iter (x) \n team  =   0 \n for   i  in   grp_num: \n \xa0\xa0\xa0\xa0 team  + =   1 \n \xa0\xa0\xa0\xa0 print ( "group" + str (team) + " 共 " + str (i) + " 人" ) \n \xa0\xa0\xa0\xa0 for   g  in   range (i): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( next (a)) \n \xa0\xa0\xa0\xa0 print ( "-"   *   20 ) \n \n \n \n \n \n \n \n \n \n Portable\xa0 System 範例: \n PortableGit:\xa0 https://git-scm.com/download/win \n MSYS2:\xa0 https://www.msys2.org/ \n Python 3.8.1:\xa0 https://www.python.org/downloads/ \n CMSiMDE:\xa0 https://github.com/mdecourse/cmsimde \n Flask:\xa0 https://github.com/pallets/flask \n lxml:\xa0 https://github.com/lxml/lxml \n bs4:\xa0 https://pypi.org/project/beautifulsoup4/ \n markdown:\xa0 https://github.com/Python-Markdown/markdown \n flask-cors:\xa0 https://github.com/corydolphin/flask-cors \n Pelican:\xa0 https://github.com/getpelican/pelican \n Reveal.js:\xa0 https://github.com/hakimel/reveal.js/ \n Leo Editor:\xa0 https://github.com/leo-editor/leo-editor \n SciTE:\xa0 https://www.scintilla.org/SciTEDownload.html \n Tiny C Compiler:\xa0 https://github.com/TinyCC/tinycc \n Fossil SCM:\xa0 https://www.fossil-scm.org/ \n Jupyterlab:\xa0 https://github.com/jupyterlab/jupyterlab \n Flutter:\xa0 https://github.com/flutter/flutter \n Visual Studio Code:\xa0 https://github.com/microsoft/vscode \n \n V-rep可動四輪車 \n 使用內建功能來創建模型，並且模擬最基本的直線移動。 \n 影片連結: https://youtu.be/y8DJ1sjuAqM \n', 'tags': '', 'url': 'Week1-5.html'}, {'title': 'OBS Streaming', 'text': 'OBS官方網站: https://obsproject.com/ \n 資料一 : https://pcrookie.com/?p=2113 \n 資料二 : 如何使用-OBS-與-Youtube-進行直播.pdf \n 下載OBS Studio的安裝程式，直接執行即可安裝，安裝畫面如下圖，雖然為英文，不過只要一直按〔Next〕或〔Agree〕按鈕即可完成，非常簡單。 \n \n OBS Studio的執行畫面如下，會自動切換為正體中文語系，所以不用擔心操作界面看懂。 \n 畫面中央的黑色範圍是預覽視窗，下方則有「場景」、「來源」、「混音器」、「轉場特效」及「控制項」五個部份，簡單介紹一下它們的功用： \n \n 1.場景： \n \xa0 就像拍電影、錄電視節目一樣，可以事先編排好不同的場景，每個場景都可配置不同的畫面、格式、影音訊號源，可在錄影或直播時自由切換。 \n 你可以按下「場景」左下角的〔+〕來新增 或 〔—〕刪除場景，點擊場景名稱即可切換，或是在場景上方點擊滑鼠右鍵呼叫躬耕 \n \n 2.來源： \n 來源就是要錄製的影音或文字資料，按下〔＋〕按鈕可以加入圖片(例如當背景圖、LOGO…)、媒體來源(電腦中的影片或音樂檔)、文字(可當字幕、說明、LOGO…)、擷取音訊輸入(可用麥克風錄音)、視窗擷取(擷取某個軟體的視窗)、視訊擷取裝置(如webcam)、遊戲擷取、顯示器擷取(擷取整個螢幕的畫面)…等，功能相當多樣。 \n \n 新增想要的訊號來源之後，可以在上面點二下滑鼠左鍵來進行設定，例如我最常用的「視窗擷取」，就可以在「視窗」選單下拉選出要錄製的視窗，如此一來就不怕在錄影或直播時不小心把其他的操作畫面也錄製進去。 \n \n 下圖就是阿正老師加入了「文字」(右上角的字樣)、「圖片」(左下角)、媒體來源(右下角的影片)及視窗擷取(左上角的瀏覽器畫面)來進行示範，每個加入的來源都可以在預覽視窗上點擊選取，選中的項目就會出現紅色外框(如下方的「軟體玩家直播測試」文字)，可以自由移動、縮放。 \n \n 如果要編輯「來源」的任一個項目，只要在項目上方點二下滑鼠，而右邊有一個眼睛圖示跟一個鎖頭圖示，點擊「眼睛」即可隱藏該項目，「鎖頭」則是將該項目鎖定(無法移動/縮放)。 \n 愈上面的項目就愈上層顯示（例如下圖的「文字」就會蓋過「圖片」，在圖片的上方顯示），可以利用下方的︿跟 ﹀按鈕來上下移動顯示的順序。 \n \n 3.混音器： \n 如果多個訊號來源都有聲音，則可以使用「混音器」來調整聲音的大小，只要拖曳音量控制桿(下圖紅色箭頭處)即可，按下右方的喇叭圖示即可切換為靜音。 \n \n 4.轉場特效： \n 當你在錄影或直播時有多個場景，可以自由切換不同的場景，而「轉場特效」就是在切換場景時所要使用的特效，類似PowerPoint的「轉場動畫」，不過特效目前只有四種，不像PowerPoint那麼花俏。 \n \xa0 \xa0 \n 5.控制項： \n 「控制項」裡面的按鈕可以掌控整個直播或錄影的程序，例如〔開始串流〕就是開始直播、〔開始錄製〕可以進行錄影、〔工作室模式〕可以切割為兩個畫面方便進行多場景的調整及直播、〔設定〕則是整個OBS的功能設置。 \n 要開始直播或錄影之前，請先按下〔設定〕按鈕。 \n \n 裡面一共有七大類，數十個詳細的設定項目。 \n \n 例如想要進行串流直播，則需切換到「串流」頁面，並在「服務」選單中選擇要串流的服務類型，選擇後再進行相關的直播設定。 \n \n 另外在「輸出」頁面中，設定要串流及錄影的品質，並選擇編碼器和錄影格式，如果有獨立顯示卡還可使用硬體編碼，以減少CPU的負載。 \n \n 如果你有多個場景要進行直播，可以點擊「工作室模式」，就會切換為左右兩個視窗，左邊是預覽的場景，右邊則是實際播出的場景。 \n 可以在左下角的「場景」中先點選一個場景，就會顯示在左邊的「預覽」視窗中，按下兩個視窗中央的 〔轉場〕按鈕即可切換為當前預覽的場景。 \n \n 還可按下中間的〔＋〕，預先加入多種快速轉場按鈕，之後就可以點擊這些按鈕來使用不同的轉場特效。 \n \n 看了以上介紹之後，相信你應該對OBS Studio的操作有所認識，最後阿正老師再來簡單整理一下2種常用的使用方式： \n 第1種：單一場景 錄影或直播 \n \n 按〔設定〕來設定要串流的平台或錄影的格式 → \n 在「來源」按〔＋〕加入訊號來源 → \n 按下〔開始串流〕 或 〔開始錄製〕→ \n 完成之後按〔停止串流〕或〔停止直播〕 \n \n 第2種：多重場景 錄影或直播 \n \n 按〔設定〕來設定要串流的平台或錄影的格式 → \n 在〔場景〕按〔＋〕加入場景→ \n 點選場景 ， 在「來源」按〔＋〕加入訊號來源 → \n 切換到其餘的每個場景 ， 在「來源」按〔＋〕加入訊號來源 → \n 進入「工作室模式」，選擇要轉播/錄製的場景 → \n 按下〔開始串流〕 或 〔開始錄製〕→ \n 完成之後按〔停止串流〕或〔停止直播〕 \n', 'tags': '', 'url': 'OBS Streaming.html'}, {'title': 'Week6-9', 'text': "直播會議Assignment 2 \n 分工表: \n \n \n \n Topic 1: \n Topic 0: \n \n \n 40623115 \n 40723232 \n \n \n 40623251 \n 40723234 \n \n \n 40723204 \n 40723238 \n \n \n 42723210 \n 40723245 \n \n \n 40723212 \n 40723250 \n \n \n 40723225 \n 40723210 \n \n \n \n Topic 1 的文章很長，自己看要翻哪一大章節都可，Topic 0 有兩篇pdf也是一樣自己決定，要全翻也行自己斟酌。最後是個人網頁要有assignment2，downloads裡面也要有檔案assignment2.pdf。作業期限到4/23，要自行檢查是否完成所有內容。 \n 直播影片: https://youtu.be/a69tNWKmC64 \n \n \n webcam 畫面製作 \n 老師要求每個人之後的影片，都必須要有視訊畫面，所以要準備一台webcam ，但是需要花錢買，我們可以使用手機來代替webcam，就是使用 iVcam 來進行畫面製作，電腦以及手機都要下載，至於obs與iVcam連線可以參考下方的影片。 \n 教學影片連結: https://youtu.be/YCAGt9qku6I \n \n \n V-rep\xa0bubbleRob Tutorial \n 操作影片連結: https://youtu.be/BStp8J-KXuY \n \n \n V-rep 馬達驅動四輪車 \n 使用內建功能來創建模型，並且模擬最基本馬達的直線移動。 \n 影片連結: https://youtu.be/y8DJ1sjuAqM \n \n \n 四輪車鍵盤控制轉向 \n V-rep 檔案連結:\xa0 4 wheel car keyboard.ttt \n 四輪車加上轉向及鍵盤控制，先開啟之前做好的四輪車，將兩個前輪馬達複製貼上，再使兩個馬達原地轉向90度，創建兩個小正方體，位置與前輪一模一樣， 需要設定屬性避免與其他部件衝突，本體、輪子、小正方體都要關閉如下圖。 \n 將控制迴路啟用，來控制轉向的限制角度，兩個馬達都用預設即可，如下圖設定。 \n 將之前的馬達速度都關掉， 點擊馬達圖示視窗下的 show dynamic properties dialog ，把 motor properties的速度改為0 ，底下的 lock motor when target velocity is zero是 馬達速度為零時鎖定馬達，可開可不開。 \n \n 最後把方塊拖移至對應馬達下，再整個放進本體下，把對應的前輪馬達放置方塊下，本體新增一個控制腳本，選擇cuboid，點擊菜單欄的Add > Associated child script > Threaded，將寫好的腳本複製貼上，更改前輪馬達的名子，這樣腳本才能控制，下圖為整個最終結構。 \n 四輪車鍵盤控制轉向程式碼: \n -- This script is threaded! It is a very simple example of how Ackermann steering can be handled.\n-- Normally, one would use a non-threaded script for that\n\nthreadFunction=function()\n\twhile simGetSimulationState()~=sim_simulation_advancing_abouttostop do\n\t\t-- Read the keyboard messages (make sure the focus is on the main window, scene view):\n\t\tmessage,auxiliaryData=simGetSimulatorMessage()\n\t\twhile message~=-1 do\n\t\t\tif (message==sim_message_keypress) then\n\t\t\t\tif (auxiliaryData[1]==2007) then\n\t\t\t\t\t-- up key\n\t\t\t\t\tdesiredWheelRotSpeed=desiredWheelRotSpeed+wheelRotSpeedDx\n\t\t\t\tend\n\t\t\t\tif (auxiliaryData[1]==2008) then\n\t\t\t\t\t-- down key\n\t\t\t\t\tdesiredWheelRotSpeed=desiredWheelRotSpeed-wheelRotSpeedDx\n\t\t\t\tend\n\t\t\t\tif (auxiliaryData[1]==2009) then\n\t\t\t\t\t-- left key\n\t\t\t\t\tdesiredSteeringAngle=desiredSteeringAngle+steeringAngleDx\n\t\t\t\t\tif (desiredSteeringAngle>45*math.pi/180) then\n\t\t\t\t\t\tdesiredSteeringAngle=45*math.pi/180\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tif (auxiliaryData[1]==2010) then\n\t\t\t\t\t-- right key\n\t\t\t\t\tdesiredSteeringAngle=desiredSteeringAngle-steeringAngleDx\n\t\t\t\t\tif (desiredSteeringAngle<-45*math.pi/180) then\n\t\t\t\t\t\tdesiredSteeringAngle=-45*math.pi/180\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tmessage,auxiliaryData=simGetSimulatorMessage()\n\t\tend\n\n\t\t-- We handle the front left and right wheel steerings (Ackermann steering):\n\t\tsteeringAngleLeft=math.atan(l/(-d+l/math.tan(desiredSteeringAngle)))\n\t\tsteeringAngleRight=math.atan(l/(d+l/math.tan(desiredSteeringAngle)))\n\t\tsimSetJointTargetPosition(steeringLeft,steeringAngleLeft)\n\t\tsimSetJointTargetPosition(steeringRight,steeringAngleRight)\n\n\t\t-- We take care of setting the desired wheel rotation speed:\n\t\tsimSetJointTargetVelocity(motorLeft,desiredWheelRotSpeed)\n\t\tsimSetJointTargetVelocity(motorRight,desiredWheelRotSpeed)\n\n\t\t-- Since this script is threaded, don't waste time here:\n\t\tsimSwitchThread() -- Resume the script at next simulation loop start\n\tend\nend\n\n-- Put some initialization code here:\n-- Retrieving of some handles and setting of some initial values:\nsteeringLeft=simGetObjectHandle('Steer_left_joint')\nsteeringRight=simGetObjectHandle('Steer_right_joint')\nmotorLeft=simGetObjectHandle('Front_left_joint')\nmotorRight=simGetObjectHandle('Front_right_joint')\ndesiredSteeringAngle=0\ndesiredWheelRotSpeed=0\nsteeringAngleDx=2*math.pi/180\nwheelRotSpeedDx=20*math.pi/180\nd=0.755 -- 2*d=distance between left and right wheels\nl=2.5772 -- l=distance between front and read wheels\n\n-- Here we execute the regular thread code:\nres,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)\nif not res then\n\tsimAddStatusbarMessage('Lua runtime error: '..err)\nend\n\n-- Put some clean-up code here: \n 教學影片連結: https://youtu.be/0W1wmC1tr4A \n \n \n V-rep 更新至最新版本 \n 1.到CoppeliaSim官方網站: https://www.coppeliarobotics.com/ \xa0。 \n 2.點選上方的 Downloads ，下載功能齊全的教育版。 \n 3.下載 :\xa0 CoppeliaSim Edu, Binaries \xa0可攜的版本。 \n 4.解壓縮完成即可，舊版的就可以刪掉了。 \n \n \n Python remote api 環境配置 \n 在自己的Y槽下輸入以下這三個模組: \n 1.pip install numpy \n 2.pip install imutils \n 3.pip install opencv-python \n 才可以開始嘗試 透過廣域網路連線控制。盡量使用python3.8.2來配置環境，輸入程式時可能會跑很久，是正常的情況。 \n \n python3.8.2，輸入leo 後軟體閃退問題 \n 1.輸入 pip list ，檢查leo 版本是否為 6.1 版。 \n 2.是的話就先卸載\xa0 pip uninstall leo 。 \n 3.再重新載一次 leo ，輸入\xa0pip install leo==6.2.1 來指定版本。 \n 4.載完之後，再輸入 leo\xa0 一次，就可以正常開啟了。 \n \n 第8周meet第二組直播影片 \n \n \n 期中考週線上課程 \n \n \n 老師與組長開會, 開放 live streaming, 回答與課程相關問題. \n \n \n 要求所有學員, 透過個人行事曆建立 Google Handout Meet 會議, 展示個人桌面操作, 開放 live stream, 並錄製至少 10 分鐘的個人期中簡報影片, 說明個人於 W1-W8 所完成的相關內容. \n \n \n 完成上述個人簡報錄製後, 將存於個人 Google Drive 中的期中簡報 mp4 影片, 以共享設置為所有登入 \xa0 @gm \xa0 帳號的用戶都可以觀看. \n \n \n 完成上述影片共享設置後, 請登入 \xa0 @gm \xa0 個人帳號, 至 \xa0 https://forms.gle/T1Vs4sv9EdetxoWF7 \xa0 填寫表單並完成期中個人自評成績登錄. \n \n \n 完成上述各步驟後, 將繼續進行線上課程之其他內容直播或錄影. \n \n \n 協同產品設計課程實習項目: \n 1. OnShape 零組件繪圖及協同設定 \n https://learn.onshape.com/ \n 2. 零組件轉檔進入 CoppeliaSim \n Parasolid \n Parasolid-XT-format-reference_2006.pdf \n SAT \n Sat File format.pdf \n https://en.wikipedia.org/wiki/ACIS \n DXF, IGES and STEP \n DXF_IGES_STEP.pdf \n 3. CoppeliaSim 零組件轉入後之零件分割, 零件從屬關係組立與控制設定 \n 4. 利用 CoppeliaSim Python Remote API 控制四輪車 \n 5. 將 Remote API 程式結合 Flask + Oauth2 + SQLite 進行 網際機電控制程式開發 \n 6. 利用 Ubuntu 20.04 虛擬主機, 進行網際協同機電系統操控模擬 \n 7. 協同四輪車與平面機構系統產品整合開發", 'tags': '', 'url': 'Week6-9.html'}, {'title': 'Article impression', 'text': 'DesignCollaboration \n 這一本主要講述到何謂協同設計，所謂協同設計是指為了完成某一設計目標，由兩個或兩個以上的隊員，通過一定的信息交換和相互協同機制，分別以不同的設計任務共同完成這一設計目標。協同設計往往都可以，使產品變得更加優秀，每個人都有自己的技藝與專長，就能彌補各自不擅長的領域。一個成功的協同設計，需要選擇合適的工具，如本文所提到各種設計工具 :  \n \n FIGMA : 非常適合在設計文件的同一區域中包含多個人。您可以時時觀看隊友的設計或在同一個設計上一起工作。是一個以協作為優先的共享工作區工具。 \n \n \n MARVEL : 是一個更簡潔、規範和專注的空間，非常適合與非設計團隊成員進行協作。允許採用更標準化的協作形式，使客戶可以輕鬆地與我們合作。 \n Zeplin : 是一個有用的傳遞工具，使開發人員可以深入研究設計工作的細節。 \n Quip : 是集思廣益在產品 / 流程文件的絕佳平台。用它來記錄和組織團隊成員在項目上需要了解的所有環境和知識。 \n \n 總結: 毫無疑問的，協同合作對於設計的共同管理、控制和改善是一個有效的策略，因此透過協同作，成本會因為無效率的人工流程的減少而大幅降低，設計創作的能見度會因此提高，資產的利用率也會改善。然而光說不練是沒有用的，這些效益必須建立在「實踐」上，要把策略轉化為行動，讓每個人專注於各自技藝與專長。要達成協同合作的策略，必須改善資訊的管理，縮減各夥伴間資訊能力的差距。其間當然存在著各項挑戰，但只要與設計的夥伴們多加協調，並善用資訊科技的服務提供者所提供的協同合作功能，一定能夠克服各種困難。 \n \n \n \n EngineeringProductDesignCollaboration \n 本文與來自六個產品製造商的  34  名工業和工程設計師 進行了有關實際產品設計項目的深入採訪，最後簡化了協作流程，以創建具有代表性的流程模型，發現了四種類型的典型協同產品設計流程及其特徵 : \n \n 類型  1 ： 由 ID ( 工業設計師 ) 主導的概念驅動過程。 \n 類型  2 ： 由 ID ( 工業設計師 ) 主導的內外聯合過程。 \n 類型  3 ： 由 ED ( 工程設計師 ) 主導的由內到外的流程。 \n 類型  4 ：  ID ＆ ED ( 工業與工程設計師 )  協同流程。 \n \n 在研究協同設計過程中，使用紮實的理論方法收集數據和分析，在進行深度訪談時，案例的公司選擇設置三個標準 :1. 公司應生產中等複雜的電子產品。 2. 獨立的工業設計和工程設計部門。 3. 市場上領先的公司，生產精心設計的高質量產品。來增加協同的適用性，再來是選擇受訪者的條件，至少要有兩年以上公司工作經驗，參與至少一個產品開發過程的周期，能與同行的緊密合作和互動，最後是面試的程序，要有效率的訪談，主要分為四個主題 : 個人信息、設計過程、角色和專業知識、交互，受訪者必須提供詳細的背景訊息，為了避免面試官產生偏見，在每一次的會議都要有會議記錄並且錄音，以便之後的一些發展。 \n \xa0\xa0\xa0 每個人都會有經歷設計的過程，儘管轉錄數據都包含與設計過程有關的信息，但它們都與其他內容混合在一起，包括項目情況和目標、個人角色、技能和知識，所以我們必須再確定每個人的經歷。下一步是通過鑲嵌法將公司的設計過程，結合到協同設計過程當中，在鑲嵌方法中，結合交叉檢查的局部過程，有利於提高可靠性和通用性。一旦制定了公司的協同產品設計流程，就將它們分類以確定它們的目的和條件，再通過簡化公司的設計流程，以幫助它保持可比性和基本特徵。 \n \xa0\xa0\xa0 我們確定了協同設計過程類型的存在，根據工業和工程設計師的深入訪談，建立起了協同設計流程，發現了四種類型的協同設計過程，根據設計過程早期階段的不同進行分類，四種類型的過程在不同的上下文中用於不同的目的。有時是戰略性地用於開發新設計或重新設計，有時是因為內部和外部因素而應用，工業設計師是有影響力的，而且是擴展的。 \n \n \n \n MechanicalDesignProcess \n 第1章 成功的設計:   主要是向我們介紹電子產品外殼設計，首先呢要求設計一個產品，就必須了解到客戶需要什麼，在一個一個把要求給列出來，並將每一個目標實現，一個成功的產品，必須要有完整的規範，整個團隊需要有各個領域的人，來互相交付整個工程工作，一個好的團隊要會時間分配、資源分配、優先級管理、符合產品規格、實現成本目標、各項目的報告，首先不管什麼職業都一定要遵守約定，必須要按規定來、按時交貨，資源要有效的分配，不能擅自將整個資源變動，管理呢是需要針對單個項目以及相對於爭奪相同資源，產品成本是工程經濟的基本，設計師必須注意成本目標、零件的材料和工藝選擇、適合產品整個生命週期、將成本信息提供給團隊，最後就是將各個項目的情況寫成報告。再來設計人員要知道，在何時切換素描、細部化兩種模式，素描是一個非常快速的構思階段，只使用鉛筆來完成構想，細部化就是提供某些部分的詳細說明，在這種詳細的模式下，就可以準確的計算出設計的關鍵部分，設計經常伴隨著溝通及評論，溝通及評論是設計成功的必要條件，互相交流來傳達有關設計的訊息，各個不同身分的人，都能帶給我們更多的創新想法，因此設計中涉及的其他主要團隊及其通常的功能，來完成設計成功的一大步。 \n 第2章 構建設計 :   我們在設計一個產品，都必須要先從產品構思開始，為了要證明產品構思的理念是對的，就要模擬或做出構建原型，首先設計師的工作就是，設計一個全新的產品，或是繼續設計現有的產品，全新的設計在基本上是沒有任何限制的，延續設計是針對產品的一些部分，來進行修改的，在這種情況下設計師也會面臨，跟全新的設計一樣困難的挑戰，要考慮到不破壞原本的系統結構，但是也可以利用現有的設計來進行更改，再來是現有的設計重大改變，設計師要更改整體設計的一部分，就需要修改很大一部分，因此與全新設計相比，存在更多約束。設計一個產品系統是有很多種的，設計人員必須要牢記各種設計系統，其中有關注個人責任、了解該設計交互的其他設備、熟悉整體的系統功能，在構思草圖這是項目是理想的階段，一旦想法採用某種形式，就可以輕鬆地對其進行審查和修訂，審查其想法並進行原型製作，最後再分析及修改來進行最終測試，通過後就可以正式批准生產的設計。  \xa0\xa0\xa0  開始製作後要考慮的東西就多了，產品的壽命、要求的環境溫度、成本的考量、生產的各尺寸及數量等等，還有最佳的放置位置及間隙距離，主要設計最有效的系統安排，首先要考慮的標準，是產品的總體尺寸，他們必須確定是否可以在，給定的總體規模內滿足所有要求。零件和外殼的最佳間隙距離，如果要保持特定的距離的外部尺寸，則設計必須允許公差的最厚外殼、最大零件尺寸，對於給定的整體大小，對象之間的距離將有一些特定的限制，對象之間的距離將取決於對象的尺寸公差和對象位置的公差。在大多數設計當中，都必須使物體的整體尺寸變小，這導致設計對象縮小之間距離，使總體尺寸和所產生的重量最小化，所以我們的東西通常重量輕、較小的生態足跡、有效的節省空間、降低成本，盡可能地滿足客戶需求。 \n 第3章 考量結構問題 : 堅固的產品需要一個好的結構設計，為了滿足條件我認為我們必須建立在穩固的基礎，以便其他設計可以以此為基礎，我們需要利用各種材料強度來提出結構解決方案，定義通用流程來考慮電子外殼結構設計，滿足客戶來應付在各種環境下使用。在材料的強度上，要考慮的不僅僅是強度，還需要考慮最具成本效益的方式，設計電子外殼結構，要先收尋是否有類似產品，使用該產品設計好的解決方案作為快速起點，只是會缺乏創造力而無法解決特定產品的問題，快速粗略計算設計，對於簡化結構元素上使用了基本設計方程，在複雜的分析中來進行討論，最後是過度的設計，雖然能解決一些問題，但過度設計可能會導致產品成本增加。結構設計過程中有通用的六種步驟， 相似設計 可能是自己公司的產品，也有可能是公司外面的競爭產品， 分力 是作用在物體上的力，通常是電子外殼中的幅度和方向，是指物件、零件、構件的動態力， 現有結束條件 是確定對象的最終條件固定和自由， 建議材料和橫截面 為確定支撐這些力所需的材料和橫截面組合，使用最大應力公式來判斷最佳組合方案， 合併功能 查看正在組合的零件的另外想法方面，是實際上要從一個單個零件創建兩個單獨的零件，此舉可以降低總體成本， 所需的安全因素 在設計過程中最重要的一點，必須確保工作人員與客戶的安全，不能因成本高或費時就不考慮。 \n 第4章 材料與工藝 : 看完了設計的結構基礎，我們就要開始來了解，如何選擇組件的各個零件，材料和工藝的組裝和維修，將是設計產品所需要考慮的，成本會是設計過程中做出選擇的決定因素，各個零件的材料、生產零件的過程、組裝零件的組裝程序、測試零件和組件的測試程序、制定質量控製程序、滿足服務要求，在對於產品上是非常重要的選擇。電子外殼在設計師腦海中，有非常多永恆的問題，通稱為設計師的思維空間，將項目進度或設計問題傳達給設計團隊的其他成員，以及需要誰進行設計審查，是要考慮的情況中比較重要的。 \n 總結: 產品的設計階段需要全面確定整個產品的結構、規格，來確定整個生產系統的佈局，因而，產品設計意義重大，具有牽一發而動全局的重要意義。如果一個產品的設計缺乏生產觀點，那麼生產時就將耗費大量費用來調整和更換設備、物料和勞動力。相反，好的產品設計，不僅表現在功能上的優越性，而且便於製造，生產的成本低，從而使產品的綜合競爭力得以增強。許多在市場競爭中占優勢的企業都十分注意產品設計的細節，以便設計出造價低而又具有獨特功能的產品。設計屬於熱門的戰略工具，好的設計才是贏得顧客的重要關鍵。 \n', 'tags': '', 'url': 'Article impression.html'}, {'title': 'Week10-14', 'text': 'gm用戶登錄設置 \n 1.登錄到自己的學校gmail， 到 https://console.developers.google.com \n 2.選台灣並勾選同意，點選建立專案，名子沒有規定 \n 3.到老師的 cd2020pj1 \xa0，直接git clone 整個倉儲放在tmp \n 4.啟用API和服務，選Google + Domain API 在按啟用 \n 5.點選憑證 > 設定同意畫面，選擇內部，應用程序名稱自己取 \n 6.在"API和服務"下，進入"憑據" 建立“ OAuth 客戶端ID"類型 \n 7.選擇網路應用程式，按建立並把帳密儲存到tmp下 \n 授權的JavaScript來源： https://localhost:8443 授權的重定向URI： https://localhost:8443/login/google/ \n 8.開啟leo，將cd2020pj1.leo打開，編輯路徑和名稱 \n 9. 儲存後按一下darwROC，再輸入pip install authomatic \n 10.進入倉儲cd2020pj1，輸入python wsgi.py就完成了 \n 影片連結: https://youtu.be/fdH7k_-vIpk \n \n \n Assignment 3 直播討論 \n MSModelingAndTFApproaches: 40723232 前20 40723234 21-50 40723204 51-80 40723225 81-110 40623115 111-140 40623251 141-170 40723245 171-207 MSModelingAndTFApproaches: 40723238\xa0 40723210\xa0 \n MechaEducFutureNeed: 40723250\xa0 40723210 MechaFutureAndChallenges: 40723212\xa0 Mechatronic project 40723210\xa0 \n 直播影片: https://youtu.be/GmKxlNPx-gs \n \n \n Vrep虛擬主機設置 \n 1.下載 VirtualBox ，下載老師用好的 Ubuntu \n 2.點選檔案的 > 匯入應用裝置，把Ubuntu匯入 \n 3.設定網路Host-Only，再啟動 Ubuntu 主機 \n 4.輸入密碼kmol2020，點選Activities > 開啟LXTermial \n 5.輸入xterm& ，使用ctrl+滑鼠右鍵來放大視窗 \n 6.用ls來顯示資料，再用cd來進入該資料夾內 \n 7.輸入./coppeliaSim.sh 來開啟vrep就可準備連線了 \n 影片連結: https://youtu.be/3lDOCkIkJ00 \n \n \n Remote API 連線 \n 1.先下載老師的 控制程式 ，和 Xming \xa0軟體 \n 2.Xmig\xa0解開後，放在data下就可以了 \n 3.新增 設定3個 虛擬主機的NAT網路埠號 \n 4.開啟putty新增一個localhost ，port 22 \n 5.設定SSH下的X11，儲存之後按Open \n 6.開啟XLaunch.exe，都按下一步即可 \n 7.putty開啟視窗的帳密都是kmol2020 \n 8.使用mv cop*\xa0 coppeliasim 來更改名子 \n 9.開啟 car_model.py ，Tools > Go 即可 \n 影片連結: https://youtu.be/6vVJh1cni3c \n \n \n', 'tags': '', 'url': 'Week10-14.html'}, {'title': 'SSH setting', 'text': '以ssh 對 Github 連線(目前使用的) \n 1.先將Y:\\portablegit\\bin下的sh.exe(通常會有)建立起來。 2.輸入sh，輸入 ssh-keygen -t rsa -b 4096 -C "學號 "。 3.在Y: \\home_mdecourse裡創建一個.ssh。 4.輸入 Y: \\home_mdecourse \\.ssh/id_rsa。 5.按完Enter後，下載putty放在Y槽內。 6.編輯 start_mdecourse.bat，加入如下的指令。 Set GIT_HOME=%Disk%:\\portablegit\\bin\\ Set GIT_SSH=%Disk%:\\putty\\plink.exe 7.到自己倉儲的.git，url改成ssh(github)形式。 8.開啟puttygen.exe，將鑰匙存成private key。 9. 開啟putty.exe，設定proxy和路徑，在案save。 \n 10.再到github存入自己的key，就可以了。 \n 11.home_mdecourse下的.ssh目錄中的config 如下 \n # no proxy at home\n#ProxyCommand y:/PortableGit/mingw64/bin/connect.exe -H proxy.mde.nfu.edu.tw:3128 %h %p\n# set git_ssh=y:/putty/plink.exe with auth under putty github.com session setup\nProxyCommand y:/putty/plink.exe github.com %h %p\n  \nHost github.com\n    User git\n    Port 22\n    Hostname github.com\n     \n    # for connect.exe need openssh key format\n    #IdentityFile "y:\\home\\.ssh\\id_rsa_mdecourse"\n    # for plink.exe need rsa key format but set under putty github.com session\n    # plink.exe do not need the following setting\n    #IdentityFile "y:\\home\\.ssh\\mdecourse_putty_private.ppk"\n  \n    TCPKeepAlive yes\n    IdentitiesOnly yes \n 我的教學影片(有字幕): https://youtu.be/k-sOF6PQa1I \n \n \n IPv4 ssh key 設定(之前使用的) \n \n \n \n 1.先把 git config --edit --system裡面的 helper = manager刪除後輸入:wq(是指儲存後退出) 。 2.進入控制台>使用者帳戶>認證管理員>windows認證>刪除現存的github帳號。 3.輸入 ssh-keygen -t rsa -b 4096 -C "github的email "。 4.輸入你想存放的位子例如: Y:\\home\\.ssh/id_rsa。 5.一直案Enter到結束。 6.打開 id_rsa並且全部複製>進入setting> SSH and\xa0 GPG\xa0 keys 。 7.案New ssh key 貼上>輸入想要的名子儲存。 我的教學影片: https://youtu.be/SJHMm3o5uEw \n \n \n', 'tags': '', 'url': 'SSH setting.html'}, {'title': 'Week15-18', 'text': '\n', 'tags': '', 'url': 'Week15-18.html'}, {'title': 'Weeks Meeting', 'text': 'Week10 \n 分配Assignment 3的 topic2、topic3的原文書翻譯工作， \xa0並討論老師的 CMS 、 影片教學 ，來進行 gm用戶登錄設置，可以參考我的 影片 。 \n MSModelingAndTFApproaches: 40723232 前20 40723234 21-50 40723204 51-80 40723225 81-110 40623115 111-140 40623251 141-170 40723245 171-207 MSModelingAndTFApproaches: 40723238\xa0 40723210\xa0 \n MechaEducFutureNeed: 40723250\xa0 40723210 MechaFutureAndChallenges: 40723212\xa0 Mechatronic project 40723210\xa0 \n 直播影片: https://youtu.be/GmKxlNPx-gs \n \n \n Week11 \n Virtualbox 虛擬主機 NAT 設定與 X-win 連線 \xa0(登入 @gm 後可以在線觀看) \n Ubuntu 20.04 上的 CoppeliaSim 四輪車與 Windows 上的 Python Remote API 在 X-Windows 介面下協同控制影片 \xa0 (登入 @gm 後可以在線觀看) \n 討論上課內容如上方連結影片，以及講解ssh的設置，可以參考我的 SSH setting 。 \n 直播影片: https://youtu.be/NjWnIy4vX1g \n \n \n Week12', 'tags': '', 'url': 'Weeks Meeting.html'}, {'title': 'Notes', 'text': 'git基本指令 \n python基本語法 \n vi 與 vim 的指令整理 \n Dos 基本指令 \n SSH setting \n SolveSpace的快捷鍵 \n Nx12快捷鍵 \n Q&A', 'tags': '', 'url': 'Notes.html'}, {'title': 'Linux 指令', 'text': 'https://blog.techbridge.cc/2017/12/23/linux-commnd-line-tutorial/ \n 理論上所有的 Linux 發佈版本應該都要遵守檔案系統的標準（Filesystem Hierarchy Standard, FHS），但根據發佈版本不同或有差異，不過大致上檔案系統架構如下： \n \n /bin, /sbin  /bin主要放置一般使用者可以操作的指令，/sbin\xa0放置系統管理員可以操作的指令。連結到\xa0/usr/bin，/usr/sbin \n /boot  主要放置開機相關檔案 \n /dev  放置 device 裝置檔案，包話滑鼠鍵盤等 \n /etc  主要放置系統檔案 \n /home, /root  /home主要是一般帳戶的家目錄，/root\xa0為系統管理者的家目錄 \n /lib, /lib64  主要為系統函式庫和核心函式庫，若是 64 位元則放在/lib64。連結到\xa0/usr/lib,\xa0/usr/lib64 \n /proc  將記憶體內的資料做成檔案類型 \n /sys  與/proc\xa0類似，但主要針對硬體相關參數 \n /usr  /usr全名為\xa0unix software resource\xa0縮寫，放置系統相關軟體、服務（注意不是 user 的縮寫喔！） \n /var  全名為variable，放置一些變數或記錄檔 \n /tmp  全名為temporary，放置暫存檔案 \n /media, /mnt  放置隨插即用的裝置慣用目錄，/mnt\xa0為管理員/使用者手動掛上（mount）的目錄 \n /opt  全名為optional，通常為第三方廠商放置軟體處 \n /run  系統進行服務軟體運作管理處 \n /srv  通常是放置開發的服務（service），如：網站服務www\xa0等 \n \n 檔案與目錄管理指令 \n 在 Ubuntu 中我們可以打開終端機進行指令操作，就可以透過指令來管理檔案。 \n 一般指令格式如下： \n $ 指令  [ 選項 ] [ 選項值 ] \n \n ls：list，查看檔案及子目錄 \n \n 列出基本資料夾資料： \n \xa0ls \n 列出詳細資料和隱藏資料： \n \xa0// -l 列出詳細資料  -a  列出隱藏資料 \n \xa0$ ls -la \n 列出部分檔案： \n \xa0// 列出為  .js  的檔案 \n \xa0$ ls *.js \n \n pwd：print work directory，印出目前工作目錄 \n $ pwd \n // /Users/happycoder/Desktop/projects/HappyCoder \n cd：change directory，移動進入資料夾 \n \n 移動到目前資料夾下的 examples 資料夾： \n \xa0$ cd ./examples \n 移動到家目錄：~： \n \xa0$ cd ~ \n 移動到上一層目錄\xa0..： \n \xa0$ cd .. \n 移動到根目錄\xa0/： \n \xa0$ cd / \n \n mkdir：make directory，創建新資料夾 \n $ mkdir examples \n cp：copy，複製檔案 \n \n 先將字串 TEST 存入 README.md 文件中 \n \xa0$ echo "TEST" > README.md \n \xa0$ cp README.md \n \n mv：move (rename) files，移動檔案或是重新命名檔案 \n \n 移動檔案： \n \xa0$ mv README.md /examples/README.md \n 重新命名 \n \xa0$ mv README.md README_MV.md \n \n rm：remove file，刪除檔案 \n $ rm README.md \n \n 刪除目前資料夾下副檔名為 .js 檔案： \n \xa0$ rm *.js \n 刪除資料夾和所有檔案： \n \xa0$ rm -f examples \n \n touch：用來更新已存在文件的 timestamp 時間戳記或是新增空白檔案 \n $ touch README.md \n cat：將文件印出在終端機上 \n $ cat README.md \n tail：顯示檔案最後幾行內容 \n \n \n $ tail README.md \n \n 持續顯示更新內容，常用於 web server 看 log debug 使用： \n $ tail -f README.md \n \n more：將檔案一頁頁印在終端機上 \n \n 可以使用上下移動換頁，按 q 離開： \n $ more README.md \n \n file：檢查檔案類型 \n \n \n $ file README.md \n \n // README.md: HTML document text, UTF-8 Unicode text', 'tags': '', 'url': 'Linux 指令.html'}, {'title': 'vi 與 vim 的指令整理', 'text': '編輯模式 \n \n \n \n 指令 \n 說明 \n \n \n i \n 在游標位置進入編輯模式 \n \n \n I \n 在游標行的第一個非空白字元進入編輯模式 \n \n \n a \n 在游標位置後進入編輯模式 \n \n \n A \n 在游標行的最後一個字元進入編輯模式 \n \n \n o \n 向下新增一行，並進入編輯模式 \n \n \n O \n 向上新增一行，並進入編輯模式 \n \n \n cc \n 刪除游標行，並進入編輯模式 \n \n \n h 或 向左方向鍵 \n 游標向左移動一個字元 \n \n \n j 或 向下方向鍵 \n 游標向下移動一個字元 \n \n \n k 或 向上方向鍵 \n 游標向上移動一個字元 \n \n \n l 或 向右方向鍵 \n 游標向右移動一個字元 \n \n \n [ESC] \n 取消指令或退出編輯模式 \n \n \n \n 刪除 \n \n \n \n 指令 \n 說明 \n \n \n dd \n 刪除游標行 \n \n \n 行數 \xa0 → dd \n 刪除 n 行 \n \n \n dG \n 刪除游標行到最後一行 \n \n \n d1G \n 刪除游標行到第一行 \n \n \n d$ \n 刪除游標處到最後一個字元 \n \n \n d0 \n 刪除游標處到第一個字元 \n \n \n \n 檔案功能 \n \n \n \n 指令 \n 說明 \n \n \n :w \n 存檔 (加 ! 表示強制存檔) \n \n \n :w \xa0 檔案名稱 \n 另存新檔 \n \n \n :q \n 退出 vi (加 ! 表示不存檔強制退出) \n \n \n :wq \n 存檔並退出 vi \n \n \n : x \n 存檔並退出 vi \n \n \n :e \xa0 檔案名稱 \n 編輯其它檔案 \n \n \n :e! \n 還原至檔案編修前的狀態 \n \n \n :r \xa0 檔案名稱 \n 讀入檔案內容，並加到游標行的後面 \n \n \n :n \n 切換到下一個開啟的檔案 \n \n \n :N \n 切換到上一個開啟的檔案 \n \n \n :set nu \n 顯示行號 \n \n \n :set nonu \n 取消行號顯示 \n \n \n :files \n 列出所有開啟的檔案 \n \n \n :Ex \n 開啟檔案瀏覽器 \n \n \n :Ex \xa0 路徑 \n 於指定路徑開啟檔案瀏覽器 \n \n \n \n', 'tags': '', 'url': 'vi 與 vim 的指令整理.html'}, {'title': 'Q&A', 'text': '網頁無法顯示Brython，Spur Gear 導入錯誤，案F12來開啟Console檢查錯誤。 \n 問題(一)如下圖 \n \n 解決方法: \n 開啟本倉儲資料夾，打開flaskapp.py，案ctrl+f來找到 page_content = request.form[\'page_content\']，有2個地方都在底下加入 \n page_content = page_content.replace(\'// \xa0 <![CDATA[\', \'\') \n page_content = page_content.replace(\'// ]]> \', \'\') \n \n save後即可解決問題。 \n \n ==================================================================== \n 問題(二)如下圖 \n \n \n 解決方法: \n \n 檢查本倉儲資料夾static底下是否有brython.js與 brython_stdlib.js，沒有的話就必須加入這2個js檔案，有的話就是導入指令錯誤如: \n \n \n <!-- 導入 Brython 標準程式庫 --> \n < script \xa0 src = "./../cmsimde/static/brython.js" ></ script > \n < script \xa0 src = "./../cmsimde/static/brython_stdlib.js" ></ script > \n \n 必須改為: \n \n \n <!-- 導入 Brython 標準程式庫 --> \n < script \xa0 src = "/static/brython.js" ></ script > \n < script \xa0 src = "/static/brython_stdlib.js" ></ script > \n \n \n 即可解決顯示問題。 \n \n \n \n \n 問題(三)如下圖:\xa0 \n \n python wsgi.py 無法執行的話 \n \n \n 將start_mdecourse用編輯器打開 \n \n path= %path%; %Disk%:;%path_python%;%path_msys2%;%path_tcc%;%path_git%;%path_cmake%;%path_coreutils%; \n 改成 \n path=%Disk%:;%path_python%;%path_msys2%;%path_tcc%;%path_git%;%path_cmake%;%path_coreutils%;%path%; \n 如下圖就可以解決。 \n \n \n \n \n \n 問題(四)如下圖: \n \n 出現了亂碼的話，開啟Options。 \n \n \n \n 把cp950改成utf-8如下圖，就可以解決。 \n \n \n \n 問題(五)如圖下: \n \n 因為之前putty是ipv6 ，現在網路改成ipv4，所以putty要改成None(如下圖)。 \n \n \n 問題(六)更新至python3.8.2後，輸入leo軟體開起來會閃退: \n 1.輸入 pip list ，檢查leo 版本是否為 6.1 版。 \n 2.是的話就先卸載\xa0 pip uninstall leo 。 \n 3.再重新載一次 leo ，輸入\xa0pip install leo==6.2.1 來只訂版本。 \n 4.載完之後，再輸入 leo\xa0 一次，就可以正常開啟了。', 'tags': '', 'url': 'Q&A.html'}, {'title': 'Assignments', 'text': "報告連結: assignment1.pdf 、 assignment2.pdf \n Assignment 1: \n Due March 25, 2020 \xa0 for class 2a and \xa0 March 26, 2020 \xa0 for class 2b. \n 1. Describe how\xa0to\xa0do an efficient random grouping for this\xa0course or do the roll calling randomly? \n 2. Describe how to prepare a portable Python programming system for Windows 10 64bit system to allow one the maintain \xa0 CMSiMDE \xa0 website, \xa0 Pelican blog \xa0 and \xa0 Reveal.js \xa0 presentation on \xa0 Github ? \n 3. What do you need to know from\xa0 http://www.coppeliarobotics.com/helpFiles/index.html \xa0to implement a four-wheeled robot? \n Assignment 2: \n Due April 22, 2020 \xa0 for class 2a and \xa0 April 23, 2020 \xa0 for class 2b. \n 1.\xa0According to the material of Topic 0 and Topic 1, can you describe specifically what the mechanical design team need to do for accomplishing Assignment 1's\xa0 four wheeled robot. \n 2. What do you need to know from\xa0 https://cyberbotics.com/doc/guide/index \xa0 \xa0to implement a four-wheeled robot? \n Assignment 3: \n Due \xa0 May 27, 2020 \xa0 for class 2a and \xa0 May 28, 2020 \xa0 for class 2b. \n According to the reading of Topic 2 and Topic 3, propose a Mechatronic project by using \xa0 CoppeliaSim \xa0 or \xa0 Webots \xa0 and \xa0 Onshape . \n Final project: \n Due June 24, 2020. \n Realize\xa0your Mechatronic project and conclude with a presentation video and pdf report.", 'tags': '', 'url': 'Assignments.html'}, {'title': 'assignment1', 'text': 'Due March 25, 2020 for class 2a and March 26, 2020 for class 2b. \n \n \n Describe how to do an efficient random grouping for this course or do the roll calling randomly? \n \n \n Describe how to prepare a portable Python programming system for Windows 10 64bit system to allow one the maintain CMSiMDE website, Pelican blog and Reveal.js presentation on Github? \n \n \n What do you need to know from \xa0 http://www.coppeliarobotics.com/helpFiles/index.html \xa0 to implement a four-wheeled robot? \n \n \n \n 報告連結: assignment1.pdf \n \n', 'tags': '', 'url': 'assignment1.html'}, {'title': 'Random grouping', 'text': '請描述如何針對該課程進行有效的隨機分組，或者隨機進行點名？ \n 測試程式(點選程式連結再貼上即可): \n \n 抽查的python程式 \n 如果要使用python來進行亂數分組抽查的話，可以導入random來從列表中隨機抽出所需要的n個不同元素，如下面的程式執行之後，就可以亂數抽出4位。 \n import random \n\ngroup = [4, 10, 12, 25, 32, 34, 38, 45, 50] \n\nteam = random.sample(group, 4) \nprint (team) \n 再來是要讀取網頁資料的話，就要導入requests，使用get請求即可直接下載，例如member = requests.get("網址")，再用print(member.text)就可以印出來了如下。 \n import requests\n\nweb = "https://mdecourse.github.io/cd2020/downloads/2b_group_list.txt"\n\nmember = requests.get(web)\n\nprint(member.text) \n 如果使用讀取出的資料，還是無法使用的，因為member.text的性質是str字串，所以我就要將它變回原本的list列表，才可以進行亂數分組，改這個非常的簡單如下。 \n x = eval(member.text) \n 最後我整理出來的程式，雖然沒有老師這麼精美，但是也是可以進行亂數分組的抽查的，如果要改抽查人數，改y = random.sample(i,2)的數字即可。 \n 最終程式碼 \n 程式碼連結: 抽查程式.py \n import requests\nimport random\n  \nweb = "https://mdecourse.github.io/cd2020/downloads/2b_group_list.txt"\nmember = requests.get(web)\n#print(memder.text)\nx=0\nfor i in eval(member.text):\n    y = random.sample(i,2)\n    x+=1\n    print("group"+ str(x))\n    print(y) \n 亂數分組的的python程式 \n 一開始先從網頁上抓人員，這次跟上面的不太一樣，抓出來的本來就是str字串，所以必須把每個學號轉變為 list列表，直接將f.text加上 .split() 來轉換，完成之後就可以使用，random.shuffle()來將整個順序打亂，再來設定一共要分幾組，再使用while迴圈來判斷每一組要有幾個人，使用if判斷是來中斷迴圈，len()是指一共有幾個數量的意思，要加組別的話就要再多寫一列，接著使用for 迴圈來從，剛剛算好的每組人數，例如:13、12、12、12，再使用一個for迴圈，來一個一個配置組人員，這時候直接使用迭代iter()的next()，來抓人員這樣子就不會重複了，最後再加上一些說明、分格、標題，就可以開始進行亂數分組了。 \n 最終程式碼 \n 程式碼連結: 亂數分組.py \n import requests\nimport random\n\nweb = "http://s1.mde.nfu.edu.tw:8000/?semester=1082&courseno=0780"\nf = requests.get(web)\n#print(type(f.text))\nx = f.text.split()\n#print(len(x))\n#print(x)\nrandom.shuffle(x)\n\ngroup1,group2,group3,group4 = 0,0,0,0\nwhile 1==1:\n    group1 += 1\n    if (group1+group2+group3+group4) == len(x):\n        break\n    group2 += 1\n    if (group1+group2+group3+group4) == len(x):\n        break\n    group3 += 1\n    if (group1+group2+group3+group4) == len(x):\n        break\n    group4 += 1\n    if (group1+group2+group3+group4) == len(x):\n        break\n#print(group1,group2,group3,group4)\n\nprint("全班人數有"+str(len(x))+"人")\nprint("="*20)\ngrp_num = group1,group2,group3,group4\na = iter(x)\nteam = 0\nfor i in grp_num:\n    team += 1\n    print("group"+str(team)+" 共 "+str(i)+" 人")\n    for g in range(i):\n        print(next(a))\n    print("-" * 20) \n \n', 'tags': '', 'url': 'Random grouping.html'}, {'title': 'Portable system', 'text': '2.描述如何為Windows 10 64位系統準備一個可移植的Python編程系統，以允許在Github上維護CMSiMDE網站，Pelican博客和Reveal.js演示文稿？ \n 要創造可攜編程系統，首先需要的是start.bat以及stop.bat，放進system資料夾(自行創建)後，然後再創建一個data數據目錄資料夾(一樣放進 system資料夾內 )。 \n \n start.bat 存放在system資料夾下 \n @echo off\nset Disk=y\nsubst %Disk%: "data"\n\n%Disk%:\n\nset HomePath=%Disk%:\\home_mdecourse\nset HomeDrive=%Disk%:\\home_mdecourse\nset Home=%Disk%:\\home_mdecourse\nset USERPROFILE=%Disk%:\\home_mdecourse\n\nREM 將系統 Python 程式的 io 設為 utf-8\nset PYTHONIOENCODING="utf-8"\n\nset PYTHONPATH=%Disk%:\\py382\\DLLs;%Disk%:\\py382\\Lib;%Disk%:\\py382\\Lib\\site-packages;\nset PYTHONHOME=%Disk%:\\py382\n\nset path_python=%Disk%:\\py382;%Disk%:\\py382\\Scripts;\nset path_msys2=%Disk%:\\msys64\\mingw64\\bin;\nset path_tcc=%Disk%:\\tcc;\nset path_git=%Disk%:\\portablegit\\bin;\n\nset GIT_HOME=%Disk%:\\portablegit\\bin\\\nset GIT_SSH=%Disk%:\\putty\\plink.exe\n\npath=%Disk%:;%path_python%;%path_msys2%;%path_tcc%;%path_git%;%path_cmake%;%path_coreutils%;%path%;\n\nstart /MIN cmd.exe\nstart /MIN cmd.exe\nstart /MIN cmd.exe\n\nstart /MIN %Disk%:\\wscite432\\wscite\\SciTE.exe\nstart /MIN %Disk%:\\wscite432\\wscite\\SciTE.exe\n\nExit \n stop.bat\xa0 存放在system資料夾下 \n @echo off\nset Disk=y\npath=%PATH%;\n\ntaskkill /IM python.exe /F\ntaskkill /IM pythonw.exe /F\ntaskkill /IM SciTE.exe /F\nREM 終止虛擬硬碟與目錄的對應\nsubst %Disk%: /D\nREM 關閉 cmd 指令視窗\ntaskkill /IM cmd.exe /F\nEXIT \n \n \n \n data的資料夾內: \n 編輯器，使用 SciTE :   https://www.scintilla.org/SciTEDownload.html \n 下載 Windows 64-bit:   full 64-bit download ，放進 data 目錄裡的 wscite432資料夾(自己創建)，接著 開啟 SciTE.exe ，點選\xa0 Options下的 Open Global Options File \xa0，使用ctrl + f 來收尋code.page=0，將code.page=65001的#刪掉，這樣才不會出現亂碼。 \n code.page=65001\n#code.page=0 \n \n \n Git控制軟體 :   https://git-scm.com/download/win \n 下載Windows 64-bit:  64-bit Git for Windows Setup ，放進 data 目錄裡面並且重新命名為 portablegit 。 \n \n ssh 連線工具組，使用的 putty :\xa0 https://www.chiark.greenend.org.uk/~sgtatham/putty/ \n 直接下載老師之前給的: putty.7z ，解壓縮放入 data 目錄就可以了。 \n \n MSYS2： https://www.msys2.org/\xa0 \n 下載的是 msys2-x86 _64-20190524.exe  ，安裝在  data  目錄裡的 msys64資料夾(自己創建) 。 \n \n Tiny C Compiler :\xa0 https://github.com/TinyCC/tinycc \n 直接在 data  目錄下進行 git clone  https://github.com/TinyCC/tinycc \xa0 tcc\xa0 \n \n 把現在再用的home_mdecourse，整個複製到data 目錄下。 \n \n Python :\xa0 https://www.python.org/ ，下載3.8.2版本的 安裝檔 。 \n 1.完成後開啟，點選 Customize installation(定制安裝)。 \n 2.將第二個選項的pip取消勾選，其他都可以勾選起來。 \n 3.使用預設勾選，將路徑改為data內的py382資料夾(自己創建)。 \n 4.直接在y槽中執行，python\xa0 get-pip.py 來安裝pip軟件。 \n 5.完成之後，來安裝軟件包，輸入python pip install \xa0 Flask \xa0依此類推。 \n 6.安裝的有 Flask 、 Markdown 、 lxml 、 bs4 、 flask_cors 、 pelican 、 leo 。 \n \n data目錄下的所有資料: \n \n system資料夾內: \n \n 這樣子就完成了最簡單的 可攜編程系統了。 \n', 'tags': '', 'url': 'Portable system.html'}, {'title': 'Four wheel car', 'text': '我們從 CoppeliaSim用戶手冊 中尋找有關於四輪機器人的文章，找到了幾個相關的文章，分別是 BubbleRob tutorial 、 Line following BubbleRob tutorial 、 External  controller tutorial 、 Simulation 、 Simulation dialog ， 一共五個有關四輪車的文章。 \n 各篇翻譯:在本站 CoppeliaSim 下，重點及心得如下: \n BubbleRob tutorial :本章教程主要是透過，自己動手實際操作模擬，來了解許多功能以及 BubbleRob  機器人設置，我們上學期時就已經有親自使用 V-rep  來操作過一次了，本章使用了包括 : 基本形狀 ( 機器人本體、輪子、障礙物 ) 、感應器 ( 接近型圓錐傳感器 ) 、接頭或電動機 ( 關節動力馬達 ) 、力傳感器 ( 滑塊 ) 、圖表 ( 運動軌跡 ) 、腳本 ( 模型定義 ) ，使用以上這些功能，就可以實現 BubbleRob  機器人，能移動並且使用感應器，來感應障礙物，再使用腳本來迴避，最後再由圖表來顯示模擬路徑。 \n Line following BubbleRob tutorial :這個教程是接續著上面的文章，可以使 BubbleRob  機器人按照規劃的路徑移動，讓我們可以有效的控制機器人，可以避免外部控制所產生的各種問題，這樣子就可以更快的達成需要的模擬狀況，可以提高不少的效率。 \n External controller tutorial :本章屬於外部控制器的教程，讓我們可以使用遠端操控的方式，來控制四輪機器人，控制的方式有編寫腳本、編寫插件、遠程 API 、 ROS 節點、 BlueZero 節點、編寫外部應用程式，每種都要寫子腳本來進行鏈結。 \n Simulation :此教程為模擬案鍵，當我們建立好腳本時，就可以控制模擬的狀況，為了增加模擬的準確性，就可以使用仿真的速度與螺紋渲染，但是必須要適當的調整，才不會造成系統運行中斷。 \n Simulation dialog :此教程是上篇的進階設定， 時間步 為調整模擬時間，運行越快準確度越差， 每幀模擬遍數 為屏幕刷新速度，刷新越快得到的情報越快，只是電腦很吃效能， 當仿真時間高於時暫停 為允許特定仿真時間暫停， 暫停腳本錯誤 會在發生問題時暫停， 模擬開始時全屏 啟用時對話框和消息不會顯示， 實時仿真-倍增係數 使仿真運行快n倍， 落後時嘗試趕上 系統運行趕不上模擬時，會在低負載時趕上， 復位場景初始狀態 運行模擬結束時，所有設定將回歸初始狀態， 刪除新對象 模擬時，添加的東西將會在結束後移除，以上的各種設定，能讓我們在模擬時，更加的方便，進而提高許多效率。 \n V-rep可動四輪車 \n 使用內建功能來創建模型，並且模擬最基本的直線移動。 \n 影片連結: https://youtu.be/y8DJ1sjuAqM \n \n', 'tags': '', 'url': 'Four wheel car.html'}, {'title': 'assignment2', 'text': "Due April 22, 2020 for class 2a and April 23, 2020 for class 2b. \n \n \n According to the material of Topic 0 and Topic 1, can you describe specifically what the mechanical design team need to do for accomplishing Assignment 1's four wheeled robot. \n \n \n What do you need to know from \xa0 https://cyberbotics.com/doc/guide/index \xa0 to implement a four-wheeled robot? \n \n \n \n 報告連結: assignment2.pdf \n", 'tags': '', 'url': 'assignment2.html'}, {'title': 'DigitalProductCollaboration', 'text': '原文pdf連結: DigitalProductCollaboration.pdf \n 翻譯連結: DigitalProductCollaboration翻譯.pdf \n 協同設計更好的產品 \n \xa0透過設計協調創作更好的產品  -  心態、工具、過程 \xa0 2019 年  7 月  10  日 \n \xa0 \n 現今的數位產品比以往都還要複雜。創建他們需要更多的團隊。每位成員都需要擁有自己的技藝與專業知識。例如 Savvy ，我們的顧客。需要與產品經理、 UX 設計師、視覺設計師、開發人員、內容策略師還有增長專家密切配合。 \n \xa0 \n 我們藉由設計協同來處理這種複雜性。正確的設計協同可以讓每一位專家擁有思維、流程和工具來快速的建立更好的產品。 \n \xa0 \n 我們撰寫這篇資源是為了幫助其他 APP 創作者採用文化偕同和流程。深入閱讀了解為何設計協同對於創作引人注目的產品和體驗來說非常重要 \n \xa0 \n 什麼是設計協同 ? \n \xa0 \n 在直接跳入主題前，我們需要了解什麼是設計協同 … 什麼不是。簡單來說，設計協同就是在以設計為主的環境中進行協同合作。但是，因為設計的本質，特別是在與 Savvy 合作的設計之中，設計協同往往會超出人們一般認為的合作範圍。 \n \xa0 \n 協同一般被定義為兩個或更多的人一起為同樣的目標工作，然而設計協同所涉及的東西卻更多。 \n \xa0 \n 設計協同包羅了更多具有不同技能的人、更艱困的挑戰、更大的目標並產生更深遠的影響 \n \xa0 \n 你可能會認為協同就是兩個人懸掛一件藝術品，只需要溝通、團隊工作、和四隻手而已。設計合作是指由策劃團隊精心為參觀者設計的體驗，他們挑取藝術品並挑選掛在什麼地方、如何掛、掛在哪個房間 ( 以及房間的燈光和家具 )  ，甚至是前一個房間和整棟建築物。 \n \xa0 \n 為什麼設計協同是重要的 ? \n \xa0 \n 你可以在沒有協同的情況下設計出一件產品，但透過一個合作的設計過程可以讓產品變的更加優秀，這就是為什麼設計協同是如此的重要。 \n \xa0 \n 我們並不只是為顧客構建應用程式， Savvy 構建了多平台體驗、複雜的內部系統，並且在某些情況下，還可以構建整個品牌與業務，為此我們在戰略、設計、開發和成長等領域利用核心專業技術，每個項目都有許多人參加，每個人都有自己的技藝與專長。 \n \xa0 \n 設計協同將這些人的思想概念結合在一起，將他們獨自的專業知識結合起來，創造出能夠解決共同目標所有方面問題的方案。設計協同不是從一個角度來解決一個問題，而是將所有問題放在專家面前，迫使他們考慮新的觀點與可能性。 \n \xa0 \n 例如，我們在早期的設計過程就讓開翻人員參予進來，確保盡快解決技術問題與侷限性。這使我們能夠利用在推動技術能力過程時，進一步消除昂貴的路障。這也同時限制一個人在筒倉的工作量，保持工廠的開放性，將重點放在用戶需求與產品目標上。 \n \xa0 \n 培養設計協同的心態 \n \xa0 \n 正確的心態能幫助在設計過程中建立有效的合作關係，它為由誰來合作、如何合作以及合作的目的制定了準則。 \n \xa0 \n 協同是人人都可以的 \n \xa0 \n 設計師有時候會認為不是設計師的人是沒有資格給出好的反饋的。但是，好的設計是不僅僅有視覺效果而已的，它包含了一個產品的一切，從品牌到工程再到在到期發展的一切。 \n \xa0 \n 設計協同引進了許多人，每個人都有其自己的觀點與優勢，它使每個人都可以擁有發言權，這些創新的視角給了設計師更多的信息。觀點可以讓設計師能夠做出正確的決定，這些選擇會對以後的設計、開發與營銷產生持久的引響。 \n \xa0 \n 與客戶的合作和與其他設計師、團隊成員的合作同樣重要。在與 Savvy 的合作中，我們讓客戶參予產品的製作過程，並花時間解釋所選方案，與客戶進行討論，以確保我們了解他們的想法。 \n \xa0 \n 這樣一來，我們就可以確保客戶的買帳並使工作有始有終，較大的揭露並不是什麼太大的驚喜，沒有人會因為第一次看到工作而感到驚訝。 \n \xa0 \n 客戶的合作意味著更早產生一個確定的產品，避免了昂貴的迴避與不必要的會議。 \n \xa0 \n 人們很容易沉浸在自己所扮演的角色中而忽略了大局關，透過讓更多的人在早期參與進來，就能將團隊成員之間的聯繫培養的更緊密，並培養出責任感與對產品是否能成功的興趣。你正在創造一個更開放、更透明的過程，以及一個更有聯繫和投入的團體。 \n \xa0 \n 協同是有背景的 \n \xa0 \n 客戶帶著複雜的挑戰與目標來尋找我們。更別提我們會持續與客戶合作數月甚至數年，累積了大量的知識，包含過去的決策、研究等其他有價值的背景。 \n \xa0 \n 透過適者生存的方法，確保每個人都處於最高的知識水平。使他們能夠在開發產品的過程中能夠做出最明確的決定，為了能夠做到這一點，我們透過提前召集所有團隊成員，紀錄和紀錄會議的內容，建立一些重和點，並將下一個團隊成員視為顧客，讓 Savvy 團隊的每一個人都能及時了解相關資訊。 \n \xa0 \n 在個案合作的基礎上，情境同樣重要，遵循這些準則，在合作中要把情境放在首位。 \n \xa0 \n 在顯示您的工作之前提供上下文。在提供背景信息的情況下，如果您的作品出現在屏幕上，那麼您可能會失去聽眾的注意力。 \n \xa0 \n 描述您要解決的問題或要達到的目標。 \n \xa0 \n 介紹與當前問題相關的工作。說明您的想法以及做出某些決定的原因。 \n \xa0 \n 請具體說明您要反饋的內容。 \n \xa0 \n 合作是開放，誠實和無畏的 \n \xa0 \n 將您的工作（和您自己）放在那裡並不容易。情緒會阻礙您提供坦誠的反饋，尤其是當您擔心會傷害對方的感受時。 \n \xa0 \n 這並不意味著在協作中沒有情感的位置。在設計中，讓您感覺如何是很重要的。我們為人們思考並為他們創建解決方案，有情感並在決策中使用情感的人。在對話中留下的情感可能會縮短潛在的想法或解決方案。充其量，僅就事實和數據進行務實的討論將無法提供全面的信息。在最壞的情況下，它可能是掩人耳目或提供虛假的敘述。 \n \xa0 \n 在與 Savvy 的合作中，我們使我們的團隊對收到反饋感到 “ 無所畏懼 ” 。這意味著放開對我們所創造的東西進行判斷不會感到任何焦慮。這也意味著我們在一起將會更加強大，更有機會創造偉大的事物。在無所畏懼的情況下，我們會更好地相互信任和相互賦予能力，以提供誠實和周到的反饋。 \n \xa0 \n 我們的團隊還信奉無所畏懼地提供反饋。這意味著能夠了解需要解決的問題以及客戶的品牌和目標。同時也意味著可以問很多問題，以發現相關的思想或幫助指導決策。 \n \xa0 \n 嘗試以探索性和指導性的方式提出反饋意見，目的是建立和改進工作，而不是拆散工作。 \n \xa0 \n 您的反饋意見應具有建設性。與其說您不喜歡某些東西，不如說出您的反饋意見以指出您要幫助解決的問題。提供可行的步驟來改進工作，或者至少提供您思考背後的理由。並且不要忘了表達您喜歡什麼以及為什麼。 \n \xa0 \n 合作不僅僅是新的想法 \n \xa0 \n 開放並接受協作反饋是一回事，解析這些想法並將其用來催生您自己的想法是另一回事。隨著時間的推移，這是一項更高級的技能。實踐方法將成為更好的聽眾。 \n \xa0 \n 通常，在與他人交談時，我們會更多地考慮接下來要說的內容，而不是別人在說什麼。這會影響反饋過程，尤其是在設計過程中，因為在聽到其他意見或解決方案之前，我們通常會知道我們要說的話。 \n \xa0 \n 當您選擇先聆聽然後再做出反應時，它可以讓您完全理解其他人的反饋，並讓您更深入地了解自己  —  他們使用的觀點是什麼以及來自何處？很有可能這是您在創建過程中未曾考慮過的觀點。通過聽取並理解收到反饋時背後的上下文和推理，您可以以更多的方式來審視，思考和體驗設計。然後，您可以針對要設計的挑戰，目標和用例來測試這些新觀點，以查看它們是否更適合用戶。 \n \xa0 \n 當所有協作者都在積極聆聽時，更容易接受反饋。最終，提供良好反饋的技能來自於學習如何獲得反饋。當我們努力成為更好的聽眾時，我們也發現自己變得更加謙虛，並認為我們是更好的設計師。 \n \xa0 \n 尋找和使用正確的設計協作工具 \n \xa0 \n 正確的工具在增強團隊的設計協作思維方面大有幫助。在本節中，您將學習在協作工具中尋找什麼。我們還根據自己的經驗推薦工具。 \n \xa0 \n 選擇合適的工具 \n \xa0 \n 有效的協作工具消除了協作者想要快速輕鬆地訪問工作並與之交互時的所有障礙。這將重點放在提供反饋上。它們還允許其他人在不破壞原始設計的情況下進行協作。 \n \xa0 \n 過去，我們依賴於提供基本版本控製而不是真正的協作功能的工具。例如，設計人員將保存一個 Sketch 文件並將其上傳到 Dropbox 。然後，另一個團隊成員下載它，進行處理，然後重新上傳。當文件在另一個人手中時，沒有辦法用簡單的方法來進行更改。我們使用 Github 嘗試了類似的方法，該工具被證明非常適合管理代碼庫，但對於反覆設計的工作卻沒有太多幫助。不用說，這些版本控製過程使我們的協作更加耗時，混亂並且非常不協作。 \n \xa0 \n 現在，我們根據要實現的協作類型從各種更高級的工具中進行選擇。 \n \xa0 \n 設計工具 FIGMA \n \xa0 \n 這是一個以協作為優先的共享工作區工具。  Figma 非常適合在設計文件的同一區域中包含多個人。您可以時時觀看隊友的設計或在同一個設計上一起工作。 \n \xa0 \n Figma的好處： \n \xa0 \n Figma降低了某人在筒倉中工作的能力。 \n \xa0 \n 無需添加不必要的修飾或創建可交付結果的靜態即可實現協作。因此，您無需更改工作流程即可展示設計。 \n \xa0 \n 可以輕鬆地在其本環境中查看並與之交互，並隨意進行調整。 \n \xa0 \n 使用時：流程文檔，高保真線框，即時協作，以及引導客戶瀏覽一系列屏幕，以解釋並獲得有關設計方向的反饋。 \n \xa0 \n MARVEL app 軟體 \n \xa0 \n 雖然 Figma 傾向於自由和靈活，但 Marvel 允許採用更標準化的協作形式。這也使我們的客戶可以輕鬆地與我們合作。 \n \xa0 \n Marvel的好處： \n \xa0 \n Marvel是一個更簡潔、規範和專注的空間，非常適合與非設計團隊成員進行協作。 \n \xa0 \n 它消除了客戶為帳戶付款或對工具進行深入了解的所有需求。 \n \xa0 \n 客戶可以下載屏幕，並通過 Marvel 應用程序在設備環境中查看它們的運行情況。 \n \xa0 \n 使用時：與客戶和開發人員一起呈現更多的最終設計工作。 （了解 Marvel 如何與其他原型工具進行比較。） \n \xa0 \n 其他合作工具 \n \xa0 \n Zeplin是一個有用的傳遞工具，使開發人員可以深入研究設計工作的細節。 （我們在這裡更深入地討論 Zeplin 。） \n \xa0 \n Quip是集思廣益在產品 / 流程文件的絕佳平台。我們使用它來記錄和組織團隊成員在項目上需要了解的所有環境和知識。對於集思廣益新思路而不是視覺關注的新想法也很有用。 \n \xa0 \n 請注意，還有許多其他工具可以為協作增加與上面類似的好處。此列表代表了在我們日常合作中對我們有效的工具，但並不表示所有可能對您的團隊有效的選項。 \n \xa0 \n 精明的設計合作過程在實踐中 \n \xa0 \n 現在，讓我們採用上面概述的最佳實踐和工具，並展示它們如何在現實生活中融合在一起。我們將使用 Press Play 應用程序中的實際繪圖經驗來演示設計協作的重要性。這種經驗涉及多個學科領域的團隊成員之間的重大協作，其中包括視覺設計師， UX 設計人員，開發人員，產品經理，當然還有客戶。 \n \xa0 \n 語境與挑戰 \n \xa0 \n Press Play是一個抽獎活動應用程序，可保存每日，每周和每月的圖紙。用戶通過觀看廣告賺取門票，並通過五個表情符號的選擇來輸入圖紙。然後，根據獲獎者的選擇與繪畫中隨機選擇的表情符號匹配的方式來獎勵獲獎者。這項特殊任務使我們為等待現場繪畫結果的用戶創造了一種有趣而激動人心的現場體驗。 \n \xa0 \n 對於我們來說，為這種體驗創建類似遊戲的動畫非常重要。我們特別想在屏幕上喚起用戶的嬉戲感和期待感，讓用戶看到他們選擇的表情符號與抽獎活動圖上的表情符號相匹配。 \n \xa0 \n 也就是說，我們需要注意動畫所需的複雜程度及其對整體產品時間表和成本的影響。我們的目標是在合理的時間內提高真實度，而又不顯著影響項目預算。 \n \xa0 \n 合作的過程 \n \xa0 \n 階段 1 ：線框和自由討論 \n \xa0 \n 首先，一位精明的 UX 設計師創建了 Press Play 的整體 UX 和線框，確定需要哪些屏幕以及每個屏幕的時間安排。她還為實時繪畫動畫整理了一個粗略的概念，根據客戶的需求和項目已建立的用戶體驗表達了初步的想法。 \n \xa0 \n 她向產品經理和視覺設計師展示了線框和粗糙的動畫。然後這三個人都與客戶會面，因此每個人都可以直接聽到反饋。 \n \xa0 \n 第二階段：研究與背景 \n \xa0 \n 精明的視覺設計師負責創建實際的繪畫動畫，他們的眼睛新鮮，而且對 Press Play 產品沒有太多的了解。為了加快速度，他與 UX 設計師和產品經理進行了深入交流。他還花費額外的研究時間來了解總體產品目標，挑戰並熟悉迄今為止的工作。如前所述，他展示線框演示的一部分，並向客戶提出反饋。 \n \xa0 \n 在這種情況下，他進行了一些與手頭任務直接相關的其他研究。通過這樣做，他確保自己了解現場繪畫體驗的要求、目標和挑戰。他查看了具有類似體驗和真實度的其他應用，並參考了粗糙的動畫以了解最終動畫到底需要顯示什麼（在這種情況下，是獲勝的表情符號和用戶的表情符號選擇）。在過於依賴解決方案之前，他會見了一位精明的 iOS 開發人員，以了解技術限制和注意事項。 \n \xa0 \n 然後，我們的視覺設計師和 UX 設計師集思廣益，視覺效果非常重要。他們一致認為，需要慢慢進行透露，以便為用戶建立懸念 / 期待 \n \xa0 \n 階段 3 ：迭代和反饋 \n \xa0 \n 當我們的視覺設計師沿多個不同方向工作時，他邀請了 UX 設計師來聊聊他在 Figma 中的進度和設計。通過討論工作，他們激發了更多的想法和迭代，同時確保它們符合客戶的期望。有了更多可靠的選擇，他再次與 iOS 開發人員會面，以確保從技術角度來看一切都符合要求。 \n \xa0 \n 階段 4 ：客戶的反饋和發展 \n 當我們找到了幾種最終確定的體驗版本時，視覺設計師使用 Figma 與客戶一起瀏覽了它們。  Press Play 的產品經理和 UX 設計師也提供了反饋和指導。 \n \xa0 \n 一旦他們都了解了會引起客戶興趣的東西，視覺設計師便開始著手讓視覺效果最大化，並為開發做好準備。他繼續與 iOS 開發人員合作，以在技術層面上充分利用該概念。 \n \xa0 \n 最終結果 \n \xa0 \n Press Play的實際繪圖動畫是工作中設計協作的一個示例。一隊跨學科專家團隊，共同解決具有更大影響的設計和開發挑戰。沒有設計協作，我們將找不到用戶體驗，視覺和技術之間的理想交匯處。 \n \xa0 \n 當客戶在他的應用程序中看到動畫是生動時，他稱其為 “ 開創性的 ” 。 \n \xa0 \n 此外，對這種 Press Play 體驗的研究、協作和創造，幫助我們發現了產品用戶旅程中的空白。最初，實際繪圖的目的是將結果顯示給用戶的一種有趣的方式。在設計過程中，我們意識到，如果用戶不因為觀看實際圖形而迷失了方向，那麼他們就不會體驗到該圖形的用戶旅程。 \n \xa0 \n 基於這一發現，我們決定在其他兩個地方也改進該應用程序。我們在 “ 獲勝者圈子 ” 中添加了一個結果 / 實際繪圖元素，並在應用程序的 “ 用戶詳細信息 ” 端添加了 “ 輸贏歷史記錄 ” 部分。最後，設計協作使我們能夠實現用戶體驗中這未滿足的需求。 \n \xa0 \n 結論說明 \n \xa0 \n 它需要設計協調來處理構建出色的產品和體驗所伴隨的複雜並關鍵的問題。通過利用跨學科的多個團隊成員的專業知識，設計協作可確保團隊從各個角度應對挑戰並尋求更好的解決方案。通過正確的思維方式、工具和流程，設計協調能使團隊能夠通過創造性思維和更深入迭代。 \n \xa0 \n 我們希望本指南為您提供一個良好的基礎，您可以以此為基礎建立自己的有效設計協作流程。您可以在 Savvy 博客上了解有關設計和產品策略的更多信息，也可以隨時在 Savvy Apps 網站上與我們聯繫以獲取幫助。 \n', 'tags': '', 'url': 'DigitalProductCollaboration.html'}, {'title': 'EngineeringProductDesign', 'text': "原文pdf連結: IndustrialAndEngineeringProductDesignCollaboration.pdf \n 翻譯連結: IndustrialAndEngineeringProductDesignCollaboration翻譯.pdf \n 產品公司中的工業和工程設計的協作產品設計過程 \n \n 這項研究在闡明工業設計師和工程設計師如何協作，以及這種合作如何體現在設計過程中。我們與來自六個產品製造商的 34 名工業和工程設計師進行了有關實際產品設計項目的深入採訪。我們首先從訪問數據中識別出各個設計過程。其次，我們使用鑲嵌的方法將設計過程進行比較並合併為協作過程。最後，我們簡化了協作流程，以創建具有代表性的流程模型。結果，我們發現了四種類型的典型協同產品設計流程及其特徵： e 類型 1 ：由 ID 主導的概念驅動過程，類型 2 ：由 ID 主導的內外聯合過程，類型 3 ：由 ED 主導的由內到外的流程，類型 4 ： ID ＆ ED 協同流程。 \n \n 工程設計和工業設計的綜合貢獻對於向市場推出成功的產品至關重要。從單學科的角度很難解釋產品設計。但是，眾所周知，工程設計和工業設計在設計實踐上有很大不同 (Pei, 2009; Persson & Wickman, 2004) ，並且它們的設計方法在某些方面是相衝突的 (Eder, 2013; Hosnedl, Srp, & Dvorak, 2008; Pahl, Wallace, & Blessing, 2007) 。工業設計師的角色包括增強產品的用戶體驗並開發其外部樣式和界面 (Ulrich & Eppinger, 2012) 。他們運用美學和人體工程學方面的知識和技能 (Eder, 2013; Pahl et al., 2007) 。在與工業設計師的互動下，工程設計師參加了由工業設計師提出的設計概念的實施 (Persson & Warell, 2003) 。工程設計人員為產品的功能，可靠和製造提供了一種方法 (Hubka & Eder, 2012; Pahl et al., 2007) 。這導致了工業和工程設計師之間的有不同觀點 (Cross, 2008; Hubka & Eder, 2012) 。 \n \xa0 \n 經常有人爭辯說，工程設計師使用 ” 從外觀到功能發展的方式 ” ，而工業設計師則採用 `` 從外觀到功能發展的方式 '(Eder, 2013; Hosnedl et al., 2008; Pahl et al., 2007) 。基於這些概念，提出了以下兩種設計策略：一種是 “ 由內而外 ” 的策略，定義為首先設計內部工件及配件，從而限制外部形狀，另一種是 “ 由外而內 ” 的策略。首先定義外型，然後約束內部零件 (Hubka & Eder, 2012; Kim & Lee, 2010) 。這些設計策略涉及公司應在特定條件下為特定目的而採取的設計過程。但是，從經驗來看的證據中很少了解到這兩種策略如何在工業項目中應用。很少有嘗試從工程設計和工業設計的綜合角度來看待設計過程。在這方面，我們研究了工業環境中兩個學科的協作設計過程。 \n \xa0 \n 研究的問題是 1: 存在哪些類型的協作產品設計流程，以及 2: 什麼條件促使公司採用特定類型的流程。根據這兩個設計師小組的角色和特點，我們假設會有不同類型的由內而外的設計方法。我們認為，由內而外的方法將以工業設計為主導的設計過程為特徵，從而產生工業設計師作為需求和標準提供者的角色，而由內而外的方法將以工程設計為主導的設計過程，工程設計師通過提供對工業設計師職責的初始要求來限制工業設計師的任務範圍。為了在競爭激烈的市場中取得成功，公司應通過適當地採用從內而外的方法來匹配其情況和目標，從而創建工業設計和工程設計的協作流程。 \n \xa0 \n 本文有兩個目標：首先，闡明在實踐中應用的原始協作產品設計過程的形式；其次，確定在不同條件下用於不同目的的不同類型的過程。為此，我們對六家消費產品製造商的工業設計師和工程設計師進行了深入採訪。我們使用 “mosaic method” 確定了每家公司的產品設計流程，其中結合了從訪談數據中提取的各個設計流程以完成協作流程。結果，我們確定了四種典型的協作產品設計流程及其特徵。 \n \xa0 \n 在本文中， “ 協同產品設計 ” 的用語是指通過工業設計和工程設計的共同貢獻而創建的產品設計。特別是在公司環境中，協同產品設計涉及一系列設計活動，例如 : 創建初始產品概念，確定內部規格以及開發外部特徵和內部結構。因此， “ 協同產品設計過程 ” 是指工業設計和工程設計都直接參與產品開發活動的產品設計過程。 \n \xa0 \n 此時的 “ 工業設計 ” 主要涉及開發產品的外形，界面和用戶體驗，但不包括純圖形或純樣式的設計。 \xa0“ 工程設計 ” 開發了用於在產品中放置和操作內部功能部件的技術解決方案，並以能夠實現大規模生產的方式定義了構成產品的內部和外部部件。我們將從事此類活動的工程師標記為 “ 工程設計師 ” 。 \n 本文包括三個部分：第一部分詳細介紹了研究方法。第二部分介紹了典型的協作產品設計過程及其特徵。最後，它總結了結果，並討論了對設計文獻的影響和貢獻。 \n 1. 研究方法 \n 為了研究協作產品設計過程的類型和相關條件，我們在數據收集和分析中採用了紮實的理論方法 (Charmaz, 2006; Glaser & Strauss, 2009) ，以及我們設計用於重新構建協作設計過程的 “ 鑲嵌方法 ” 在工業設計師和工程設計師之間。紮根的理論方法在社會科學中被廣泛用作為研究，較少的領域有建立理論的系統方法，而在設計研究中已被長期採用 (e.g. Lee & Cassidy, 2007; Wong, 2010) 。它使用歸納邏輯，主要是通過深入的訪談和或觀察開始進行數據收集。在編碼階段，通常有兩種策略。一種是從數據中收集有意義的參考資訊並進行編碼，如果研究主題沒有明確定義，則將它們分為編碼類別。另一種是在明確定義研究主題時，使用符合特定主題的預定義編碼類別來標識相關參考。我們使用了後一種策略，因為對設計過程進行了廣泛的研究。 \xa0Berends ， Reymen ， Stultiens 和 Peutz （ 2011 ）採用了類似的方法，對五家公司的設計過程進行了調查。 \xa0Kleinsmann 和 Valkenburg （ 2003 ）收集了有關工業中協同設計過程的事例，並確定了協同設計項目的關鍵主題和過程。 \n \xa0 \n 我們首先對個別設計師進行了深入採訪，並收集了他們關於設計項目的事例。為避免追溯性帳戶的不可靠性或準確性所造成的可能的失真（ Ackroyd ＆ Hughes ， 1981 ），我們採用了三個標準來選擇研究目標：（ 1 ）相似產品領域中的多家公司； \xa0 （ 2 ）工程和工業設計部門的多個參與者； \xa0 （ 3 ）在整個產品開發週期中已經完成的項目。我們設置了第一個標準來提高研究結果的適用性。對項目環境的理解和分析提高了設計過程和方法的適用性（ Gericke ＆ Blessing ， 2012 ）。因此，對具有相似項目環境的多家公司進行調查可能會提供更好的機會來應用研究結果。使用第二個標準，來自具有不同觀點的多個受試者的數據將相互補充，以抵消任何潛在的偏見（ Miller ， Cardinal 和 Glick ， 1997 ）。最後，在回顧性訪談中，可以通過收集和分析整個產品開發週期中已經完成的設計項目的事例來確定設計過程（ Berends 等， 2011 ）。 \n \xa0 \n 為了基於轉錄的訪談數據重建產品設計過程，我們首先確定 “ 過程元素 ” ，然後繪製出各個設計師實踐的部分設計過程。接下來，我們使用 “‘mosaic method” 將每個公司的所有部分流程組合為協同產品設計流程。在構建了所有詳細的協同產品設計流程之後，我們使用 “ 流程塊 ” 對其進行了簡化，以識別典型設計流程的類型。最後，我們將它們可視化為設計過程模型。如下圖 1 顯示了研究過程。 \n 可以根據實際設計項目確定實際設計過程及其相對於上下文的特徵，這可能與公司記錄的設計過程不同。比較兩者將提供洞察力。但是，我們無法收集它們，因為它們被視為對外部機密。取而代之的是，我們詢問受訪者他們的公司是否有書面的標准設計流程，以及它是否與實際設計流程不同。 \n \xa0 \n 1.1 深度訪談 \n 1.1.1 案例公司的選擇 \n 為了增加適用性，應該在公司的環境和背景下理解設計過程（ Maffin ， 1998 ）。因此，我們通過指定案例公司來設置三個標準。所採用的三個標準如下： \n (1）公司應生產中等複雜的電子產品。 \n (2）他們應該有獨立的工業設計和工程設計部門。 \n (3）他們應該是市場上領先的公司，生產精心設計的高質量產品。 \n \xa0 \n 第一個標準使得能夠選擇在產品領域內具有相似性的製造商，其中工業設計師和工程設計者都扮演著重要的角色。生產簡單消費品的製造商在工程設計師中的作用將減少。此外，開發火箭不需要工業設計師。 \xa0Ulrich 和 Eppinger （ 2012 ）指出， “ 中等複雜度的機電產品 ” 要求工業設計師和工程設計人員重要程度相同。根據 Cross （ 2008 ）提出的具有復雜性的工程消費品分類，中等複雜產品的例子包括電鑽和洗衣機。因此，中等複雜的電子消費產品指的是日常消費電子產品，它們是完全集成了電子和機械系統的工程產品（ Vasi c ＆ Lazarevi c ， 2008 ）。儘管滿足第一個條件，但是某些公司（例如原始設備製造商（ OEM ））或小型公司的工業設計或工程設計部門是一個，或者沒有。在這種情況下，他們會使用外部設計或工程諮詢公司。他們的協同過程將不同於內部獨立工業設計和工程部門之間的協同過程。我們傾向於通過探索具有相似背景的案例來提高研究結果的適用性。因此，滿足了第二個標準。最後，生產精心設計和高質量產品的領先公司可以為調查提供合理和適當的數據，研究結果將為其他公司提供很好的參考。 Lawson （ 1994 ）指出，發現良好的設計實踐是如何發生的，將有助於理解和製訂更有效的方法。這是第三個標準的理由。 \n \xa0 \n 我們根據以上標準選擇了案例公司。我們首先將第一和第三項標準應用於從 2006 年至 2010 年連續獲得 “ 韓國優秀設計獎 ” 的公司（關於 GD ， 2011 年）。 \xa0“ 韓國優秀設計獎 ” 在韓國許多市場領先的製造商中很受歡迎。結果，我們獲得了 16 個公司名稱。然後，我們與獲獎公司列表中的聯繫方式聯繫了每家公司，並詢問主管是否具有獨立的 ID 和 ED 部門（第二標準）以及他們是否願意參加研究。最後，我們選擇了六家公司（表 1 ）。 \n 表 1: \n \xa0 \n 1.1.2選擇受訪者 \n 我們選擇了具有目的性和滾雪球式抽樣方法的受訪者（ Berg ， 1988 ）。每個公司的主管都建議他們的設計師，而後者又建議他們的同事。在這樣做的同時，我們選擇了滿足以下三個條件的受訪者： \n （ 1 ）兩年以上公司工作經驗 \n （ 2 ）參與至少一個產品開發過程的周期 \n （ 3 ）與同行的緊密合作和互動（即工業設計，簽名人與工程設計師） \n \xa0 \n 從一家公司的工業設計師和工程設計師團隊招募的預期受訪者人數為 6 名，每名受訪者中有 3 名為了保持平衡。但是，我們只能從 B 公司和 F 公司招募兩名工程設計人員。總共有 18 名工業設計師和 16 名工程設計師作為受訪者參加。他們的工作經驗從 2.1 年到 20 年不等，平均為 8.9 年。 \n 1.1.3 面試程序 \n 根據文獻的建議，我們採用了半結構化深度訪談方法（ Kvale ＆ Brinkmann ， 2009 ； \xa0Seidman ， 2012 ）。我們首先列出了約 20 個詳細問題，並將它們分為四個主要主題： 個人信息 、 設計過程 、 角色和專業知識 、 交互 ，然後提出了四個關鍵問題： \n （ 1 ）您在團隊中的職位和角色是什麼？ \n （ 2 ）產品設計過程如何進行以及在此過程中發生了什麼過程？ \n （ 3 ）您在設計過程中擁有哪些任務，以及哪些知識和常識您執行項目所需的技能？ \n （ 4 ）工業設計和工程設計如何相互作用，在設計過程中互相交流？ \n \xa0 \n 訪談首先是關於受訪者在團隊中的角色和工作經驗的問題，然後是他們經歷的產品開發過程以及在這些過程中的任務。當受訪者由於不願指出要回憶的時刻而猶豫不決時，我們提供了詳細的背景信息，例如： “ 假設今天是您參與的項目的開工會議日，然後告訴我發生了什麼事。 ” 假設，替代，理想和解釋性問題（ Merriam ， 1998 年）。為了限制由多個訪問者引起的不一致，一位作者執行了所有訪問（ Ahmed ， 2007 年）。此外，作者在產品開發方面擁有 14 年的行業經驗，這限制了誤解受訪者描述的綜合設計情況的可能性。為了避免對面試官產生偏見，本研究遵循了 “ Epoche” 過程，該過程將對現象的判斷和假設封閉，以便在參與者的世界中進行檢查（ Leedy ＆ Ormrod ， 2012 年）。因此，面試官在感覺要判斷受訪者的反應時就忽略了對這種現象的判斷。我們在每個公司的會議室中進行了採訪，並對所有對話進行了錄音。為了幫助進行對話並記錄補充信息，我們做了現場說明。有時，受訪者會在便箋上製作圖紙以提供詳細說明。 \n \xa0 \n 從經驗中知道， 90 分鐘適合進行深度訪談，因為受訪人在這段時間內會認真回答採訪，而受訪人在 90 分鐘以上時的回應往往會減少（ Seidman ， 2012 年）。遵循指南，我們計劃的採訪時間為 90 分鐘，但我們沒有控制住它。當我們有足夠的關於問題的數據時，我們通過觀察減少了來自答复的新信息，從而結束了訪談。錄音機中的 “ 語音檢測錄音功能 ” 使我們可以無聲地暫停錄音幾秒鐘，並在聲音返回時恢復錄音。每個受訪者的錄音時間從 70 分鐘到 100 分鐘不等，所有參與者的平均錄音時間為 78.5 分鐘。因此，每個受訪者的實際採訪時間應長於錄音時間。我們逐字記錄了所有採訪數據。結果，我們獲得了大約 1000 頁的全部轉錄。 \n 1.2 確定設計過程 \n 1.2.1 確定每個人經歷的設計過程 \n 儘管所有轉錄數據都包含與設計過程有關的信息，但它們都與其他內容混合在一起，包括項目的情況和目標，個人的角色，必要的技能和知識，參與者之間的衝突，每個對象的感知圖像首先，通過回顧相關文獻來確定用於構建設計過程的 “ 過程元素 ” ，從而製定出一個編碼框架。我們通過仔細閱讀 A 公司的採訪記錄來確認他們。關於過程建模，將過程視為信息處理和狀態轉換系統的兩種觀點為有關過程建模的過程元素的編碼類別提供了有意義的線索。 \n \xa0 \n 從信息處理的角度來看， Browning ， Fricke 和 Negele （ 2006 ）將產品開發及其活動視為信息收集，創建，解釋，轉換和轉移的過程。大多數產品開發活動需要一組輸入，並作為活動的結果，初步輸出，狀態報告等進行生產（ Browning 等， 2006 ）。這種觀點得到了有關設計過程和組織的大量文獻的支持（例如 Burns ＆ Stalker ， 1961; Clark ， 1991; Hubka ＆ Eder ， 2012 ）。 \xa0Ulrich 和 Eppinger （ 2012 ）將其描述為最終結果所必需的信息，該信息被注入以將當前設計問題轉換為下一個問題以降低不確定性，從而產生輸出，直到形成最終結果為止。這被建模為將功能規範（輸入）轉換為製品規範（輸出）的過程（ Takeda ， Veerkamp 和 Yoshikawa ， 1990 ； \xa0Tomiyama 和 Yoshikawa ， 1986 ）。 \xa0Browning 和 Ramasesh （ 2007 ）指出，由於對交互的了解不多，從信息處理的角度進行過程建模無法捕獲完整的信息流。他們認為，確定組織單位之間的相互作用的重要性，因為它們會引起建立可交付的流程模式的活動之間的依賴。最終，從這個角度來看，流程建模的基本元素概括為 信息流 與 IPO （ InputeProcesseOutput ）表示以及組織單位（人員，團隊，公司等）的 “ 互動 ” 。 \n \xa0 \n 從狀態轉換的角度來看， Reymen （ 2001 ）將設計過程描述為通過在每個階段執行任務並評估設計活動將狀態從一種狀態轉移到另一種狀態的過程。這與階段模型一致，在階段模型中，每個階段都會進行設計活動，並在設計評審中評估階段的設計輸出，從而決定是否進行下一階段，重複當前階段或拒絕項目。（ Cagan ＆ Vogel ， 2002 ； \xa0Ulrich ＆ Eppinger ， 2012 ）。大多數基於階段的模型都提倡這種觀點（ Wynn ＆ Clarkson ， 2005 ）。基於階段的模型由旨在執行任務的動作和旨在評估執行任務的結果的決策組成；這項工作的完成構成了下一階段的發展（ J€ansch ＆ Birkhofer ， 2006 ； \xa0Roozenburg ＆ Cross ， 1991 ）。除此之外，當從一個階段跳到另一個階段或在子過程之間鏈接時，伴隨輸入和輸出的信息流就會發生（ Lindemann ， 2003 ； \xa0Ogot 和 Okudan-Kremer ， 2004 ）。 \xa0Pahl 等人提出的工程設計過程模型。 \xa0 （ 2007 ）證明了每個階段的明確投入和成果。第一階段的輸入為 “ 任務 ” ，結果為 “ 規範 ” ，該輸入再次進入下一階段。這樣，繪製出了將輸入和結果連接起來的順序發展階段。關於 “ 任務 ” 和 “ 設計活動 ” ， Pahl 等人。 \xa0 （ 2007 ）使用 “ 任務 ” 來表示項目的初始起點，不同於在每個階段執行的 “ 任務 ” 。但是，這兩個術語的用法類似，用以表示執行設計工作，因此，人們對相互連接和處理任務的設計過程達成了普遍共識（ Dorst ， 2008 年）。 \n \xa0 \n 從狀態轉換的角度來看，有兩個活動：執行任務和評估結果。通常，評估是在相對較短的時間內進行的，以便在 “ 前進，重複或下降 ” 之間做出決定。因此，我們將這些活動（評估，設計審查，門禁檢查，決策）稱為 “ 事件 ” 。目前，我們有兩個編碼類別；總而言之，我們可以用四個編碼類別對設計過程進行建模。 “ 任務 ” ， “ 事件 ” ， “ 信息流 ” 和 “ 互動 ” ，並且可以通過階段的關聯來表示。此時，設計過程的一個階段可以用 “ 輸入任務（設計活動）事件（決策制定）輸出 ” 來表示。以下內容描述如何使用以上四種編碼類別對過程要素進行編碼。 \n 任務：清除設計人員執行的任務，例如 “ 想法草圖 ” ， “ 3D 建模 ” 等。我使用圓珠筆粗略地表達了我的想法。它上的顏色很少，或者掃描後可以在 Photoshop 上進行修飾。 ” 我們將其編碼為帶有 “ 想法草圖 ” 標籤的任務類別。 \n \xa0 \n 事件：完成特定任務後，將進行一個事件（決策），從而導致下一個動作。一位受訪者說； \xa0‘ 我們去樣板公司製作原型，並帶走所有兩個或三個原型。與他們舉行了一次模擬評估會議 \xa0 。工程師們聽老闆的批評。老闆說就是這樣，那就是，如果工程師有不同的想法，他們會提供意見 .. 。最後一個被選中。我們在活動類別中使用 “ 模擬評估會議 ” 標籤對此進行了編碼。 \n \xa0 \n 資訊交流：當任務或事件發生時會生成信息流。它總是伴隨著輸入和輸出。一位受訪者說； \xa0‘ 事實上，我們根據工程設計人員提供的規范進行工作。我們要等到事情來臨時才開始工作。 ” 這表示工業設計師從工程設計師那裡收到了輸入的 “ 規格數據 ” 作為他們開始工作的依據。我們對 “ 從 ED 到 ID 的規範數據 ” 進行了編碼。 \xa0‘ 。選擇一個後，我們會將模型的 3D 數據傳遞到工程部門。我們發送 “ STEP” 文件，然後他們使用 “ UG” 開始設計。 ” 這說明他們向工程設計人員發送了 3D CAD 數據作為其設計活動的輸出，這些輸入成為後續工程設計的輸入。活動。我們對 “ 從 ID 到 ED 的 3D CAD 數據 ” 進行了編碼。 \n \xa0 \n 交互：發生任務或事件時，兩組經常交互。例如，當工業設計師檢查是否可以修改內部空間時，工程設計師通過提供相關信息為他們提供建議。在這種情況下，會發生激烈的互動，而工程設計人員會充當 “ 顧問 ” 的角色。 \xa0‘ 他們解釋說 ‘ 應該放在這裡，應該放在那裡。 ’ 然後，我們修改尺寸和位置，然後再次詢問他們是否可以減小 2 毫米的間隙。如果他們說 “ 是 ” ，我們會將一個部分與另一個部分拼合。 ” 我們將其編碼為 “ ED 到 ID 的顧問角色 ” 。 \n \xa0 \n 我們從每個轉錄的訪談數據中識別出流程要素。我們盡可能用參與者自己的話語標記他們。我們將現場說明用作補充數據源。在此過程中，我們按時間順序排列並連接了編碼元素，以構建部分設計過程。該方法被廣泛採用以可視化行業中的過程模型（ Vergidis ， Tiwari 和＆ Majeed ， 2008 年）。我們還根據訪談數據確定了設計過程中涉及的項目類型和目標。兩名研究人員執行了整個程序。一位研究人員首先構建了部分設計流程，另一位研究人員通過檢查訪談數據對其進行了檢查。結果，我們從每個公司用 7-9 獲得了 45 個局部設計過程（請參見表 2 中的第二行）。 \n 表 2: \n 1.2.2 確定協作產品設計流程 \n 下一步是通過 “mosaic method” 將每個公司的設計過程結合到協作設計過程中。我們首先從公司的特定項目中收集了部分設計過程。之所以容易做到這一點，是因為公司的設計師描述了同一項目中的共享經驗，因此各個局部設計過程相互重疊並相互補充。之後，我們通過比較和合併過程元素來合併部分過程。從工業設計者的訪談數據中提取的部分過程提供了有關工業設計活動的豐富信息，包括與工程設計師的互動行為，但有關純工程設計活動的信息較少。工程設計也是如此。我們將公司中工業設計師的部分流程合併在一起，以圍繞工業設計活動重建設計流程。同時，我們利用工程設計師提供的信息來補充和加強工程設計方面的設計活動流程。我們以相同的方式圍繞工程設計活動重建了設計流程。我們最終將這兩個設計過程合併為一個協作產品設計過程。在鑲嵌方法中，結合交叉檢查的局部過程有利於提高可靠性和通用性。通過抵消彼此的信息，這大大降低了構建信息不完整的流程的可能性。因此， “mosaic method” 降低了構建不准確流程的可能性。 \n \xa0 \n 在比較部分設計過程時，我們發現產品計劃團隊參與了一些設計過程元素。因此，我們包括了它的作用。這意味著產品規劃團隊在工業設計和工程設計的協同設計項目中扮演著一定的角色。我們還標準化了一些表示相同任務或事件的術語。但是，它們的編碼方式不同，因為受訪者使用它們的方式略有不同。例如 : 我們發現一個會議在一個局部設計過程中被編碼為 “ 產品計劃會議 ” ，而在另一個局部設計過程中被編碼為 “ 產品開發會議 ” 。因此，我們將它們統一為 “ 產品計劃會議 ” 。也有人將工業設計結果稱為 “ 模型 ” ， “ 設計模型 ” 或 “ 模型製造 ” 。我們將它們統一為 “ 設計模型 ” 。我們還將 “ 模擬評估事件 ” 和 “ 模擬選擇 ” 標準化為 “ 模擬評估事件 ” 。這項工作是通過對每個公司的面試數據進行交叉檢查，同時評估了評估的意義和環境來完成的。具體條款。實際上，設計師似乎了解每家公司定義了標準術語的文件化設計過程，但並沒有特別意識到這一點。他們似乎忽略了標準化流程，因為市場形勢迫使他們迅速採取行動。語言差異也是造成術語差異的可能原因。在產品設計領域，韓國語中的母語和借來的單詞混合使用。例如，我們同時使用借用詞和用英語表示 “ 設計 ” 的母語。此外，兩支球隊的文化和位置上的差異很可能會導致期限上的差異。除 F 公司外，這兩個部門分別位於不同的物理空間，至少位於不同的樓層。 \n \xa0 \n 最後，我們通過將階段元素（輸入，任務，事件和輸出）合併到一個框中並在其中將它們與相關任務進行命名，來定義設計過程中的階段（參見圖 2 ）。例如，工業設計師開始根據前一階段的研究結果繪製各種構想草圖。然後，他們通過評估選擇一些最佳草圖。根據選擇的結果，他們決定進入下一階段或重複當前階段。因此， “ 想法草圖 ” 階段由 “ 研究結果（輸入）， ” 想法草圖（任務）， “ 評估（事件） ” 和 “ 最佳草圖（輸出） ” 組成。 \n \xa0 \n 圖 2: \n 結果，我們從所有公司獲得了 12 個協同產品設計流程；每個公司一到三個（請參閱表 2 中的第三行）。我們將它們發送給每個公司的受訪者，以檢查我們對其流程的解釋。在此過程中進行了較小的更改。圖 3 顯示了公司 A 的協作產品設計過程。它在兩側顯示了兩個並行的過程：左側是工業設計過程，右側是工程設計過程，中間示出了兩者之間的相互作用。中間的 “ 產品規劃會議 ” 是由 “ 產品規劃小組 ” 主持的活動，由他們決定是否繼續將概念商業化或拒絕。文本框是由輸入任務事件輸出組成的階段。帶有虛線的文本框不是階段。它們沒有所有四個階段的元素。例如， “ 檢查 ” 是一種決定。沒有輸入和輸出。垂直箭頭指示流程的進度。它還顯示了信息流的方向，前一級的輸出變成了下一級的輸入。水平箭頭表示 “ 信息流 ” 或 “ 交互 ” 的方向。圓形箭頭表示各階段中反复且強烈的交互。圖 3 和 5 中的顏色顯示了它們的連通性。稍後將這些分類為階段，並在下一部分中進行說明。 \n 1.2.3 簡化流程 \n 一旦我們制定了每個公司的協作產品設計流程，我們就將它們分類以確定它們的類型，目的和條件。但是，由於每個公司的流程都包含詳細的設計動作和信息，因此直接在公司之間進行比較並不容易。因此，我們通過 “ 流程塊 ” 的概念簡化了每個公司的設計流程，以幫助它們保持可比性，同時又保持基本特徵。 \n \xa0 \n 我們發現在一組小的連續階段中存在一種模式。所有主要階段都完成了一項主要工作。完成後，一個清晰的新階段從另一個工作開始。我們將這些小階段定義為 “ 流程塊 ” 。其特徵在於初始輸入，內部迭代，決策，最終結果和不可逆趨勢（圖 4 ）。流程塊中的內部流程從初始輸入開始，並在內部的各個小階段中運行。迭代或反饋可能在塊內的各個小階段之間發生。最後，他們對最終結果做出最終決定。這是一個里程碑，指示該階段將跳到下一階段。例如，在圖 3 的藍色方框中，此塊的主要工作是開發執行六個小階段的設計概念。當他們處於渲染階段時，如果在渲染評估事件中不滿意渲染結果，則可以返回到構思草圖階段。在最後階段，設計樣機作為結果由高層管理人員確認，然後跳至 “ 產品計劃會議 ” 。 \n \xa0 \n 在前一個結果進入下一個過程塊的輸入之後，兩個過程塊之間的過程流幾乎沒有機會被逆轉。跨團隊通常進行最終設計，並由高層經理在每個工作組中批准。回到上一個區塊意味著它無法滿足市場時間表。因此，應該由最高管理層對此事做出決定。根據訪談數據，他們寧願放棄該項目，也不願返回上一個階段。在大多數基於階段的模型中都對階段之間的迭代和反饋進行了描述（ Wynn ＆ Clarkson ， 2005 ）。但是，在本研究中，將一個過程塊或兩個並行塊視為一個階段，因此在實際情況中很少會發生階段之間的反向迭代或反饋。它發生在一個塊中的各個階段之間。因此，似乎在階段之間幾乎不可能放棄項目，但是在階段之間可以放棄。 \n \xa0 \n 我們通過其主要工作來命名流程塊。在命名這些過程塊時，我們發現 “ 概念設計 ” 一詞在工程設計和工業設計中的用法有所不同。工程設計中的概念設計是與技術概念有關的技術概念，該技術概念通過開發對工作結構和功能的廣泛解決方案來與產品的工作方式相關（ Haik ＆ Shahin ， 2010; Kroll ， Condoor ，＆ Jansson ， 2001; Ullman ， 2009 ）。但是，工業設計師在概念設計階段決定產品樣式和交互作用的方向，這由概念關鍵字，情緒板，想法草圖和用戶場景來表示（ Press ＆ Cooper ， 2003 ； \xa0Tovey ＆ Harris ， 1999 ； Vredenburg ， Isensee ， \xa0Righi 和＆ Design ， 2001 年）。因此，我們標記了這個概念工業設計師的設計活動稱為 “ Concept Design-I” ，而工程設計師的設計活動稱為 “ Concept Design-E” 。 \n \xa0 \n 圖 5 是圖 3 的簡化版本。圖 3 中的彩色框使用圖 5 中的相同彩色框進行了簡化。圖 3 中的藍色框變為 “ 概念設計 -I” 。圖 3 中的 “ 產品計劃會議 ” 為定義為 “ 產品計劃 ” ，並以細長的六邊形可視化。由於它是一個單獨且獨特的設計活動，因此被確定為單個階段。在紅色塊內部，有兩個並行的處理塊；右邊的 “ Concept Design-E” （紅色的小方框）是 “ 主流程塊 ” ，左邊的是 “ 形狀修改 ” （黃色），是 “ 對應的塊 ” 。塊並不能視為單獨的階段，因為它們與大紅色塊內的開始到結束相結合。這樣，兩個設計師團隊之間的互動就很強。為了區分兩個平行的塊，我們用粗實線表示主塊，並用淺實線表示相應的塊。在綠色塊中，由於所有 12 個流程之間的設計活動都沒有什麼區別，因此我們將詳細設計，測試和生產的兩個順序流程塊合併為一個。因此，在本研究中我們將它們視為一個階段。當綠色方框中的設計過程繼續進行時，工業設計師會根據工程設計師的要求或他們自己的設計檢查目的不時做出反應。他們通常將這些活動稱為 “ 後續活動 ” ，與主要任務有所不同。這些活動顯然存在，但不屬於流程塊。它們是如圖 3 所示的離散過程元素，因此用虛線表示。為了幫助視覺理解，實心箭頭，雙向寬箭頭和單個方向寬箭頭分別表示過程流，相互交互和單向交互。 \n 圖 3: \n 圖 4: \n 圖 5: \n 1.2.4 確定協作設計過程的類型 \n 我們根據流程結構，流程塊和階段的輸入和結果的相似性以及工業設計師和工程設計師之間的交互性，對 12 個簡化的協同產品設計流程進行了比較和分類。我們首先將每個流程塊和階段與其他 11 個流程的相應流程塊和階段進行結構比較。然後，我們比較了 12 個流程中每個相應階段的投入和結果。例如，圖 5 中的 “ 概念設計 -I” 階段沒有輸入，但是產生了 “ 設計模型 ” 作為輸出。其他流程中的某些 “ 概念設計 -I” 階段始於工程設計團隊的初步佈局設計。因此，檢查階段的輸入和結果的類型為確定總體流程如何進行提供了線索。最後，我們評估了一個階段中工業設計人員與工程設計人員之間的互動。藍色方框中的兩個組之間沒有交互。但是，在紅色塊中，它們之間存在強大的交互作用。結果，我們將 12 個協作產品設計過程分為四種代表性過程。 \n 2. 協作產品設計過程的類型 \n 我們根據協作產品設計過程的特徵來命名四種類型。它們是類型 1 ：由 ID 主導的概念驅動過程；類型 2 ：由 ID 領導的內外聯合流程；類型 3 ： ED 主導的內部流程；和類型 4 ： ID ＆ ED 協同過程，它們之間的差異主要存在於開發設計概念和初步佈局的過程的早期階段。在詳細設計階段之後，工程設計師的任務占主導地位，這之間存在一些差異。它相當標準化。這表明協作產品設計過程的類型由詳細設計階段之前採用的方法確定。 \n \xa0 \n 兩家公司根據其目標和情況採用了一到三種類型的設計流程（請參見表 3 ）。類型 1 和 4 僅用於新設計，但 C 公司在市場要求在短時間內進行新樣式時採用了類型 1 。當他們有很多參考產品並且交貨時間很短時，就會發生這種情況。  Type 2 用於新設計和重新設計。有趣的是，類型 3 僅用於重新設計。除公司 C （“移動通信產品製造商”）通過服務提供商向市場發布其產品外，大多數流程都用於 B2C 。考慮到 C 公司在與 A 公司和 E 公司不同的情況下使用 Type 1 ，業務類型（ B2B 或 B2C ）將影響設計流程的選擇。 \n \xa0 \n 關於實際設計過程和書面過程之間的區別，大多數人回答說他們已經記錄了所有公司的標准設計過程，但根本沒有遵循。  Ma  ﬃ  n （ 1998 ）的發現支持了這一點，即設計師根據產品開發環境開發了自己的方法。似乎已記錄在案件的流程根據項目類型定義了標準化的任務流和階段，每個部門的任務和角色以及項目時間。但是，他們總是被迫縮短實際項目時間。這種管理壓力很可能導致他們不遵循記錄的流程。 \n \n 表 3: \n 通過比較每種類型過程的使用頻率，我們發現類型 3 是最常用的，而類型 4 是最少的。使用類型 2 的頻率比使用類型 1 的頻率更高。除了公司 B 的情況外，類型 3 與大多數受訪者所說的公司標準最為相似。考慮到重新設計比新設計更頻繁發生的論點（ Roozenburg ＆ Eekels ， 1995 ），成功的徹底創新可能每 5-10 年發生一次（ Norman ＆ Verganti ， 2014 ），這是一個合理的發現。由於類型 4 是個人自發發起的，並且不是一套官方的標準程序，因此這種情況很少見。以下各節介紹了每種類型的設計過程的詳細特徵以及相關的上下文。 \n 2.1 類型 1 ：由 ID 主導的概念驅動的過程 \n 工業設計人員在決定類型 1 初始階段的產品開發方向方面起著主導作用。根據過程塊，它分為四個階段，如圖 6 所示。 \n \xa0 \n 第一階段（概念設計 -I ）：工業設計師獨立開發產品的概念，而不受其他部門的干擾。他們主要關注與美學外觀和用戶體驗有關的方面。他們很少考慮內部零件，這給了他們很多自由。他們為外部和高質量渲染圖像生成 3D CAD 數據以測試該概念。最終確定外觀形式後，他們會生成一個“設計模型”，一個無功能的原型，以驗證該概念。最後，在“設計評估會議”上選擇最佳設計。此階段的最終結果是外形的 3D CAD 數據和設計模型。工程設計師在此階段不採取任何行動。通常，他們甚至不知道工業設計師在設計什麼。 \n \xa0 \n 第二階段（產品計劃）：產品計劃部門決定所選設計的商業化以及目標市場，設計的目標價格和材料成本。最後，他們準備一份產品計劃文件，並確定設計商業化的具體方向。 \n 圖 6: \n \xa0 \n 第三階段（概念設計 -E / 形狀修改）：前一階段的產品規劃文檔和由工業設計師開發的最終 3D CAD 數據是向工程設計師提供的初始輸入。工程設計人員回顧了工業設計人員提出的設計概念的可行性，因為工程設計人員收集了相關技術並在 3D CAD 數據中佈置了內部零件，以測試是否可以將所有必不可少的內部功能零件固定在外部表格中。有時，工程設計人員會生成實驗性原型，以測試是否可以通過預設的外觀形式實現所需的性能。由於工業設計師在定義外觀形式時未考慮內部零件，因此工程設計師在將內部零件佈置在給定的形式中時遇到了麻煩。因此，以某種方式不可避免地要改變外觀。因此， Concept Design-E 有一個相應的過程：工業設計師的“形狀修改”。工業設計師使用從工程設計師那裡收到的佈局數據來修改外觀形式。此時，兩個目標相互碰撞。工業設計人員嘗試保持原始形式，而工程設計人員要求進行修改以確保功能和性能。在這個過程中，發生了非常緊密的交互。結果是有關外部形狀和內部零件佈局的 3D CAD 數據。 \n \xa0 \n 第四階段（詳細設計測試和生產 / 跟進）：從這一階段開始，工程設計師在所有零件中領導該過程。工程設計人員根據上一階段確定的 3D CAD 數據來決定各個零件的幾何形狀和成分結構。由於考慮了批量生產或可靠性測試，他們有時會要求工業設計師對外觀設計進行較小的修改。詳細設計完成後，將生產稱為“工程樣品”的工作原型，以檢查形式和功能。在這一點上，工業設計師要評估其外觀設計符合其設計理念的程度。然後，工程設計師決定供應商，生產模具，並通過多個事件過程測試“生產前原型”，以提高性能的可靠性和產品的耐用性。 \n \xa0 \n 另一方面，在“跟進”中，工業設計師決定如何在產品上應用顏色，圖形，材料和表面修飾，並為工程設計師提供相關規範。對於所生產的每個工作原型，工業設計師都會根據規格測試美學和情感品質。當他們批准時，他們在設計過程中的正式作用就結束了。除非獲得批准，否則工程設計師應再次生產和測試有問題的零件。我們發現所有六個公司都具有這種機制來維持產品的設計質量。 \n \xa0 \n 類型 1 與傳統觀念相反，傳統觀念認為新產品開發過程是通過市場研究或開發新技術來確定市場需求而開始的。它始於純粹的工業設計師的完全自由的概念化。這意味著可以根據工業設計師在腦海中設想的圖片來開發新產品。這與工程設計學科中描述的產品設計過程不一致（例如， Dym ， 1994 年；  Haik ＆ Shahin ， 2010 年；  Pahl 等， 2007 年），在工業設計中，工業設計師在概念設計中的作用缺失。 \n \xa0 \n 考慮到相關的理論，即創造力是在以解決方案為導向的方法（ Wynn ＆ Clarkson ， 2005 ）對問題進行徹底分析之前發生的，例如“主要生成器”（ Darke ， 1979 ）和猜想分析模型（ Hillier ）。 ， Musgrove 和 O'Sullivan ， 1972 年），以及 Lawson （ 2006 年）和 March （ 1984 年）的其他相關發現和觀點，這將是公司在沒有外部影響的情況下，賦予工業設計師自由和自主權來產生創造性解決方案概念的最佳策略。干擾。實際上，類型 1 在兩種情況下被使用：一種是開發形狀和功能都新的概念產品，包括開發新產品類別（如公司 A 和 E 中的產品），另一種是啟動新概念產品。盡快（如公司 C 中）的現有產品。當參考設計豐富時，後一種情況似乎是可能的，因此，工業設計師可以在交貨時間短時確定產品尺寸和外部元素而無需任何產品規格。 \n 2.2 類型 2 ：由 ID 領導的組合內外流程  \n 公司使用此過程來開發新型產品或修改現有產品。在任何一種情況下，與類型 1 不同，產品計劃團隊都將啟動該過程。我們可以分四個階段來解釋類型 2 ，如圖 7 所示。 \n 圖 7: \n 第一階段（產品計劃）：產品計劃小組創建一個產品計劃文檔以啟動產品開發。它設置了目標市場，目標價格和產品規格。在開發現有產品的修改版本時，它會根據現有產品（包括競爭對手的產品）來決定它們。在開發新產品時，工程設計師會幫助他們確定。此階段的結果是產品規劃文檔。 \n \xa0 \n 第二階段（概念設計 -I ）：從產品計劃部門收到產品計劃文件後，工業設計師將決定產品的外觀和相關內部。他們收集符合產品尺寸和規格的待開發產品所需的功能項目，並從對用戶或設計趨勢的研究中得出形式概念。然後，他們安排內部零件以決定外觀形式，同時避免內部零件與預期的外部形式之間發生任何衝突。因此，它們在外形設計和內部零件的佈置之間來回移動。在此階段，工業設計師和工程設計師之間幾乎沒有互動。對於最終事件，設計評估將使用非功能性設計模型進行。因此，此階段的結果是有關產品外觀和初始內部佈局的 3D CAD 數據，以及設計模型。 \n \xa0 \n 第三階段（概念設計 -E / 形狀修改）：從工業設計師那裡獲得 3D CAD 數據後，工程設計師會仔細檢查內部零件與外部形狀相關的可行性和可操作性，並製定最終佈局。工程設計師檢查它們時，經常要求工業設計師修改佈局或外部形式。因此，工業設計活動要進行相應的過程。 “形狀修改”。但是，形狀更改不像 Type1 那樣重要，因為他們在上一階段決定了與內部部件相關的外部形狀。該階段的結果是有關最終外觀形式和內部零件確定佈局的 3D CAD 數據。 \n \xa0 \n 第四階段（詳細設計測試和生產 / 跟進）：該階段與類型 1 並無顯著差異。 \n 類型 2 的顯著特徵是工業設計師在確定第二階段的外形時積極參與佈置功能性組件。儘管工業設計師對內部佈局與外部形狀之間的聯繫的了解較少以工程為重點，但此案例清楚地表明，工業設計師的作用已經超出了我們通常期望的範圍。因此，工業設計師變得很有潛力並且可以主動地進行決策。此外，工程設計師幾乎沒有參與此階段。根據工程設計文獻的建議（例如 Hubka ＆ Eder ， 1987; Pahl et al 。， 2007; Ullman ， 2009 ），我們希望版圖設計將是工程設計人員的專屬工作。我們假設至少工程設計人員會積極為工業設計師提供建議和指導。但是，他們希望數據能夠從工業設計師那裡獲得，並賦予工業設計師自由完成與產品內部結構有關的外部形式的能力。此時，公司的設計第一政策似乎是主要原因。 \n \xa0 \n 2.3 類型 3 ：由 ED 主導的內部第一個過程類型 3 與類型 1 和類型 2 有兩點不同：它們僅用於重新設計現有產品，工程設計人員的工作要先於工業設計人員進行。它要求工程設計師扮演更重要的角色，同時減少工業設計師的角色。我們解釋它們的特徵如下： \n \xa0 \n 第一階段（產品計劃）：如圖 8 所示，產品計劃團隊首先根據年度產品開發路線圖啟動產品開發項目。至此，他們在路線圖中確實具有產品的功能概念。產品規劃專家根據市場上現有的產品確定目標市場，目標價格，產品尺寸和材料成本。工程設計人員經常通過分析競爭對手產品的技術部分並估算材料成本來幫助他們開發產品規格。此階段的結果是產品計劃文件，其中包括產品規格。 \n \xa0 \n 第二階段（概念設計 -E ）：工程設計師根據產品規格快速制定初步佈局。他們通常使用以前開發的產品的數據。完成後，他們將初步佈局作為 3D CAD 數據發送給工業設計師。這是工業設計過程的起點。工業設計人員將其用作開發外觀的輸入，而工程設計人員則尋求系統性能的解決方案並繼續完善佈局。隨著內部佈局和外部形式的同時發展，兩個團隊密切互動並討論任何分歧或衝突之處，並反復交換反饋以進行修改。最終，當設計草圖發展為確定的外觀形式時，初步佈局成為確定的佈局。這個階段的結果是確定設計的最終佈局，從而確定最終產品的尺寸。 \n \xa0 \n 2.5階段（概念設計 -I ）：此過程遠非一個獨立的後續階段，而是第二和第三階段之間的中間階段。因此，我們將其稱為第 2.5 階段。它從收到工程設計人員的初步佈局開始，並與 Concept Design-E 同時進行。工業設計師檢查內部佈局並以匹配的外部形式進行覆蓋。他們進行構想草圖， 3D CAD 建模，渲染，設計評估會議和模型選擇活動，以決定外觀設計。工程設計人員不斷為外觀設計提供建議和評估。因此，外觀設計和佈局通過相互交織的 Concept Design-I 和 Concept Design-E 逐步發展。 \n \xa0 \n 第三階段（詳細設計測試和生產 / 跟進）：該階段與類型 1 和類型 2 沒有明顯不同。 \n \xa0 \n 除公司 B 以外的所有公司都使用此過程。這表明它被最廣泛地使用。受訪者指出，就角色，任務和階段而言，此過程可與公司有關設計過程的正式指導方針相媲美。但是，他們提到實際時間比指南中指定的時間短。 \n 2.4 類型 4 ： ID ＆ ED 協同過程 \n 類型4並非是根據官方提議而發生的，而是各個設計師在早期階段的嘗試。在許多情況下，由於在有限的時間內存在可行性問題，參與開發陣容模型的工程設計師往往會拒絕工業設計師提出的新穎設計概念。為了實施這些概念，工業設計師與自由設計師合作。因此，此過程使繼續拒絕的新穎設計概念成為可能。此外，工業設計師和工程設計師也可以協同工作。與傳統的分離方法不同，它們以集成方式處理設計概念，同時考慮了許多設計變量。此過程的詳細階段如下）： \n 圖 8: \n 第一階段（產生概念）：如圖 9 所示，工業設計師獨立地構思新設計。他們大都是根據僅有創新性但仍未開始進行的設計構想來構建它。 \n 第二階段（概念設計）：此階段始於工業設計師尋找可以與他們合作的工程設計師。當工程設計師同意加入工業設計師以實施設計概念時，他們將在整個階段中緊密合作。工程設計師為工業設計師提供最先進的技術，以增強設計理念。內部佈局的第一層是根據要開發的外部形狀開發的。該階段的結果是有關外觀和內部佈局的 3D CAD 數據。 \n 第三階段（產品計劃）：產品計劃小組通過設計評估會議來決定設計的商業化。然後，產品計劃團隊確定設計的目標市場。從這個階段開始，負責開發陣容模型的工程設計人員就參與其中。 \n 第四階段（詳細設計測試和生產 / 跟進）：該階段的過程與類型 1 、 2 和 3 的過程沒有太大不同。 \n 現有的產品開發環境使工程設計人員趨於保守。消費電子領域的大多數開發項目都是緊迫的。公司通常會在計劃中設定產品發布日。因此，設計人員將按照時間軸執行所有任務和排程。根據訪談數據，參與此類項目的工程設計師傾向於拒絕工業設計師提出的新穎設計概念，因為他們認為自己無法確保使用這些概念的作品能夠在選定的時間通過性能和可靠性測試。測試失敗將直接影響公司的產品開發路線圖以及工程設計師評估時的年度績效。這似乎使他們保守地選擇和評估設計概念。因此，對於直接參與按時間表進入市場的項目的設計人員來說，幾乎無法使用此過程。相反，相對而言，從時間表到市場的時間相對有限的工程設計師，例如那些參與開發面向未來產品的先進技術的工程師，將更願意接受新穎的設計理念。此外，更重要的是，似乎更願意與其他專家合作進行設計的設計師傾向於執行此過程。 \n 對於公司 D ，通過採用此過程，類型 4 在新產品方面取得了巨大的市場成功。但是，在我們的採訪中沒有報告更多將這一過程積極應用於後續項目的案例。儘管如此，有趣的是， D 公司還是從先進技術開發團隊派遣了幾名工程設計師到工業設計團隊的一個相鄰辦事處。這啟用了協同處理案例。最高管理者故意讓他們動用，以使他們迅速為工業設計師提供必要的技術支持，以防止工業設計師提出不切實際的設計概念。這似乎激發了雙方更加親密，從而營造了合作的氣氛。這將增加新興的集成設計流程的可能性。 \n 3. 討論與啟示   3.1 角色變更 \n 工業設計師的貢獻在概念設計階段占主導地位，此後，工程設計師接任其主要角色。這可以視為四種設計過程的一般特徵。除類型 3 外，所有設計過程均始於工業設計師開發的設計概念。對於類型 1 和類型 2 ，工業設計師根據形狀和用途獨立定義設計概念。  Type 4 在概念設計階段是集成的，但從工業設計師的初始設計概念開始。與其他三種類型（第 3 種情況）不同，在這種情況下，對現有產品進行了計劃中的修改，首先是由工程設計師進行佈局設計。看來他們的角色分為概念開發者和概念實現者。有趣的是，當一家公司追求新概念的產品或強調情感感覺和可用性（即使在重新設計案例中）時，工業設計師的作用似乎很重要。這與通過開發新原理和新技術來開發新概念產品的想法不同。他們寧願設計新用途或現有用途的含義。因此，這可以被視為新設計也從現有技術和原理開始的證據。 \n 關於工業設計師的知識，與我們認為很少考慮內部零件的信念相反，他們似乎具有足夠的知識來閱讀和處理內部功能組件並進行外部設計。除類型 1 外，定義外部形狀通常是通過工業設計師考慮並重新佈置內部功能部件來進行的。類型 2 是意外情況。工業設計師通過同時安排相關的內部組件來開發外形。但是，他們在內部零件上的工作可能僅限於直接影響外部形狀的主要零件。儘管他們沒有完全參與設計內部零件的細節，但是很明顯，他們的作用已擴展到工程設計領域。這要歸功於最高管理層對工業設計的大力支持以及兩組之間共享的 CAD 工具。 \n 3.2 選擇設計方法 \n 從理論上講，“由內而外”和“由外而內”的方法是發生的，並且是由工程設計師和工業設計師的不同工作傾向共同造成的（ Hubka ＆ Eder ， 2012 ；  Kim ＆ Lee ， 2010 ）。四種類型的協作設計過程可以看作是這兩種方法的擴展版本。本節討論四種類型與兩種方法之間的關係，以及成功應用每種類型並將其應用於顧問和客戶合作夥伴設置的條件。 \n 對於強調使用環境的消費產品，工業設計師應首先定義與可用性和外觀有關的外觀，然後工程設計師確定與外部鏈接的內部功能部件以支持可用性和外觀。在這種情況下，這是一種由外而內的方法，其中類型 1 適用，類型 2 幾乎適用。如果我們將內向外過程定義為首先確定初步佈局，然後將其用於共同開發隨後的外部形式和確定性佈局，則類型 3 是一種情況。考慮到這兩種方法，類型 4 被視為混合過程，因為外部和內部都同時定義。如果我們將內部到外部的過程定義為在完成內部確定的佈局後決定外部的過程，則此處研究的公司中沒有這樣的過程。它不太適合與消費產品一起使用。它非常適合工業耐用品。例如，如果我們設計一台工業電動機，容量將決定電線的纏繞數和磁芯的尺寸。我們應該科學地計算內部轉子和定子的佈局和尺寸，以獲得最佳性能。因此，必須首先完全確定內部零件，然後將外部形式定義為覆蓋。如果我們根據預設的外部形式開發電機的內部零件，它將無法正常運行。 \n 使用 Type 1 時，工業設計師可以自由提出創新的設計思路。然而，該方法將導致兩個問題。首先，很難獲得工程技術性能。為了獲得最佳性能，內部功能部件可能會與外形衝突。其次，為了解決第一個問題，設計團隊可能會通過在功能和外觀之間進行權衡來折衷原始設計概念。為了成功管理此方法，當折衷方案發生時，高層管理人員必須保持強大的支持以保持設計的創新性。正如我們在 B 公司中觀察到的那樣，類型 2 可以替代這些問題。它的策略是，工業設計師在移動或放置相關內部零件時確定外觀形式。這避免了內部和外部之間的嚴重干擾。然而，有爭議的是，工業設計師是否應在外觀設計開發之外還進行室內佈局設計，以犧牲想像力為代價。他們可能會在自己的知識範圍內折衷創新。要成功應用 Type 2 ，設計師應該對工業設計和工程設計都具有很高的知識。 \n 為了在早期階段獲得高級設計概念的可行性，值得注意的是 Type 4 ，因為工業設計師的概念和工程設計師的技術支持可以開發新產品。鑑於此過程非常有效並且有可能開發創新產品，因此公司需要為其提供適當的使用條件。戴森公司可以成為榜樣。眾所周知，設計師和工程師作為一個部門的成員共享一個工作區，以實現設計的集成實施（ Dyson ＆ Coren ， 1997 ）。為了促進此過程，公司需要有一個集成的團隊，其中兩個小組共享一個工作空間，並按預期吸收每個學科的文化。更為重要的是組織文化，它激發了設計師挑戰性和開放性，可以一起工作。如果設計師擔心公司因失敗而受到懲罰，那麼他們會更加保守。沒有這種情況的改變，類型 4 甚至作為公司中有據可查的流程都將無法有效地發揮作用。 \n 在行業中，許多工程公司與外部工業設計師合作。儘管我們沒有調查這種類型的協作，但是，根據我們的發現對可能的流程方案進行討論將是有益的。當製造商與設計諮詢公司合作時，他們可以得到補充支持，以按時完成項目或產生新的想法（ Bruce ＆ Morris ， 1994 ）。在顧問和客戶合作關係中，有兩種過程耦合方式：被動耦合，其中顧問在與客戶聯繫以獲取更多信息或查看其結果時獨立開發解決方案，以及主動耦合，其中顧問和客戶設計師的協作團隊密切合作生成解決方案（ Gericke ＆ Maier ， 2011 年）。在被動耦合中，由於外部設計師獨立工作，其設計過程將類似於類型 1 或類型 2 。當客戶希望利用他們缺少的特定專業來收集盡可能多的創意時，類型 1 將非常有用。當客戶公司高度以技術為導向並且有足夠的能力在強大的工程支持下實施好的概念時，這種情況將很有幫助。如果客戶的能力比上述情況要小，並且在初期需要聘請外部工業設計師來領導其產品開發，則類型 2 將是合適的。主動耦合模式將具有與類型 3 和類型 4 相似的過程。當客戶已經具有良好的設計方向和相關技術，並且想要改善產品的美學外觀時，類型 3 將是合適的。除非客戶和顧問公司的整合團隊在項目期間在同一空間工作，否則第 4 類將是不可能的。在顧問和客戶合作夥伴的協作設計過程中應該考慮其他因素。在許多情況下，客戶為顧問提供的信息在一定程度上受到限制。因此，在顧問和客戶合作夥伴以及公司內部發生的相同類型的協作過程在內容方面將是不同的。儘管如此，我們的研究結果和討論仍可為在消費電子領域選擇更好的設計方法提供線索。 \n 3.3 設計過程類型的含義 \n 工業設計師和工程設計師在設計方法和關於產品開發的觀點上是不同的（ Eder ， 2013 ；  Pahl 等， 2007 ；  Ulrich ＆ Eppinger ， 2012 ）。工業設計師產生以用戶為中心的解決方案概念，工程設計師根據技術角度解決設計問題。這兩個群體的專業所面臨的過程可能是開發具有競爭力的創新產品的基礎。此外，系統工程設計和以用戶為中心的設計思想的耦合過程對於在顧問與客戶之間的關係中生成以用戶為中心的解決方案是有益的（ Gericke ＆ Maier ， 2011 ）。耦合過程是公司採取並實現市場競爭力的最佳選擇。例如，消費電子公司使用四種類型的協作設計過程來實現其市場目標。工業設計師在這四種類型的早期階段中的作用是顯而易見的，採用工業設計師專業的方式是採用適當類型的協作設計過程的重要因素。通過給予類型 1 中的工業設計師自由，可以增加獲得創新設計概念的可能性。那麼，這種自由如何驅動工業設計師創建創新設計概念呢？實際上，建築和工業設計師首先從解決方案的圖像入手，然後通過重複試驗最終確定（ Lawson ， 2006 ；  Roozenburg ＆ Cross ， 1991 ）。這與一個模型有關，在該模型中，設計人員首先基於預設進行推測，然後進行分析（ Hillier 等， 1972 ）。這意味著工業設計師依靠對未來的展望來創造創新的概念，而不是對市場和客戶進行深入的設計研究。  Press and Cooper （ 2003 ）補充說，工業設計方法是價值驅動的。因此，類型 1 的工業設計師可以不受約束，可以通過設想所需的未來產生創意。 \n Norman 和 Verganti （ 2014 ）認為，創新產品開發是通過技術或含義的改變進行的，而不是以人為中心的認真的設計研究。他們補充說，以人為本的設計方法更適合於現有產品的逐步改進 \n 產品。在消費電子領域當前的產品開發環境中，產品規劃專家在市場和客戶研究中起著關鍵作用。因此，產品規劃團隊對工業設計師的投入將僅限於他們的創造力。這解釋了為什麼公司以相反的方式使用 Type 1 ；首先開發概念，然後再定義市場，而不是相反。通常，在產品設計概念中，設計師會考慮與技術高度相關的功能概念，以及會給用戶帶來新含義的樣式概念（ Baxter ， 1995 年）。因此，由於功能和 / 或樣式概念，工業設計師提出的設計概念應該是創新的。當涉及到技術時，工程設計師應開發新技術或尋找適當的技術來實施該概念。如果在產品開發計劃階段沒有被拒絕，這種類型的過程會導致新技術的開發。 \n 在類型 2 中，公司對工業設計師承擔各種角色和職責。由於工程設計師不會打擾他們，所以他們可能有一定的自由度。工業設計師的方法是面向解決方案的。他們通常不遵循系統的過程。他們寧願提出新的想法並重複他們。但是，類型 2 可能通過強加他們在內部佈局設計和外部設計中扮演的另一角色而中斷了工業設計師的方法。工業設計師採用面向問題和系統的方法，將最終限制他們在概念開發中的想像力。在考慮其設計概念的可行性時，這將使它們更加現實。因此，類型 2 的設計結果將不如類型 1 的創新。否則，類型 2 將比新設計更適合重新設計。如果工業設計師不考慮將 Type 2 的內部零件進行重新設計，則他們可能會面臨困難，設計概念可能會被拒絕（ Kim ＆ Lee ， 2014 ）。 \n \xa0如果我們考慮將類型 2 和類型 3 用於重新設計，那麼類型 2 何時比類型 3 更好？類型 3 的特性符合工程設計中顯示的大多數設計過程。工業設計被認為是工程設計領域中的事後想法（例如 Andreasen ＆ Hein ， 2000 ；  Hubka ＆ Eder ， 1987 ；  Pahl 等， 2007 ）。按照他們的觀點，工業設計的功能與產品外觀的各個方面有關，例如確定產品的技術特徵後的樣式，形式和顏色。第 3 類是工程設計師為設計概念提供技術解決方案的過程。他們要求工業設計師開發外觀。因此，類型 3 僅使用工業設計師的部分專業知識來創造美學外觀。從這個角度來看，類型 2 比類型 3 可以為工業設計師提供更多的方法來展示其專業知識。考慮到類型 3 是最常用的過程，因此在過程管理方面可以更有效。類型 3 早期階段的不確定性可能是四種類型中最小的。的大多數技術解決方案設計概念是由工程設計師在早期階段設定的，而工業設計師只限於創造美學外觀。 \n 我們找不到的一個過程是類型 5 ： ED 主導的技術驅動過程。這可以與類型 1 ：由 ID 主導的概念驅動過程形成對比。在類型 5 中，工程設計人員將首先開發一項新技術而無需考慮產品開發計劃，並使用測試原型來測試其性能。接下來，工業設計師為該技術產生新的產品設計概念。然後，可視化的設計概念和原型可用於決定產品開發。應用類型 5 ，公司可以創建新類別的產品，從而增加打開新市場的可能性。我們無法找到這種類型的原因之一是創新技術開發的稀缺性，以及新技術滿足新概念的難得機會。另外，在決定產品開發之前，公司不太可能等不確定的工程設計師和工業設計師。為了使此過程更好，我們需要工程設計師開發新技術，需要工業設計師使用相互合作的技術創建新概念。根據這一論點，類型 4 在正式用於創新產品設計時會很有用。它還可以使工程設計師開發的技術與工業設計師提出的新概念集成在一起。  4.結論 \n 我們旨在確定協作設計過程類型的存在以及在公司中採用特定類型的條件。我們根據工業設計師和工程設計師的深入訪談數據建立了協作設計流程。結果，我們發現了四種類型的協作設計過程。根據設計過程早期階段的不同對它們進行分類。四種類型的過程在不同的上下文中用於不同的目的。有時，它們會被戰略性地用於開發新設計或重新設計，有時它們會由於內部和外部因素而有機地應用。我們還發現，工業設計師的作用是有影響力的，而且是擴展的。 \n 設計過程模型的抽象特徵和研究中的一門學科方法與實際實踐並不完全匹配，並且被確定為造成這種問題情況的原因（ Brooks Jr ， 2010 ；  Eckert ＆ Clarkson ， 2005 ）。在這方面，有人要求結合不同的設計過程模型（ Albers ， 2010 ；  Dorst ， 2008 ）。四種類型的過程是工業設計師驅動的以解決方案為導向的方法和工程設計師以問題為導向的方法的組合過程。它們表明，即使在單個領域（即消費類電子產品）中，實際的設計過程也無法用單個模型來表示。為了提高設計過程的適用性並在設計實踐中獲得設計方法的適當支持，需要考慮公司和項目具體環境的更為具體的過程模型（ Finkelstein ＆ Finkelstein ， 1983 ；  Gericke ＆ Blessing ， 2011 ）。我們特別專注於消費電子領域，在這一領域中，工業設計師和工程設計師在產品開發中起著重要的合作作用。我們發現了四種類型的設計過程，並確定了它們的目的和背景。因此，我們發現的有關上下文的詳細信息將為公司計劃針對新產品開發的有效設計過程管理提供有用的信息，尤其是在消費電子領域。 \n 根據研究方法，我們展示瞭如何從設計師的深入訪談數據中建立協作設計過程。我們確定了過程元素，並使用它們構造了部分過程，並使用鑲嵌方法建立了詳細的協作設計過程。我們還引入了“過程塊”，並定義了一個或兩個交互塊作為一個階段。我們認為這種方法有利於確定最佳水平的實際設計過程。我們認為該方法適用於發現其他設計過程。我們的過程模型的形式可與其他基於階段的模型相比較（例如 French ， 1998 ；  Pahl 等， 2007 ）。我們從模型中發現，在階段之間很少發生反向迭代或反饋。這與現有的基於階段的工程設計過程模型的描述不同。在理想情況下，我們認為雙向迭代是可能的，但是實際上由於激烈的市場競爭，我們認為這種情況很少發生。 \n 特別是針對其他產品領域中的其他項目案例，需要對該方法進行進一步的研究。本研究中的公司均為電子產品製造商。因此，結果僅限於此產品類別。我們需要測試這四個協作設計過程如何在其他公司中應用。相反，值得研究創新產品開發和應用過程的案例。 \n \xa0 \n", 'tags': '', 'url': 'EngineeringProductDesign.html'}, {'title': 'MechanicalDesignProcess', 'text': '原文pdf連結:  MechanicalDesignProcess.pdf \n 翻譯連結:\xa0 MechanicalDesignProcess翻譯.pdf \n', 'tags': '', 'url': 'MechanicalDesignProcess.html'}, {'title': 'Keyboard control car', 'text': "V-rep 馬達驅動四輪車 \n V-rep 檔案連結:\xa0 4 wheel car.ttt \n 剛開始可以使用內建的功能來創建模型，Add > Primitive shape > Cuboid(需要的 形狀)，給定所需形狀的參數值即可，創建出一個正方形本體，還有四個圓柱形輪子， 移動到相對應的位置，再來加上馬達 Add > Joint > Revolute，分別定位在四個輪 子的軸上，雙擊Revolute_joint圖示，在彈出的屬性框點擊Show dynamic parameters dialog，勾選 Motor enable，並設置 Target velocity 為 10，四個馬達都是如此。\xa0 \n 影片連結: https://youtu.be/y8DJ1sjuAqM \n \n \n 四輪車鍵盤控制轉向 \n V-rep 檔案連結:\xa0 4 wheel car keyboard.ttt \n 四輪車加上轉向及鍵盤控制，先開啟之前做好的四輪車，將兩個前輪馬達複製貼上，再使兩個馬達原地轉向90度，創建兩個小正方體，位置與前輪一模一樣， 需要設定屬性避免與其他部件衝突，本體、輪子、小正方體都要關閉如下圖。 \n 將控制迴路啟用，來控制轉向的限制角度，兩個馬達都用預設即可，如下圖設定。 \n 將之前的馬達速度都關掉， 點擊馬達圖示視窗下的 show dynamic properties dialog ，把 motor properties的速度改為0 ，底下的 lock motor when target velocity is zero是 馬達速度為零時鎖定馬達，可開可不開。 \n \n 最後把方塊拖移至對應馬達下，再整個放進本體下，把對應的前輪馬達放置方塊下，本體新增一個控制腳本，選擇cuboid，點擊菜單欄的Add > Associated child script > Threaded，將寫好的腳本複製貼上，更改前輪馬達的名子，這樣腳本才能控制，下圖為整個最終結構。 \n 四輪車鍵盤控制轉向程式碼: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n \n \n \n -- This script is threaded! It is a very simple example of how Ackermann steering can be handled. \n -- Normally, one would use a non-threaded script for that \n \xa0 \n threadFunction= function () \n \xa0\xa0\xa0\xa0 while   simGetSimulationState()~=sim_simulation_advancing_abouttostop  do \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- Read the keyboard messages (make sure the focus is on the main window, scene view): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 message,auxiliaryData=simGetSimulatorMessage() \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 while   message~=-1  do \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (message==sim_message_keypress)  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[1]==2007)  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- up key \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 desiredWheelRotSpeed=desiredWheelRotSpeed+wheelRotSpeedDx \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[1]==2008)  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- down key \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 desiredWheelRotSpeed=desiredWheelRotSpeed-wheelRotSpeedDx \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[1]==2009)  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- left key \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 desiredSteeringAngle=desiredSteeringAngle+steeringAngleDx \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (desiredSteeringAngle>45* math.pi /180)  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 desiredSteeringAngle=45* math.pi /180 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[1]==2010)  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- right key \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 desiredSteeringAngle=desiredSteeringAngle-steeringAngleDx \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (desiredSteeringAngle<-45* math.pi /180)  then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 desiredSteeringAngle=-45* math.pi /180 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 message,auxiliaryData=simGetSimulatorMessage() \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- We handle the front left and right wheel steerings (Ackermann steering): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 steeringAngleLeft= math.atan (l/(-d+l/ math.tan (desiredSteeringAngle))) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 steeringAngleRight= math.atan (l/(d+l/ math.tan (desiredSteeringAngle))) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 simSetJointTargetPosition(steeringLeft,steeringAngleLeft) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 simSetJointTargetPosition(steeringRight,steeringAngleRight) \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- We take care of setting the desired wheel rotation speed: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 simSetJointTargetVelocity(motorLeft,desiredWheelRotSpeed) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 simSetJointTargetVelocity(motorRight,desiredWheelRotSpeed) \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 -- Since this script is threaded, don't waste time here: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 simSwitchThread()  -- Resume the script at next simulation loop start \n \xa0\xa0\xa0\xa0 end \n end \n \xa0 \n -- Put some initialization code here: \n -- Retrieving of some handles and setting of some initial values: \n steeringLeft=simGetObjectHandle( 'Steer_left_joint' ) \n steeringRight=simGetObjectHandle( 'Steer_right_joint' ) \n motorLeft=simGetObjectHandle( 'Front_left_joint' ) \n motorRight=simGetObjectHandle( 'Front_right_joint' ) \n desiredSteeringAngle=0 \n desiredWheelRotSpeed=0 \n steeringAngleDx=2* math.pi /180 \n wheelRotSpeedDx=20* math.pi /180 \n d=0.755  -- 2*d=distance between left and right wheels \n l=2.5772  -- l=distance between front and read wheels \n \xa0 \n -- Here we execute the regular thread code: \n res,err= xpcall (threadFunction, function (err)  return   debug.traceback (err)  end ) \n if   not   res  then \n \xa0\xa0\xa0\xa0 simAddStatusbarMessage( 'Lua runtime error: ' ..err) \n end \n \xa0 \n -- Put some clean-up code here: \n \n \n \n \n \n \n \n 教學影片連結: https://youtu.be/0W1wmC1tr4A \n \n", 'tags': '', 'url': 'Keyboard control car.html'}, {'title': 'assignment3', 'text': 'Due\xa0May 27, 2020\xa0for class 2a and\xa0May 28, 2020\xa0for class 2b. \n According to the reading of Topic 2 and Topic 3, propose a Mechatronic project by using \xa0 CoppeliaSim \xa0 or \xa0 Webots \xa0 and \xa0 Onshape . \n \n', 'tags': '', 'url': 'assignment3.html'}, {'title': 'MechatronicDesignCases', 'text': '原文pdf連結: MechatronicDesignCases.pdf \n 翻譯連結: MechatronicDesignCases翻譯.pdf \n Ch11 實例探究 \n \n 11.1 介紹 \n 在前面的章節中，我們提出了一些概念，並通過學術示例說明了它們的應用，以向讀者展示這些結果如何應用。更具體地說，我們已經了解瞭如何設計機電一體化系統。介紹了成功完成所需機電系統設計所必須遵循的不同步驟。我們已經介紹了在以下設計中必須使用的方法： \n •\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0機械部分 \n •\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0電子電路 \n •\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0C語言中用於實時執行的程序 \n \xa0 這些工具已應用於一些實際系統，並提供了更多詳細信息以幫助讀者執行自己的設計。 \n \xa0 對於控制算法，我們提供的大多數示例都是具有理想模型的學術模型。不幸的是，對於一個實際的系統，我們將擁有的模型只是一個可以在某些特定條件下描述該系統的實現，並且由於某些原因，該模型無法在算法的實時實現過程中按預期方式完美運行。這可能是由於不同的動態動力學可能導致某些頻率的行為改變而引起的。 \n \xa0 本章的目的是向讀者展示我們如何實時實現前面幾章中針對實際系統開發的理論結果。我們將逐步進行並顯示所有步驟，以使讀者輕鬆閱讀。我們在本章中考慮的案例研究是在前幾章中討論和設計的案例研究。 \n \n 11.2\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0速度 直流電機套件的控制 \n 作為第一個例子，讓我們考慮驅動機械零件的直流電動機的速度控制。該示例的選擇非常重要，因為大多數係統將使用此類直流電動機。我們將考慮的直流電動機由Maxon公司製造。該電動機非常重要，因為它帶有齒輪箱（比率6：1）和編碼器，該編碼器每轉給出一百個脈衝，我們每轉產生600個脈衝，我們通過使用正交方法將其變為24400個脈衝。每轉。如果在本示例中使用的系統具有更靈活和更多的優勢，則可以在前面介紹的控制算法的實時實現中使用。 \n \xa0 該電動機的數據表給出了所有重要參數，因此容易獲得該執行器的傳遞函數。在此示例中，我們正在考慮的負載是一個帶有刻度的小磁盤，我們希望在速度上控制它，然後在位置上進行控制。這種設置在 圖11.1 和11. 2 中示出。我們正在考慮的圓盤的直徑等於0.06 m、質量等於0.050 Kg。利用這些數據和直流電動機的數據表之一，我們可以獲得磁盤速度和輸入電壓之間的傳遞函數。 \n \xa0 首先讓我們專注於負載的速度控制。在這種情況下，為了建立該系統的傳遞函數（直流電動機執行器及其負載），我們可以使用數據表，磁盤上的信息以及Boukas[1]中的結果。 \n \n 圖11.1 \xa0直流電動機套件的電子電路 \n \n 或繼續進行識別。使用第一種方法，[1]中第2章的結果是: \n \n 和 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 K \xa0= 48.91\xa0 \xa0 \xa0 \xa0 \xa0 τ = 63.921毫秒 \n \xa0 為了設計控制器，我們首先應該指定我們希望系統具有的性能。首先，我們需要係統穩定，還需要係統速度在過渡狀態下具有良好的性能，在穩態狀態下具有零誤差，以作為階躍參考。對於瞬態，我們希望負載的穩定時間小於或等於3τ/5的5％，而過衝則小於或等於5％。 \n \xa0 為了完成適當控制器的設計，我們既可以連續進行設計，然後獲得應在軟件部分進行編程的算法，也可以直接在離散時間內進行所有設計。在本示例的其餘部分中，我們將選擇第二種方法。 \n \n 圖11.2 \xa0實時實施設置 \n \n \xa0 根據系統傳遞函數的表達式以及所需的性能，結果表明我們至少需要一個比例積分器（PI）控制器。該控制器的傳遞函數由下式給出： \n \n 其中KP和KI是要確定的結果，以迫使負載具有我們施加的性能。 \n \xa0 使用零序持有者和Z-transform表，我們得到： \n \n \xa0 對於控制器，使用梯形離散化，我們得到： \n \n \xa0 將分子和分母除以z並回到時間，我們得到： \n \n \xa0 結合執行器及其負載和控制器之一的傳遞函數，我們得到以下閉環傳遞函數： \n \n \xa0 現在使用期望的性能，很容易得出結論，主導根點是: \n \n 其中ζ和ωn分別代表我們系統控制閉環的阻尼比和固有頻率。 \n \xa0 根據控制理論（請參見Boukas [1]），眾所周知，過衝d％和5％的建立時間ts由下式給出： \n \n 使用我們的性能和這些表示，我們得出以下結論: \n \n 它具有以下主要優勢： \n \n 且T =τ/10= 0.0064的變換，我們得到以下結果 域中的主要根點： \n \n \xa0 對於這些根點，我們具有以下特徵方程式： \n \n \xa0 現在使用根點放置技術，我們得到： \n \n 這意味著： \n \n 使用K，T和τ的值，我們得到增益KP和KI的以下表達式： \n \n 備註11.2.1 \xa0 在這種情況下，必須謹慎，因為我們不在乎傳遞函數零的位置，因此在實現此控制器時可能會有些意外。顯然，我們將獲得的性能（穩定時間和過衝）將取決於零的位置。有關此問題的更多詳細信息，請向讀者介紹Boukas[1]。 \n \xa0 至現在實施該PI控制算法，並確保達到理想的性能，我們將使用Microship1的微控制器。這種選擇是由於我們在此類微控制器方面的經驗所致。讀者可以記住，其他製造商的任何其他微控制器都可以做些小改動。在本示例中，我們將使用Microhip的單片機dsPIC30F4011。 \n \xa0 我們實現的代碼使用C語言編寫。採用這種語言是因為其簡單性。該實現具有以下結構： \n //\n// Put here the include\n//\n\n#include "p30F4011.h"\t// proc specific header\n\n//\n// Define a struct\n//\ntypedef struct {\n// PI Gains\nfloat K_P; // Propotional gain\nfloat K_I; // Integral gain\n//\n// PI Constants\n//\nfloat Const1_pid; // KP + T KI/2\nfloat Const2_pid; // -KP + T KI/2\nfloat Reference; // speed reference\n\n//\n// System variables\n//\nfloat y_k; // y_m[k] -> measured output at time k\nfloat u_k; // u[k] -> output at time k\nfloat e_k; // e[k] -> error at time k\n\n//\n// System past variables\n//\nfloat u_prec; // u[k-1] -> output at time k-1\nfloat e_prec; // e[k-1] -> error at time k-1\n\n}PIStruct;\n\nPIStruct thePI;\n\nthePI.Const1= thePI.K_P+T*thePI.K_I/2;\nthePI.Const2=-thePI.K_P+T*thePI.K_I/2;\nthePI.Reference=600;\n\n//\n// Functions\n//\nfloat ReadSpeed(void);\n\nfloat ComputeControl(void);\n\nfloat SendControl(void);\n\n//\n// Interrupt program here using Timer 1 (overflow of counter Timer 1)\n//\nvoid __ISR _T1Interrupt(void) // interrupt routine code\n{\n// Interrupt Service Routine code goes here\nfloat Position_error;\n\n//\n// Read speed\n//\nthePI.y_m=ReadSpeed();\n\nthePI.e_k= thePI.Reference-thePI.y_m;\n\n//\n// Compute the control\n//\nComputeContrl();\n\n//\n// Send control\n//\nSendControl();\n\nIFS0bits.T1IF=0; // Disable the interrupt\n}\nint main ( void ) // start of main application code\n{\n// Application code goes here\nint i;\n\n// Initialize the variables Reference and ThePID.y_m (it can be read\nfrom inputs) Reference = 0x8000; // Hexadecimal number\n(0b... Binary number) ThePID = 0x8000;\n\n// Initialize the registers\nTRISC=0x9fff; // RC13 and RC14 (pins 15 and 16) are configured as outputs\nIEC0bits.T1IE=1; // Enable the interrupt on Timer 1\n\n// Indefinite loop\nwhile (1)\n{\n}\nreturn 0\n}\n\n% ReadSpeed function\nint ReadSpeed (void)\n{\n}\n\n% ComputeControl function\nint ComputeControl (void)\n{\nthePI.u_k=thePI.u_prec+thePI.Const1*thePI.e_k+thePI.Const2*thePI.e_prec;\n}\n\n% SendControl function\nint Send Control (void)\n{\nsendControl()\n\n//\n// Update past data\n//\nthePI.u_prec=thePI.u_k;\nThePI.e_prec=thePI.e_k;\n}\n \n \n \xa0 從該結構可以看出，首先我們注意到系統將進入循環，並在每次中斷時調用函數： \n •\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0ReadSpeed; \n •\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0ComputeControl; \n •\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0SendControl; \n 並採取適當的措施。 \n \xa0 ReadSpeed函數在每個採樣時間返回加載速度，該速度將由ComputeControl函數使用。SendControl功能通過L293D芯片將適當的電壓發送到執行器。 \n \xa0 使用編譯器HighTec C獲取十六進制代碼，並使用PicKit-2將文件上傳到微控制器的內存中。 有關如何獲取十六進制代碼的更多詳細信息，我們邀請讀者閱讀編譯器HighTec C或Microchip的編譯器C30的手冊。 \n \xa0 在這種情況下，國家方法是微不足道的，我們將不發展它。 \n \n 11.3\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0直流電機套件的位置控制 \n 讓我們專注於負載位置控制。遵循與上一節中開發的負載速度控制類似的步驟，我們首先需要選擇我們希望系統具有的理想性能。進行以下展示： \n •\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0系統穩定在閉環狀態； \n •\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0建立時間ts為2％等於我們可以擁有的最佳時間 \n •\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0超調等於5％ \n •\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0階躍函數作為輸入的穩態等於零 \n \xa0 使用性能和傳遞函數，很容易得出結論，比例控制器KP足以滿足這些性能。 \n \xa0 在此示例中，我們將使用連續時間方法進行控制器的設計。在上一章的基礎 \xa0 \xa0 \xa0 \xa0 上，我們的系統模型如下： \n \n 其中K和τ取與速度控制相同的值。 \n \xa0 讓傳輸控制器由以下方式給出： \n \n \xa0 使用這些表達式，閉環傳遞函數由下式給出： \n \n \xa0 由於系統類型為1，因此使用比例控制器輸入的階躍函數的誤差等於零。 \n \xa0 根據規範，以下複雜的兩根： \n \n 將完成這項工作，相應的特徵方程式如下： \n \n \xa0 與閉環系統之一等效，我們得到： \n \n \xa0 為了確定最佳穩定時間ts為2％，請注意，我們有： \n \n \xa0 現在使用事實： \n \n 我們獲得： \n \n \xa0 因此，使用此控制器可以在2%處獲得的最佳建立時間是系統恆定時間的8倍。小於可獲得的任何值。實際上，如果我們在改變KP時關注閉環系統的根源，這是微不足道的。這由 圖11.3 給出。為了將控制器的增益固定為所需的根點s1,2 = 7.5 j，我們使用該圖並選擇一個ζ= 0.707。得出KP = 0.1471。 \n \n 圖11.3 \xa0帶比例控制器的直流電動機的根軌跡 \n \xa0 使用該控制器，幅度等於30度的階躍函數的時間響應由 圖11.4 表示，從中我們可以得出結論，所設計的控制器以2%的穩定時間等於0.5115 s滿足了所有期望的性能。但是，如果我們實現該控制器，則實際情況將與仿真有所不同，因為齒輪箱的齒隙並未包含在所使用的模型中，因此實時結果將有所不同，誤差永遠不會為零。為了克服這個問題，我們可以使用比例和微分控制器，它可以在2%處提供更好的建立時間。讓該控制器的傳遞函數由下式給出： \n \n 其中KP和KD是要確定的增益。 \n \n 備註11.3.1 \xa0重要的是要注意，比例和微分控制器的使用將在閉環傳遞中引入零，如果放置得當，則可以縮短建立時間。根據其位置，過沖和建立時間將是受到影響。有關此問題的更多詳細信息，請參閱[1]。 \n \n 圖11.4 \xa0幅度為30度的階躍函數的時間響應 \n \n 使用該控制器，閉環傳遞函數由下式給出: \n \n \xa0 和以前一樣，控制器的設計使用了兩個複雜的根點。如果將兩個特徵方程式相等，則得到： \n \n \xa0 在這種情況下，我們有兩個未知變量KP和KD以及兩個唯一確定增益的代數方程。它們的表達式如下： \n \n \xa0 現在使用期望的性能，我們得出與之前類似的結論，即等於等於30度幅值階躍函數的輸入的穩態誤差等於零，並且與過衝等於5%的阻尼比ζ等於0.707。我們可以將其固定為系統時間常數的一部分的穩定時間ts在2%處給出： \n \n \xa0 現在，如果將穩定時間固定為3τ，我們將得到： \n \n \xa0 使用這些值，我們可以得到以下控制器增益值： \n \n 它給出了以下複雜的兩根： \n \n 零為： \n \n \xa0 使用該控制器，幅度等於30度的輸入的時間響應如 圖11.5 所示。從該圖可以看出，過沖和建立時間少於使用比例控制器獲得的過沖和建立時間。 \n \xa0 至實施比例或比例和微分控制器，我們需要得到控制律的遞推方程。為此，我們需要使用前面介紹的不同方法來離散化控制器的傳遞函數。讓我們使用梯形方法，該方法包括將s替換為 。這給出： \n \n \xa0 如果我們通過控制分別表示u（k）和e（k）以及瞬時kT處參考與輸出之間的誤差，我們將得到以下表達式： \n \n 對於比例 \n \n \n \n 圖11.5 \xa0幅度為30度的階躍函數的時間響應 \n \n \n 用於比例和微分控制器 \n \n \n \xa0 實現是該控制器使用相同的功能，但有一些小的更改。列出相應的功能是： \xa0 \n \n %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Main program %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\nmain\n% Data\n\n% Variables\n\n% While loop\nwhile (1)\ndo\nReadSpeed;\nComputeControl;\nSendControl;\nend;\n% ReadSpeed function\n\n% ComputeControl function\n\n% SendControl function \n \xa0 現在讓我們使用此示例的狀態空間表示，並設計一個狀態反饋控制器，以保證所需的性能。對於這種情況，我們將首先假定完全訪問狀態，其次通過假設僅可以訪問該職位來放寬此假設。像我們之前所做的那樣，我們可以連續進行，也可以不連續進行。 \n \xa0 先前我們建立了該系統的狀態空間描述，其描述為： \n \n \n \n \xa0 通過均衡這兩個方程式，我們可以得到以下結果： \n \n \xa0 使用該控制器，幅度等於30度的輸入的時間響應如圖11.6所示。從該圖可以看出，超調和建立時間就是我們想要的。重要的是要注意穩態狀態下錯誤的存在。如果在循環中添加一個積分動作，則可以消除此錯誤。有關此的更多詳細信息，請向讀者介紹[1]。 \n \xa0 對於第二種情況，由於我們無法訪問負載速度，因此我們可以從位置計算負載速度，也可以使用觀察者來估計系統狀態。如前所述，我們用於觀察者設計的根點應該比控制器設計中使用的根點更快。 \n \xa0 擇以下根點（s1,2，為控制器設計中所用實數的四倍）： \n \n \n 圖11.6 \xa0幅度為30度的階躍函數的時間響應 \n \n 我們為觀察者帶來以下結果： \n \n \xa0 控制器的增益與對狀態向量的完全訪問情況相同。 \n \xa0 在下面的Matlab中，我們同時提供控制器和觀察者的設計，並進行仿真，以顯示系統和觀察者的狀態相對於時間的行為。 \n clear all \n %data \n tau=0.064 \n k=48.9 \n A = [0 1;0 -1/tau]; \n B = [0 ; k/tau]; \n C = [1 0]; \n D = 0; \n \n % controller design \n K = acker(A,B,[-3+3*j -3-3*j]); \n L = acker(A’,C’,[-12+3*j -12-3*j])’; \n % Simualation data \n Ts = 0.01; \n x0 = [1 ; 1]; \n z0 = [1.1 ; 0.9]; \n Tf = 2; %final time \n \n %augmented system \n Ah = [A -B*K; \n L*C A-B*K-L*C]; \n Bh = zeros(size(Ah,1),1); \n Ch = [C D*K]; \n Dh = zeros(size(Ch,1),1); \n xh0 = [x0 ; z0]; \n t=0:Ts:Tf; \n u = zeros(size(t)); \n m = ss(Ah,Bh,Ch,Dh); \n \n %simulation \n [y,t,x] = lsim(m,u,t,xh0); \n \n %plotting \n figure; \n plot(t,y); \n title(’Output’); \n xlabel(’Time in sec’) \n ylabel(’Output’) \n grid \n figure; \n plot(t,x(:,1:size(A,1))); \n title(’States of the system’); \n xlabel(’Time in sec’) \n ylabel(’System states’) \n grid \n \n figure; \n plot(t,x(:,size(A,1)+1:end)); \n title(’states of the observer’); \n xlabel(’Time in sec’) \n ylabel(’Observer states’) \n grid \n \n \xa0 圖11.7與11.9 \xa0 給出了輸出、系統狀態和觀察者狀態的說明。 \n \n 圖11.7 \xa0輸出與時間 \n \n \xa0 我們還可以使用線性二次調節器設計狀態反饋控制器。實際上，如果我們為成本函數選擇以下矩陣： \n \n 備註11.3.2 \xa0通常，對於成本函數的矩陣的選擇沒有魔術規則。但是通常，例如，我們對控件使用較高的值將迫使控件採用較小的值，並可能防止飽和。 \n \xa0 使用這些矩陣和Matlab函數lqr，我們得到： \n \n \xa0 我們也可以使用魯棒控制部分的結果設計狀態反饋控制器。由於系統沒有不確定性，也沒有外部干擾，所以我們可以為名義動態設計一個狀態反饋控制器。使用系統數據和Maltlab，我們得到： \n \n 圖11.8 \xa0系統狀態與時間 \n \n \xa0 給出了相應的控制器增益: \n \n 備註11.3.3 \xa0由於我們有直流電動機套件的連續時間模型，因此我們用它來設計控制器增益。在這種情況下，我們解決了以下LMI： \n \n \xa0 增益K由下式得出：K = YX -1 。 \n \xa0 有關連續時間情況的更多詳細信息，請向讀者介紹Boukas [2]及其中的參考文獻。 \n \n 11.4\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0平衡機器人控制 \n 從控制的角度來看，平衡機器人是一個具有挑戰性的系統，因為它是一個不穩定的開環系統。該系統吸引了許多研究人員，為此已經提出了許多設計方案。在這裡，我們將介紹 \n \n 圖11.9 \xa0 觀察者狀態與時間 \n \xa0 圖11.10與11.11 \xa0 給出了機器人的概念。它是為研究目的而開發的，目的是使機電一體化的學生能夠實現他們的控制算法並熟悉複雜的系統。該機器人有兩個獨立的輪子，每個輪子都由一個直流電動機通過一個傳動比為1：6的齒輪驅動。每個電機都有一個編碼器來測量軸的速度。這兩個電機連接到機器人的主體。其他傳感器（如加速度計和陀螺儀）用於測量傾斜角。引入了適當的濾波器以消除這些措施的噪聲，從而獲得有用的控制信號。 \n \xa0 機器人的大腦圍繞30F4011系列的MicrochipdsPIC構建。在Microchip的C30使用PCKit2生成可執行代碼之後，所有的編程都以C語言完成，並插入到dsPIC中。 \n \xa0 如果我們參考第4章，則數學模型如下： \n \n \n 圖11.10 \xa0平衡機器人 \n \n 而 \n \n \n 圖11.11 \xa0平衡機器人的電子電路 \n \n \xa0 由於系統在開環中不穩定，因此讓我們設計一個狀態反饋控制器，該控制器具有以下性能： \n 1.\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0系統閉環穩定； \n 2.\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0超調小於或等於5％; \n 3.\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa02％的穩定時間等於1.5 s; \n \xa0 從規格中我們得到： \n \n \xa0 相應的主根對由下式給出： \n \n \xa0 由於矩陣A的等級為4，因此我們需要再放置兩個根點以確定狀態反饋控制器增益K。讓我們選擇以下主根： \n \n 使用功能acker，我們獲得了以下結果： \n \n \n 圖11.12 \xa0輸出與時間 \n \n \xa0 該控制器的模擬結果在 圖11.12和圖11.13 中示出。系統從初始狀態開始 \xa0輸入為零。要是我們嘗試發送輸入參考，我們將在狀態或輸出中出現錯誤。克服這需要添加一個整體動作。如果我們用 \n xr（t）為位置參考，然後跟隨[1]，我們得到： \n \n \n 圖11.13 \xa0狀態與時間 \n 而 \n \n \xa0 新的動力學變為五階，我們需要修復三個主導根點以及規範中的主導根點。這些根固定為以下根： \n \n \xa0 使用功能acker，我們獲得了以下結果： \n \n \xa0 我們還可以使用線性二次控制技術設計狀態反饋控制器。實際上，如果我們選擇以下矩陣： \n \n 並使用Matlab函數lqr求解Ricatti方程，我們得到： \n \n \xa0 閉環的相應特徵值由下式給出： \n \n \xa0 可以類似地獲得該控制器的仿真結果，並省略了細節。 \n \xa0 對於該系統，我們還可以使用穩健控制理論設計狀態反饋控制器。可以連續時間或離散時間完成。由於我們的模型是連續的，因此我們將使用LMI連續進行設計。求解適當的LMI（用於矩陣尺寸不同的直流電動機套件的LMI，我們得到： \n \n 為狀態反饋控制器提供以下增益： \n \n \xa0 閉環的相應特徵值由下式給出： \n \n \xa0 對於其他控制器的設計可以很容易地獲得，我們將此作為因為設計是為了編寫Matlab程序而為讀者進行的類似於我們在文本中給出的內容。 \n \xa0 作為第一個示例，讓我們考慮兩輪機器人的H∞控制問題。在這種情況下，我們在狀態動態中添加一個項。 該項為Bw（t），其中w（t）是具有有限能量的外部干擾。 通過γ= 0.1求解適當的LMI，我們得到： \n \n 為狀態反饋控制器提供以下增益： \n \n \xa0 閉環的相應特徵值由下式給出： \n \n \xa0 對於其他控制器的設計，可以很容易地獲得，並且我們將此作為讀者的練習，因為設計被引入來編寫類似於我們在本文中給出的Matlab程序。 \n \n \n 11.5\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0磁懸浮系統 \n 在本節中，我們將介紹前面介紹的磁懸浮系統。由我們的機電實驗室開發的機電系統由兩部分組成：一個固定的部分，代表線圈並產生電磁力，另一個是我們希望通過作用於電磁場產生的電磁力而放置在某個位置的鐵磁物體。線圈。該系統的目的是通過輸入電壓調節電磁鐵中的電流來控制移動物體的垂直位置。使用霍爾效應傳感器測量物體位置。dsPIC30F4011周圍的電子電路通過L298（集成電路）為線圈供電，電流與致動器的指令電壓成正比。由於磁力只具有吸引力，互導放大器會轉為否定命令。該系統如 圖11.14 所示。 \n \xa0 該系統的數學模型由以下方程式給出: \n \n 其中m是運動物體的質量，l（t）R+是從電磁體測量的距離，F1和F2分別是當電流為i（t）時線圈產生的力以及電磁體與電磁體之間的電磁力。永久磁鐵放置在移動物體的頭部。 \n \xa0 這些力的表達方式如下： \n \n \xa0 我們可以線性化這個非線性模型，得到以下信息（請參閱第1章）： \n \n 而 \n \n \xa0 該系統的數據由表11.1給出。使用此數據，矩陣由下式給出： \n \n \xa0 重要的是要注意，系統在開環中不穩定，因為它具有積極的一面。可以通過計算的特徵值來檢查矩陣A。 \n \xa0 讓我們設計一個狀態反饋控制器來保證以下性能： \n 1.系統穩定閉環 \n 2.超調量小於或等於0.2％ \n 3.％2的建立時間等於0.05秒 \n \n 圖11.14 \xa0磁懸浮系統 \n 表11.1 \xa0磁懸浮系統的數據 \n \n \n \xa0 由於過衝小於或等於0.2％，因此ζ= 0.9的2％的時間建立時間由下式給出： \n \n wn是自然脈衝。如果將穩定時間固定為0.05秒，我們將得到： \n \n \xa0 設計的主要根點如下： \n \n \xa0 使用這對根，我們得到： \n \n \xa0 使用該控制器，從給定的初始條件開始的時間響應如 圖11.15 所示。從該圖可以看出，過沖和建立時間就是我們想要的。 \n \xa0 對於第二種情況，由於我們無法訪問負載速度，因此我們可以從位置計算負載速度，也可以使用觀察者來估計系統狀態。如前所述，我們用於觀察者設計的根點應該比控制器設計中使用的根點更快。 \n \xa0 選擇以下根點（s1,2，為控制器設計中所用實數的四倍）： \n \n \n \n 圖11.15 \xa0運動物體的時間響應 \n \n 我們為觀察者帶來以下結果： \n \n \xa0 我們可以像我們對直流電動機套件和雙輪機器人所做的那樣試驗所有其他控制器，但是我們更喜歡讓這一部分作為練習供讀者練習工具。注意，我們邀請他/她在連續時間和離散時間情況下進行設計並比較結果。該系統的尺寸可以做到這一點。 \n \xa0 下面給出了用於對該系統的狀態反饋控制進行編程的示例： \n \n  #include <p30fxxxx.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <adc10.h>\n#include <math.h>\n#include <uart.h>\n\n//\n// Configuration\n//\n// Interne frequency (30 MIPS) instructions/sec\n// Number of samples: 7,37*16/4 = 29480000\n\n_FOSC(CSW_FSCM_OFF & FRC_PLL16);\n_FWDT(WDT_OFF);\n_FBORPOR(PBOR_OFF & MCLR_DIS);\n_FGS(CODE_PROT_OFF);\n_FICD( ICS_NONE );\n__C30_UART=2;\n\n//\n// Variables\n\n#define Freq_pic 29480000 // PIC Frequency\n\n#define a11 7.8510061454215840e-001\n#define a12 2.2727760074413661e-004\n#define a21 5.0829248960838420e+001\n#define a22 1.0000643300984893e+000\n#define b11 3.7771272752681438e-005\n#define b12 4.5392069137012870e-004\n#define b21 8.7496385285734044e-003\n#define b22 1.0852723324638587e-001\n\n#define Ts 2.2727272727272727e-004\n#define u_max 1.1789999999999999e+001\n#define ref_tension 5.0000000000000000e+000\n#define ref_pic 1.0240000000000000e+003\n#define duty_cycle_ref 5.8481764206955049e+001\n#define x_ref 7.8768775539549939e-003\n#define u_ref 2.0000000000000000e+000\n#define y_ref 8.5691877396730676e-001\n#define K0 5.2128678707944724e+004\n#define K1 3.9336557697049994e+002\n\ndouble y[2] = {0.0, 0.0};\ndouble u[2] = {0.0, 0.0};\ndouble y_tilde[2] = {0.0, 0.0};\ndouble tension_tilde[2] = {0.0, 0.0};\ndouble tension = 0.0;\ndouble duty_cycle_tilde = 0.0;\ndouble lim_Sup = 0.0;\ndouble lim_Inf = 0.0;\ndouble position_tilde[2] = {0.0, 0.0};\ndouble vitesse_tilde[2] = {0.0, 0.0};\ndouble integrale_tilde[2] = {0.0, 0.0};\ndouble duty_cycle = 0.0;\ndouble temps_total = 0.0;\ndouble n = 6553500.0/65536.0;\nint compteur = 0;\nint compteur_freq = 0;\nint uart_flag = 1;\nunsigned long Val_reg = 0;\n\n//\n// Functions\n//\n\nvoid init(void){\n\nINTCON1bits.NSTDIS=0; // Activation of the level of interruption\nTRISE = 0; // Configuration of PORTE as output\nTRISD = 0; //Configuration of PORTD as output\nPORTEbits.RE8 = 1;\nPORTEbits.RE2 = 0;\nPORTDbits.RD0 = 1;\nADPCFG= 0xFFFF; // Configuration of the pins of PORTB as digital\nI/O\n}\n\nvoid init_ADC (void){\n\nSetChanADC10(ADC_CHX_POS_SAMPLEA_AN3AN4AN5 &\nADC_CHX_NEG_SAMPLEA_NVREF);\n\nConfigIntADC10(ADC_INT_DISABLE);\n\nOpenADC10(ADC_MODULE_ON & ADC_IDLE_CONTINUE & ADC_FORMAT_INTG\n& ADC_CLK_AUTO & ADC_AUTO_SAMPLING_ON & ADC_SAMPLE_SIMULTANEOUS,\nADC_VREF_AVDD_AVSS & ADC_SCAN_OFF & ADC_CONVERT_CH_0ABC\n& ADC_SAMPLES_PER_INT_1 & ADC_ALT_BUF_OFF & ADC_ALT_INPUT_OFF,\nADC_SAMPLE_TIME_1 & ADC_CONV_CLK_SYSTEM & ADC_CONV_CLK_32Tcy,\nENABLE_AN4_ANA & ENABLE_AN5_ANA, SCAN_NONE);\n}\n\nvoid init_Timer1 (void){\n\nINTCON1bits.NSTDIS=0; // Activation of mode 16 bits of the Timer1\nT1CONbits.TON = 1; // Autorisation du Timer1\nT1CONbits.TGATE = 0; // Dsactivation du mode Timer Gate\nT1CONbits.TSIDL=1; // Synchronisation of Timer1 sur le Idle mode\nT1CONbits.TCKPS = 0; // Choice of the Prescaler 1:1\n(1=1:8, 2=1:64)\nT1CONbits.TCS=0; // Selection of the interne clock (0=FOSC/4)\nIFS0bits.T1IF = 0; // Put to zero the overflow bit for the\ninterrupt of Timer\nIEC0bits.T1IE = 1; // Activation of the interruption of Timer1\nPR1 = 6699; // Sampling frequency at 4400 Hz environ\nIPC0bits.T1IP = 5; // Priority 5 for the interruption of the\nTimer1\n\n}\n\n/* ROUTINE D’INITIALISATION DE L’UART */\n\nvoid init_UART (void){\n\nConfigIntUART2(UART_RX_INT_DIS & UART_RX_INT_PR0\n& UART_TX_INT_DIS & UART_TX_INT_PR0);\n\n// Configuration of the register\n\nU2MODEbits.UARTEN = 1; // UART pins controlled by UART\nU2MODEbits.USIDL = 0; // UART communication continue in\nIdle Mode\n\nU2MODEbits.WAKE = 1; // Wake up enable in sleep Mode\nU2MODEbits.LPBACK = 0; // Loopback mode disabled\nU2MODEbits.ABAUD = 0; // Autobaud process disabled\nU2MODEbits.PDSEL = 0; // 8-bit data, no parity\nU2MODEbits.STSEL = 0; // 1 stop-bit.\n\n// Configuration du registre U2STA\n\nU2STAbits.UTXISEL = 0; // Transmission Interrupt Mode\nSelection bit\nU2STAbits.UTXBRK = 0; // UxTX pin operates normally\nU2STAbits.UTXEN = 1; // Transmit enable\nU2STAbits.URXISEL = 1; // Interrupt occurs when one charater\nis received\nU2STAbits.ADDEN = 0; // Address detect disabled\n\nU2BRG = 31; // Value for 57600 bps baudrate\n}\n//\n// Initialization of the complementary mode PWM\n//\nvoid init_PWM (void){\n\nVal_reg = 1023; // Frquence de 30000 Hz environ\nlim_Sup = (u_max*(2*Val_reg + 1)/(2*Val_reg + 2)) - u_ref;\nlim_Inf = -u_max - u_ref;\n\nPTCONbits.PTEN = 1; // Activation of the time base\nPTCONbits.PTSIDL = 1; // Configuration in Idle Mode\nPTCONbits.PTCKPS = 0; // Selection de 4TCY ( Prescale: 00 = 1:1;\n01= 1:4; 10 = 1:16; 11 = 1:64)\nPTCONbits.PTMOD = 0; // Selection of the free running mode\n\nPTMRbits.PTDIR = 0; // Increment of the time base\nPTMRbits.PTMR = Val_reg; // Register value of the Time base\n\nPTPER = Val_reg; // Value of the signal period\n\nPWMCON1bits.PMOD1 = 0; // Selection the mode PWM complementary\nPWMCON1bits.PEN1H = 1; // Activation of the pins in mode PWM\nPWMCON1bits.PEN1L = 1; // Activation of the pins in mode PWM\n\nDTCON1bits.DTAPS = 0; // Time base unit is 1TCY\nDTCON1bits.DTA = 0; // Value of the DT for the unity A\nPDC1 = 0; // zero of the dutycycle\n\n}\n\nvoid __attribute__((interrupt, auto_psv)) _T1Interrupt (void){\n\nif (IFS0bits.T1IF){\n\nPORTEbits.RE2 = !PORTEbits.RE2;\nPDC1 = (2.0 * (Val_reg + 1) * duty_cycle)/100.0; // Calcul de la\nvaleur du registre PDC1\ny[0] = (ReadADC10(2)*ref_tension)/ref_pic; // Signal of the\nsensor in Volts\ny_tilde[0] = y[0] - y_ref;\n\nposition_tilde[1] = position_tilde[0];\nvitesse_tilde[1] = vitesse_tilde[0];\nintegrale_tilde[1] = integrale_tilde[0];\ny_tilde[1] = y_tilde[0];\ntension_tilde[1] = tension_tilde[0];\n\nposition_tilde[0] = (a11*position_tilde[1]+a12*vitesse_tilde[1]\n+b11*tension_tilde[1]+b12*y_tilde[1]);\nvitesse_tilde[0] = (-a21*position_tilde[1]+a22*vitesse_tilde[1]\n+b21*tension_tilde[1]+b22*y_tilde[1]);\ntension_tilde[0] = (K0*position_tilde[0]) +\n(K1*vitesse_tilde[0]);// + N*ref;\n\nif(tension_tilde[0]>lim_Sup){tension_tilde[0] = lim_Sup;}\n// Saturation of the tension tilde\nif(tension_tilde[0]<lim_Inf){tension_tilde[0] = lim_Inf;}\n\ntension = u_ref + tension_tilde[0];\nduty_cycle_tilde = tension_tilde[0]*(50.0/u_max);\nduty_cycle = duty_cycle_ref + duty_cycle_tilde; // Computation\nof the duty cycle in percentage\n\ntemps_total += Ts;\n\ncompteur_freq = 0;\n\ncompteur++;\nif(compteur == 10){ // Print data every 1 ms\ncompteur = 0.0;\nuart_flag = 1;\n}\n\nIFS0bits.T1IF = 0; // put to zero of the overflow bit\n}\n}\n\n/* PROGRAMME PRINCIPAL */\n\nint main (void){\n\ninit();\ninit_PWM();\ninit_ADC();\ninit_UART();\ninit_Timer1();\nwhile(1){\ninit();\ninit_PWM();\ninit_ADC();\ninit_UART();\ninit_Timer1();\nwhile(1){\nif (uart_flag){\nprintf("%lf %lf %lf %lf %lf %lf %lf\\n\\r",\ntemps_total, tension, u_ref, y[0], y_ref,\nposition_tilde[0], x_ref);\nuart_flag = 0;\n}\n}\n}\n \n \n 11.6 結論 \n 本章涵蓋了一些案例研究，這些案例是在我們位於蒙特利爾的E\'cole PolytechniquedeMontre´al的機電一體化實驗室中開發的。我們詳細介紹了機電系統設計的所有步驟。重點放在每個提出的系統的控制算法的設計。 \n \n 11.7 問題 \n 1.讓我們考慮一個具有以下數據的動態離散時間系統： \n \n \n (a)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0為標稱系統設計以下控制器： \n i.\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0狀態反饋控制器 \n ii.\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0靜態輸出反饋控制器 \n iii.\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0動態輸出反饋控制器 \n (b)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0為不確定係統設計以下控制器： \n i.\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0狀態反饋控制器 \n ii.\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0靜態輸出反饋控制器 \n iii.\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0動態輸出反饋控制器 \n (c)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0如果我們在狀態動力學中有一個額外的術語會增加外部干擾： 。為標稱和不確定係統設計控制器（狀態反饋、靜態輸出、動態輸出反饋），以確保H∞性能。 \n (d)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0設計狀態反饋，靜態輸出反饋和動態反饋控制器，以確保所有容許的不確定性的保證成本。 \n 2.在這個問題中，我們邀請您進行小船的設計，您可以使用操縱桿控制小船，使其例如在小紫膠中移動。 \n (a)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0給出原理圖設計（電池、電動機等） \n (b)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0建立數學模型 \n (c)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0修正您想要的規格，並設計合適的控制器以達到這種性能 \n 3.在這個問題上，我們邀請您進行小型飛機的設計，您可以使用操縱桿控制小型飛機的飛行。 \n (a)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0給出原理圖設計（電池、電動機等） \n (b)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0建立數學模型 \n (c)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0修正您想要的規格，並設計合適的控制器以達到這種性能 \n 4.在這個問題上，我們要求設計真空吸塵器。此設備應為自動設備，並避免其環境中的障礙物。設計便宜的，可以通過發射器、接收器和操縱桿進行無線通信的控制器也很重要。 \n (a)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0給出原理圖設計（電子電路、電機等） \n (b)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0建立數學模型 \n (c)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0修正您想要的規格，並設計合適的控制器以達到這種性能 \n 5.在這個問題上，我們邀請您繼續進行機電系統的設計，該系統控制乒乓球的小球的位置。可以使用壓縮空氣來定位球。 \n (a)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0給出原理圖設計（電子電路、電機等） \n (b)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0建立數學模型 \n (c)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0修正您想要的規格，並設計合適的控制器以達到這種性能 \n 6.在此問題中，我們希望設計一種單腿機器人，該機器人可以在保持垂直位置的情況下使用一個輪子移動。提供此類機電一體化系統的設計。 \n (a)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0給出原理圖設計（電子電路、電機等） \n (b)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0建立數學模型 \n (c)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0修正您想要的規格，並設計合適的控制器以達到這種性能 \n 7.太陽能是可以使用的替代能源。在這個問題上，我們要求您設計一個太陽能係統，以使太陽能電池板產生的能量最大化。 \n (a)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0給出原理圖設計（電子電路、電機等） \n (b)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0建立數學模型 \n (c)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0修正您想要的規格，並設計合適的控制器以達到這種性能 \n 8.在這個問題中，我們要求設計一種可通過操縱桿通過發射器和接收器控制在水上進行密封的胡佛。 \n (a)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0給出原理圖設計（電子電路、電機等） \n (b)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0建立數學模型 \n (c)\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0修正您想要的規格，並設計合適的控制器以達到這種性能 \n', 'tags': '', 'url': 'MechatronicDesignCases.html'}, {'title': 'MechaEducFutureNeed', 'text': '原文pdf連結: MechaEducFutureNeed.pdf \n 翻譯連結: MechaEducFutureNeed翻譯.pdf \n Ch15機電一體化教育：滿足未來需求 \n 15.1簡介 \n 在員工大會、會議和部落格上熱烈討論的所有主題中，未來的教育效果和相關性似乎總是在上升。教授們回想起自己的教育經歷和在學術界達到目前的地位而奮鬥的過程，這是因為目前缺乏數學和缺乏學生才能以及從硬設計轉變為即插即用的思維方式。軟件即服務（SaaS）、雲計算以及平台即服務（PaaS）和機電一體化系統之間存在明顯的脫節。 \n \xa0 雖然從構成物聯網（IoT）的計算單元內部進行抽象可能會加快產品的發布速度，但在實際應用領域中工作的機電工程師卻正在考慮軟件及其原始碼的完整性、可靠性。實際環境中的時間，如何管理組件升級以及故障後的系統恢復。本章包含作者經驗中的真實經歷、困難、挑戰和討論主題，旨在突出機電工程師必須了解的知識並說明創新和技術靈活性的必要性。選擇本章的每個小節都是為了突出技術和非技術主題，這些主題應該成為機電一體化教育不可或缺的一部分。 \n \xa0 在2014年6月於瑞典Karlstad,Sweden舉行的2014年機電一體化會議上，作者是受邀小組成員，進行了激烈的討論。他在製造系統集成行業和學術界工作了近五十年。本章中表達的是他本人的觀點，旨在發起討論，並希望在其讀者機構的教學人員和管理人員中實現機電一體化教育的真正進步。隨著教學交付機制從傳統的講課課堂遷移到更多的基於結果的教學大綱和技術增強的學習中，希望讀者能夠決定機電一體化和類似學科的最佳行動方案學習課程。 \n \n 15.2教育經歷與就業 \n 對教育過程進行快速的審核，很明顯與專業相反，沒有機電一體化的真正知識。比較在大學甚至大學前的共同核心教育，不在本章的範圍之內。目的是強調如何構成未來工程學隊列的學生、教授與眾不同的相似元素，從而降低在線交付的效率。 \n \xa0 儘管在撰寫本文時，在線教學可能處於上升之中，North Carolina Charlotte大學（UNCC）的教學中心列出了150種不同的教學方法，但不能肯定所有方法都適用於機電一體化。這些範圍從著名的 老師的演講 （排名第一）到 小組集體討論 （排名第150）。排名第106的是 技術和教學資源的使用 。 該章作者最喜歡冒險的是＃127 參觀民族餐廳 。 但是，什麼是最適合學生的呢？ \n \xa0 有許多教學方法。 表15.1是Southern Nevada大學（CSN）網站的，並總結了可以與各種教學方式相關的一些教學方法。 \n \xa0 學術讀者將隨時隨地聯想到他們機構中的課程是如何進行的。在完整的CSN網站之後，有興趣的讀者可能會發現這些方法如何轉化為有趣的在線環境。 \n 15.2.1機構 \n 在美國，有一千多所擁有一所工程學校的學院和大學。如果增加歐洲、中國和印度的工程部門數量，則這個數字將大大增加。就課程而言，大多數學校都受到理事機構的監管（例如，美國的ABET），但是美國沒有通用的核心課程。 \n \xa0 這意味著在機構A中所教的內容在機構B中可能是膚淺的，甚至根本沒有。在國外，問題更加嚴重。某些國家/地區的一些工程學校沒有通過其本身以外的會議。通過授予工程學學位，這些機構承諾為他們的畢業生提供好工作和更好的生活，甚至根本不認為他們在國內或國外都享有良好的工作。這對學生不利。 \n 表15.1 教學方法和教學風格 \n \n \n \n \n 方法 \n \n \n 註釋 \n \n \n \n \n 演講 \n \n \n 一種靈活的方法，幾乎可以應用於任何內容。 儘管講座可能非常吸引人，但它們使學生處於被動角色。經驗豐富的工作人員可以將他們的實際經驗融入課程材料中，以顯示班級的相關性。 \n \n \n \n \n 講座討論 \n \n \n 將講座與簡短問題期或一系列簡短問題期相結合。 \n \n \n \n \n 示範 \n \n \n 讓學生根據講師的表現學習過程或程序。學生可以參與示範和練習。 \n \n \n \n \n 模擬 \n \n \n 模擬使學習者處於看似真實的情況下，他們可以做出決策並體驗決策的結果而不會冒險。 \n \n \n \n \n 協同學習 \n \n \n 學生通過相互討論與課程相關的問題和主題來處理信息並獲得知識。 \n \n \n \n \n 合作學習 \n \n \n 一小組學生一起解決問題或完成任務。 \n \n \n \n \n 實例探究 \n \n \n 這涉及個人或學生群體一起分析案例，這通常是一種現實情況，旨在突出問題和解決方案。 \n \n \n \n \n 角色扮演 \n \n \n 學生通過採用與之相關的不同角色來解決問題。角色扮演涉及識別，執行和討論問題。小心謹慎，這可能非常有效，特別是在系統工程的非技術方面，例如人力資源管理。 \n \n \n \n \n 基於問題和探究學習 \n \n \n 講師給學生一個問題，學生必須通過收集數據，組織數據並嘗試進行解釋來解決。 學生還應該分析他們用來解決問題的策略。 \n \n \n \n \n \n \xa0 \xa0 為了解決這個問題，許多知名大學和學院都開設了在線和遠端研究生課程。 機電一體化，機器人技術和其他學科在旨在成為教育對象的領域中很受歡迎。 \n 15.2.2學院教職員工 \n 大學教學人員、講師和教授最好是成熟的，並且具有一定的實際行業經驗。他們沒有經過真正的教學培訓，就按照所教的內容進行教學、理論豐富，並且與學生的興趣或最終職業無關。大多數教學人員在教學，課堂管理或法律和道德事務上都沒有或很少接受過正式培訓。 \n \xa0 《美國新聞與世界報導》每年對排名靠前的學校進行排名，但該排名通常反映出研究支出，所授予博士學位的數量（如果適用），在其機構內擁有最終學位和研究員身份的員工人數。 該等級可以包括畢業率和保留率。 可以為每位工作人員規定教學方法，但是在合同續簽問題上，教學方法的重視程度肯定低於受資助的研究。 \n \xa0 英國教學質量評估（TQA）等工作旨在強調和獎勵學校和學院的良好教學實踐，與研究評估練習（RAE）處理研究的方式幾乎相同。 優秀的研究人員和教學人員有責任在TQA和RAE評審中提高成績。 在美國，工程部門需要接受全國范圍內ABET的定期認證程序，但只能獲得學士學位。 但是，什麼是最適合學生的呢？ \n \n 15.2.3大學生 \n 舉例來說，在美國，許多工程專業的學生在相當集中的課程中花費了兩年多的時間（例如，電氣工程），並且可能在第一年或第二年選擇自己的專業。在進行這些研究的同時，學生將接觸到道德、法律問題和陳述。在歐洲，學生可以進入已經知道他們所選領域的課程，並經歷四年的主題學習。 一些學校在最後一年之前註入工作經驗，而另一些則從事最後一年的學生項目。 \n \xa0 幾乎不用說，成功的學生將具有良好的學習技能和對工程學的興趣，而缺乏學習精神的學生則表現較差，並經常轉入其他（自認為更容易）的課程或機構。 這是一個眾所周知的結構，即學生在上大學之前如何學習科學、技術、工程和數學（STEM），這是該大學生選擇哪些研究領域的主要指標；這將在本章末尾顯示，在全球範圍內有所不同。儘管獲得了獎學金和經濟援助，但地理位置、需求和社會地位確實可以確定哪些機構對申請人可行。 \n \xa0 全球的工科學校有些挑剔，要獲得學士學位，需要四年甚至五年的學習時間。 機電一體化當然是由學士，碩士和博士學位級別的人教授的，但通常是由熱情的工作人員擁護。 是否吸引學生攻讀研究生學位以幫助員工進行研究和教學，而不是行業僱用？ 這對學生最好嗎？ \n \n 15.2.4機電一體化用人單位 \n 現在想像一下，該學生已經成功地在一家技術公司找到了工作，該公司為本章的目的生產或使用機電一體化系統。這樣的雇主對專業知識有進一步發展他們的產品或服務的需求，並對即將畢業的畢業生或技術人員寄予厚望。 \n \xa0 在法律和醫學專業中，創新者必須先完成居住才能獲得認證，然後才能執業，而在工程學中，成為一家機構的特許會員在很大程度上被認為是可選的、珍貴的且無關緊要的。 對於新員工來說，通常是經驗豐富的工程師，直到他們可以自己分配給項目專家為止。由此，讀者可以推斷出項目失敗的原因，成本超支的發生方式以及產品從未達到客戶預期的效果。 什麼對公司最合適？ \n \n 15.3機電一體化：現實世界中的小插圖精選 \n 以下內容包含了本章作者的經驗中的三個真實的事實短片，旨在反映機電一體化教育中的必要主題。出於保密原因，省略了公司名稱或公司名稱，但希望讀者會發現示例有用。每個小節將簡要描述一個真實的系統及其設計、問題如何自我呈現、問題的解決方法，最重要的是，機電技術工程師可以使用什麼教育技能來解決問題。為了更好地說明這一點，第一種情況比其他兩種情況更為詳細。 \n \n 15.3.1注塑成型監控系統 \n 總覽 \n 一家注塑公司與系統工程公司簽約，以設計和實施其主要場所的生產監控系統，該系統最多可運行40台高科技模塑機。 每天大約有35台機器定期運行，每天生產數千萬個塑料小零件。這些組件按重量包裝在盒子中，然後傳遞到質量控制和庫存中。 圖15.1顯示了一個典型的注塑（IM）工廠。 \n \n 圖15.1 典型的美國注塑操作（由Rodon Group，Hatfield PA提供） \n \n \xa0 工廠在逐個工作的基礎上生產各種物品。任何機器上的工作變更都需要花費大量的精力來清除先前的有色原始材料和必要的模具安裝，並且新的液態塑料會滲入系統中以用於下一項工作。機械師可能會多次循環機器，直到新零件完美為止，但是這些測試操作永遠不會出現在生產數量中。 \n \n 要求摘要 \n 系統的要求包括以24×7為基礎對每台機器的每個週期進行測量，將實際性能與工廠工作指令進行比較，在整個工廠提供顯示屏以及定期下載 庫存數據到大型計算機。從數據完整性的角度來看，這實際上是很難做到的，因為並非所有的機器週期都會產生例如 技術人員進行新工作或清除卡紙。 \n \n 系統設計 \n 與工業客戶多次會面後，圖15.2作為初步的系統設計出現了。在大多數工業自動化設置中，主要組件是相當標準的。可編程邏輯控制器（PLC）是工業過程控制代理、可抵抗斷電，並具有本地存儲、通信功能以及多個輸入和輸出數據端口。 \n 在設計了系統之後，在對系統進行了更詳細的現場檢查之後，提出了以下迄今為止無法預料的問題： \n 1.如何長距離連接機器信息？ \n 2.如何在如此長的距離上連接所有系統設備？電信號都是低質量的，注塑機會隨機產生明顯的噪聲。 \n 3.顯示多少信息有用？ \n 4.操作員和技工如何提供特定數據進行顯示？ \n 解決這些問題後，實際上確實需要重新設計系統併購買其他軟件和硬件，然後對系統進行編碼和安裝。 \n \n 圖15.2 初步系統設計 \n \n 問題領域 \n 在系統的日常運行中，出現了以下意外情況： \n 1.在操作期間隨時可能出現凍結的隨機數據。 \n 2.主工廠電源中斷或停電後數據丟失。 \n 3.處理機器的維護和維修狀態週期。 \n 4.輪班報告顯示錯誤時間。 \n \xa0 這些問題似乎表明了系統中的致命缺陷，但使用機電一體化原理可以解決。 本章作者的解決方案在15.5.1節中進行了概述。 \n \n 15.3.2在小型計算機上執行大型機代碼 \n 總覽 \n 一家公司正在使用大型計算機來執行高級CADCAM和圖形處理。每個設計站的成本超過50,000美元，大型機租賃和操作系統的每月成本超過100,000美元。 顧問找到了一家公司，該公司通過對小型計算機的主板進行一些細微的調整，找到了一種在價值2萬美元的小型計算機上運行大型機指令的方法。 \n \n 發明概述 \n 圖15.3說明瞭如何通過使用專有固件修改小型計算機主板來由小型計算機訪問和執行大型機指令。虛線所示的示意圖是所需的唯一固件修改。小型計算機字的大小必須與從製造商處購買的大型機指令芯片組（32位）相當。 \n \n 問題領域 \n 該系統運行良好，並且CADCAM應用成功，並且是傳統圖形工作站的廉價替代品。在升級小型計算機操作系統之後，系統完全無法運行。嵌入在CADCAM序列中的大型計算機指令突然導致微型計算機返回非法指令陷阱，並完全導CADCAM故障。 \n \xa0 此問題表明系統中存在致命缺陷，最終被證明無法解決，導致該項目被終止。本章作者的解釋在15.5.2節中進行了總結。 \n \n 圖15.3 修改後的微型計算機主板示意圖 \n \n 15.3.3機械不穩定的系統 \n 總覽 \n 許多研究人員研究了各種將控制引入倒立擺裝置的方法。該系統適用於自適應、智能、進化和學習控制。 圖15.4是作者與之合作的一種此類鑽機的照片。本質上，手推車是在計算機命令下以 左右 模式驅動的。實驗被限制在一個兩米長的軌道上，兩端各有一個碰撞傳感器。推車上的桿可自由鉸接，但限制在±10°左右。如果系統超出範圍，則推車上的運動將停止。問題在於通過左右移動推車來平衡桿，不應與向上擺動桿平衡動作混淆。 \n \n 問題領域 \n 兩個主要問題是確保系統從初始的隨機但合法的狀態開始使用其學習算法，以便控制器可以識別它並以控制偏移的形式啟動，並在手推車方向反轉時處理從動輪打滑 。15.5.3節概述了本章作者對第一個問題的解決方案的解釋。 \n \n 15.3.4案件摘要 \n 對於上述三種情況中的每一種，如何解決這些有問題的情況在下面的15.5節中都有介紹。鼓勵讀者在閱讀本節之前與學生討論他們的想法。閱讀作者的評論後，讀者應該討論他們機構或公司中的哪些教育模塊可以使創新工程師解決這些問題？ \n \n 圖15.4 手推車和桿子實驗台 \n \xa0 也許我們的大學缺少教育經驗是對系統工程和系統集成的深入介紹。 \n \n 15.4系統工程與系統集成 \n 在以上章節中給出的情況下。在15.3節中，系統組件、集成系統的設計，甚至系統在其全局範圍內（也稱為系統的系統）中的放置，都很大程度上取決於對系統工程和系統集成的理解 。 \n \n 15.4.1系統工程 \n 可以在國際系統工程理事會（INCOSE）的網站上找到系統工程的最清晰定義： \n （INCOSE）...代表來自全球行業，政府和學術界的系統工程專業人士。它堅信，系統工程的基本原理在所有工程師的教育中都起著重要作用，無論他們的專業是什麼，以及與系統工程師一起工作但沒有工程背景的專業人員。 \n \xa0 同一網站解釋了該學科的性質及其真正基於結果的重點。 \n 系統工程是一種跨學科的方法，是實現成功系統的手段。 它著重於在開發週期的早期定義客戶需求和所需的功能，記錄需求，然後在考慮整個問題的同時進行設計綜合和系統驗證。 \n \xa0 具體來說，系統工程是一個集成範式，多年來，工程學院從來沒有教過它，前提是他們的程序專業的畢業生將在職業生涯的晚些時候接手。 \n 系統工程將所有學科和專業團隊整合為一個團隊，形成了從概念到生產再到運營的結構化開發過程。 系統工程考慮了所有客戶的業務和技術需求，目的是提供滿足用戶需求的優質產品。 \n \n 15.4.2系統集成 \n 系統集成是計算機科學和IT領域眾所周知的一門學科，它的含義是使用即插即用範例從COTS（現成代碼）、SaaS（軟件即服務）和後期的雲端服務。在軟件領域，開放體系結構環境中的主要集成問題是系統和應用程序配置。在此活動中，集成商必須巧妙地將應用程序插入可能用另一種語言在外部編寫的代碼集。例如SAP®之類的企業軟件系統需要使用許多配置表格和數據操作，才能使製造公司從其複雜性和信息能力中受益。大多數問題來自硬件故障，互聯網問題以及術語和用法不當。 \n \xa0 在機電工程系統集成中，機械、電氣、計算機和系統學科的結合產生了問題。在一個區域內求解可能會導致另一面突然失效。15.3.2節說明了項目是如何通過無故障而失敗的，如15.5.2節所述。實際上，微型計算機供應商不願對他們的操作系統進行簡單的修改才導致了故障。 \n \xa0 計算機工程和計算機科學程序通常包括一些信息集成，數據庫和啟用互聯網的模塊。 總體上，正式的工程計劃很少涉及系統集成的課程。Warminki和Ikonomov認為：基礎工程課程未能教授以下領域的寶貴技能： \n •知識管理/文檔/召回和重用。 \n •在跨職能的分佈式團隊中工作。 \n •產品設計框架中的批判性思維。 \n •設計方法，包括：將模糊的要求轉換為工程規範，故障模式識別和效果分析、總參數和公差產品設計、製造執行，作為團隊成員進行自動化手冊的分析和集成製造過程。 \n \xa0 他們所在機構的這個問題正在通過詳細的動手項目解決，在該項目中，學生面臨要解決的實際問題。 在小組情況下，學生可以從事解決問題的活動，例如Scrum和其他類似的面向團隊的項目工作。 \n \n 15.4.3實作與基本知識的教學 \n 這種基本項目的方法是引入了學生動手 彌補 教育價值與傳統的固體教育課堂教學的爭議。 常見的 邊做邊學 在簡單的教學情況下可能會很好地起作用，但在以上15.3節中給出的情況下是否奏效?急於付費客戶可以同等地學習專業知識嗎？在第15.2.4節的內容被低估了。 \n \xa0 正式的工程程序，尤其是那些在認證控制下的程序，不願放棄更經典的類型，而傾向於機電一體化或系統工程。許多學校都推出了機電一體化的一兩年制碩士課程。這些在美國比在歐洲更受歡迎。歸根究底，主要是大學教授的經驗、熱情和專注心，信任他們能夠培養出具有道德，世俗明智的各個學科的合格工程師。許多項目工作都是在個人層面上進行的，與其他學生的互動很少，而在行業中，團隊合作的能力則是一種技能。 \n \n 15.5案例問題的解決方案和教育資源 \n 下面概述為如何解決每個案例的問題區域，但是讀者可能希望與同事和班級討論其他解決方案。第一種情況的細節更為詳細，以說明機電一體化系統的複雜性，因為它位於真實的工業環境中。第二個重點是對操作系統和固件有相當深入的了解，第三個重點是機械設計和定時軟件的使用。 \n \n 15.5.1注塑成型監控系統（範例15.3.1） \n 本節介紹的問題的解決方案。 以下總結了15.3.1，但應清楚地理解，這並不是詳盡的清單。 \n \n 問題（a）和（b） \n 這些問題集中在長距離連接設備以及低質量和高噪聲電信號上。 \n \xa0 \xa0 解決方案 —使用短程調製解調器並檢查工廠屋頂中的所有電線屏蔽都可以解決此問題。更好、更昂貴的解決方案是使用光纖電纜進行重新佈線。 \n \xa0 \xa0 教育對象 —工程師需要熟悉遠距離的調製解調器、通信和光纖線連接。 \n \n 問題（c）和（b） \n 這些引入了良好的數據收集，顯示和工廠現場輸入的問題。 \n \xa0 \xa0 解決方案 -至關重要的是，由包括工業客戶和工廠車間人員在內的焦點小組決定要在車間上顯示什麼數據。在所討論的系統中，很明顯需要從操作員那裡收集車間數據。然後，這些數據確定了機器故障的必要性和性質等。必須安裝微終端，並使用數據融合技術將此數據集成到數據庫中。 \n \xa0 \xa0 教育對象 -系統設計人員需要對數據庫設計和融合以及人機交互有深入的了解。 \n \n 問題（e）、（f）、（g）和（h） \n 這些全都發生在系統的運行階段中。 在原始系統中，數據收集和所有數據庫操作將凍結，從而模仿斷電的影響。 \n \xa0 \xa0 解決方案 -工廠軟件的設計和實現需要一定級別的系統智能，以便可以檢測到臨時問題和故障並進行 自我修復 以避免數據丟失。實際的系統包括可編程邏輯控制器（PLC），其中嵌入了前端智能功能，可以在系統暫停或停止期間臨時存儲數據。 \n \xa0 \xa0 教學對象 -機電工程師需要了解文件鎖定和系統編程，以釋放鎖定的文件和文件夾。實時操作系統設計知識是必不可少的，因此熟悉可用的工業組件也是如此。 \n \n 15.5.2在小型計算機系統上執行大型機代碼失敗 \n 系統如何運作 \n 圖15.2 描述瞭如何購買專有固件來修改硬件。小型計算機主板利用了小型計算機的32位處理器狀態字（PSW）中未使用的17位。操作系統內核允許系統用戶訪問高優先級任務中的所有PSW位。PSW中包含位3，可捕獲指令錯誤。小型計算機嘗試執行大型機指令時正是設置了此位（第3位）。 如果執行程序檢測到此類事件，它將設置最後一個未使用的位（第17位），該位用於將執行定向到其他硬件以供執行。 \n 失敗原因 \n 小型計算機供應商發布了對該操作系統的更新，該更新無辜地將該位（17）用於新的精緻打印功能。 操作系統軟件團隊花了許多時間來開發此新功能，該功能將使其所有其他客戶受益。CAD / CAM項目已取消。 \n \xa0 \xa0 教學對象 -為了使機電工程師能夠檢測到，這將需要相當高水平的計算機體系結構、系統編程和固件。順帶一提，先進的談判技巧可能已經保存了該項目！ \n \n 15.5.3機械不穩定的系統 \n 隨機但合法的初始狀態系統 \n 許多桿和手推車系統都始於將桿垂直固定在軌道中心附近。釋放後，系統將啟動，過程繼續進行，但總是從幾乎相同的初始狀態變量值開始。這是系統中的真正缺陷。在這種情況下，為了使手推車和桿邏輯從隨機但可識別的初始狀態進入學習範式，有必要構造一個啟動子系統，該子系統將手推車沿一個方向驅動一段隨機時間，然後反轉購物車方向較短的隨機時間，然後再次反轉。這將使磁極從其最初的穩態靜止位置變為動態狀態，但不會使其獲得足夠的動量以至於失敗。在啟動過程中，控制系統監視狀態變量當啟動系統進入狀態時，系統的爆炸控制值與啟動值一致，因此啟動邏輯斷開，對系統有利。 \n \xa0 還有許多其他這樣的示例，讀者可以使用這種方法根據自己的經驗選擇插入自己的示例。 \n \n 15.6結論：本地解決方案帶來的全球性問題 \n 解決未來的教育方法 要懂得變通 ，馬歇爾·麥克盧漢（Marshall McLuhan）說，布朗最近在《教育》雜誌上發表的一篇文章中引用了這一觀點。 布朗討論了諸如自適應學習技術、學習空間、學習分析和下一代學習管理系統之類的概念，並著重介紹了學生如何通過教學經歷或途徑進行學習。 \n \xa0 這當然有真理的成分，但可能過於簡單化。能夠將研究或其他技術興趣帶入課堂的敬業教師不僅可以吸引班級的注意力，而且可以創造一個學習環境，使學生成為終身的學習者、道德和創新。再次看著15.5節。列出了可行的（和實際的）解決方案時，讀者應考慮在自己的機構中何處教授這些技能。 \n \xa0 這件事不僅限於北美或歐洲，而且在中國、印度、新加坡、澳大利亞和許多其他國家通常被歸類為良好機構的情況下，也是全球性的不適。 \n \xa0 一個現成的解決方案可能是更好地理解和使用諸如大學和IMechE、IET、IEEE、ASME等專業機構提供的持續專業教育（CPE）模塊。這樣的計劃可以幫助培訓更多的高級工程師，並填補新員工的空缺。為了更深入地了解機電一體化，許多機構都提供了授課式碩士課程，可以面對面或在線學習。在這些計劃中，學生已經是有學歷的工程師，因此可以在無需太多數學或基礎工程學複習的情況下專注於本章中描述的機電問題。 \n \xa0 本章的目的是介紹一些機電一體化系統如何解決各種問題的概念，即使是在博士級別的學生，也可能沒有深入的指導，並且還不具備經驗豐富的工程師的才幹。由於數字每年都在如此迅速地變化並且由不可靠的來源提供，因此很大程度上避免了參考統計數據。 \n Ch16結論 \n 作者希望本書的讀者喜歡本文的基本研究主題和未來的願景。本章反映了這些主要主題的相互作用和集成，並試圖總結關鍵陳述。 \n \xa0 應當指出，技術（機電）系統的不斷（發展）與多個學科（例如IT功能和組件）的更深層次的集成以及產品及其相關生產過程之間的詳細考慮是其中的一部分。 產品設計的主要趨勢。此外，一些合作夥伴（遍布全球）的參與和新業務流程的挑戰也起著重要作用。 \n \n 16.1全球趨勢及其對機電一體化的影響 \n 近年來，一些機構已經對全球（巨型）趨勢進行了概述。它們在細節上彼此不同，但是主要的Top-ics參與了所有已發表的研究，如下所示： \n •人口變化（以及老齡化社會醫療系統） \n •流動性 \n •全球化（以及勞動世界、濟、融的變化） \n •城市化（和個性化） \n •氣候變化和環境變化（以及能源和資源、持續性） \n •智慧型社會（以及無所不在的情報、數位文化） \n \n 對於2030年的製造業生產，Westkämper討論了以下四個主要主題: \n •創新的產品和流程 \n •基於知識的製造工程 \n •產品生命週期中的新業務模型 \n •基礎設施和教育 \n \n 所有這些趨勢的結果也是該技術必須向前發展。 因此，如本書各章所述，由於多種學科的結合，機電一體化產品具有很高的產品開發潛力。 \n \xa0 經濟成功的主要部分是創新產品和工藝的開發。 術語創新包括新產品、服務或程序的發明、介紹和銷售。這不僅包括整個營銷過程，還包括社會和經濟影響。不論發明的質量如何，許多因素都會影響發明向創新的發展。在這種情況下討論的主要因素可以分為三類：技術、經濟和社會影響。 機電一體化領域是眾多創新的源泉。但是，大多數新發展都被認為是漸進式創新。在進行徹底創新的情況下，概念設計已被確定為產品設計中最關鍵的階段，因為成功的主要部分將在那裡建立。 \n \xa0 在此早期階段做出的決定會對產品的未來發展產生重大影響。因此，對於整個產品的系統級別的需求定義至關重要。在系統級別上定義的要求應反映客戶的意願。為了確保所考慮的系統滿足要求，有必要將它們轉換為解決方案的屬性。系統的開發融合了來自不同工程學科（例如機械工程、電氣工程、控制工程等）的解決方案。因此，區分只能在系統級別上確保的特性和可以通過以下方法保證的特性非常重要單一的工程學科。因此，必須將不同的屬性分配給相關級別。為了實現此任務模型，必須在不同的層次級別上進行（特定學科模型和系統模型）。從這個角度來看，考慮到的特定方面的建模、模擬、評估和優化是未來機電系統設計的關鍵，前面幾章也提到了這一點。 \n \n 16.2機電一體化未來地圖 \n 可以理解，不可能在一本書中討論機電一體化未來的所有方面。本書的目標是如何將挑戰歸類為主要主題，並從不同角度介紹具體方面。下面列出了常見的觀點，而 圖16.1 顯示了以下主題的地圖： \n •問題與挑戰 \n 機電系統未來發展的主要動力是減少開發成本和時間，以及使用新技術改進設計產品。這主要涉及產品的虛擬化，以改善其架構設計、驗證和確認、生產或運營。實際上，虛擬化可以以較低的成本在開發的不同階段提供更大的靈活性。設計產品與生產系統之間的交互在工業4.0（或智能製造、網絡物理生產系統等）的方向上起著重要作用。 \n •系統設計、建模和模擬 \n 機電一體化產品的結構更複雜，並且將具有更多的計算能力和網絡連接性。 這就導致了在理解複雜系統的困難方面面臨的擴展設計挑戰，其中模擬將是掌握這些困難的關鍵技術。機電系統設計過程的未來趨勢，方法和模型必須被認為是將復雜系統轉變為網絡物理系統或物聯網的全球集成的不可替代的推動力。這些用於機電工程的設計過程必須支持新服務的開發或為將來的工廠實施工業互聯網。 \n •製造技術 \n 物理創建機電設備和系統的未來技術（例如增材製造或增材製造）將為設計過程帶來新的可能性。 從 為組裝設計 方法到 直接製造 方法將發生轉變。 因此，我們無需再進行後期組裝和使用緊固件，從而可以快速生產堅固的設備。如今，典型示例包括3D打印傳感器、3D打印電子產品和集成多種材料，這是生產 完全集成產品的基礎機電設備 。 \n •物聯網和網絡物理系統 \n 機電一體化的當前趨勢涉及將計算和物理過程更深入地集成到網絡機電一體化系統，網絡物理系統（CPS）或物聯網（IoT）中。 因此，通信、集成和數據分析被認為是必不可少的，因為物聯網的範圍將取決於各種系統和標準的整合， 低層 （本地）系統相互通信而 高層 （全局）通信。系統典型的應用是自動化、生產、運輸、能源、醫療保健和農業。值得稱讚的潛在的社會和經濟利益是合理的，但尚未得到保證。 \n •通信和信息技術 \n 這裡的關鍵問題與促進建立多學科合作夥伴關係有關。 沒有這樣的伙伴關係，就很可能失去在產品設計和服務交付方面進行創新的機會。因此，建立穩健的伙伴關係工作形式的組織更有可能獲得競爭優勢。與此相關的是，需要建立一種新的方法來確保和管理用戶同意，同時確保如果用戶選擇退出數據共享，則不會造成經濟或功能上的不利影響。 \n 這反過來又引發了有關如何與法律/法學從業人員一起對技術人員進行教育和宣傳的問題，以便在開發、實施和應用新技術時滿足法律和社會要求。 \n •機電一體化教育 \n 機電一體化正朝著複雜物理組件的設計商品化的未來發展。特殊的挑戰是學科多樣性，因此機電一體化教育必須在 技術知識 、 基礎技術技能 和 個人技能 之間尋求平衡，任何教育計劃都應以支持這些領域為導向。機電一體化課程必須涵蓋的典型主題與產品生命週期保持一致，包括創新、創造力、系統思維、工程和集成，這些方法結合了基於項目和問題的學習方法。機電一體化教育便成為應用新技術的基礎。 \n \n 圖16.1 機電一體化未來地圖 \n', 'tags': '', 'url': 'MechaEducFutureNeed.html'}, {'title': 'CoppeliaSim', 'text': '\n 版本4.0.0 \n \n 具有集成開發環境的機器人模擬器CoppeliaSim基於分佈式控制體系結構：可以通過嵌入式腳本，插件，ROS節點，BlueZero節點，遠程API客戶端或自定義解決方案分別控制每個對象/模型。 這使CoppeliaSim非常通用，非常適合多機器人應用。 控制器可以用C / C ++，Python，Java，Lua，Matlab，Octave或Urbi編寫。 \n 以下只是CoppeliaSim的部分應用程序： \n \n \n 工廠自動化系統仿真 \n 遠程監控 \n 硬件控制 \n 快速原型製作和驗證 \n 安全監控 \n 快速算法開發 \n 機器人相關教育 \n 產品介紹 \n \n \n CoppeliaSim可以用作獨立應用程序，也可以輕鬆地嵌入到主客戶端應用程序中：它的佔用空間小且精心設計的API使CoppeliaSim成為嵌入更高級別應用程序的理想選擇。 集成的Lua腳本解釋器使CoppeliaSim成為了一種極其通用的應用程序，使用戶可以自由組合低級/高級功能以獲得新的高級功能。 \n 快速入門CoppeliaSim的一個好方法是先看一下 教程部分 。 \n 推薦主題 \n \n \n CoppeliaSim主要功能 \n CoppeliaSim版本歷史 \n 致謝和鳴謝 \n 講解 \n CoppeliaSim周圍的各種貢獻和外部資源 \n CoppeliaSim / V-REP論壇 \n \n \n \n', 'tags': '', 'url': 'CoppeliaSim.html'}, {'title': 'BubbleRob tutorial', 'text': '由40723210提供 \n 個人操作影片連結: https://youtu.be/BStp8J-KXuY \n 本教程將在設計簡單的移動機器人 BubbleRob 時嘗試介紹很多CoppeliaSim功能。與本教程相關的CoppeliaSim場景文件位於CoppeliaSim的安裝文件夾的 tutorials / BubbleRob 文件夾中。下圖說明了我們將設計的仿真場景： \n \n \n 由於本教程將跨越許多不同的方面，因此請確保也看看 其他教程 ，主要是 有關構建仿真模型 的 教程 。首先，重新啟動CoppeliaSim。模擬器顯示默認 場景 。我們將從 BubbleRob 的主體開始。 \n 我們使用[菜單欄->添加->基本形狀->球體]將直徑為0.2的基本球體添加到場景中。我們將X尺寸項目調整為0.2，然後點擊確定。默認情況下，創建的球體將顯示在 可見性層 \xa01中，並且是 動態且可響應的 （因為我們已啟用“\xa0創建動態且可響應的形狀\xa0”項）。這意味著 BubbleRob的 身體將掉落，並且能夠對與其他可響應形狀的碰撞做出反應（即，由物理引擎模擬）。我們可以看到這是 形狀動力學屬性 ：項目身體是可響應的，身體是動態的已啟用。我們開始模擬（通過工具欄按鈕，或在場景窗口中按<control-space>），然後復制並粘貼創建的球體（使用[菜單欄->編輯->複製所選對象]，然後[菜單欄->編輯->粘貼緩衝區]，或者先按<control-c>，再按<control-v>）：這兩個球將對碰撞做出反應並滾動。我們停止模擬：重複的球體將自動刪除。可以在 模擬對話框中 修改此默認行為。 \n 我們還希望 BubbleRob的 主體可以被其他計算模塊（例如 最小距離計算模塊 ）使用。因此，如果尚未啟用，則在該形狀的 對象公共屬性中 啟用 Collidable ， Measurable ， Renderable 和 Detectable 。如果需要，我們現在還可以在 形狀屬性中 更改球體的視覺外觀。 \n 現在，我們在“\xa0平移”選項卡上打開“\xa0 位置”對話框 ，選擇表示 BubbleRob 身體的球體，然後為“\xa0沿著Z”輸入0.02\xa0。我們確保將相對項設置為World。然後，單擊翻譯選擇。這會將所有選定對象沿絕對Z軸平移2 cm，並有效地將我們的球體抬高了一點。在 場景層次結構中 ，我們雙擊球體的名稱，以便我們可以編輯其名稱。我們輸入 bubbleRob ，然後按Enter。 \n 接下來，我們將添加一個 接近傳感器， 以便 BubbleRob 知道它何時接近障礙物：我們選擇[菜單欄->添加->接近傳感器->圓錐類型]。在方向選項卡上的 方向對話框中 ，我們為Y周圍和Z\xa0周圍輸入90\xa0，然後單擊旋轉選擇。在 位置對話框 的“\xa0位置”選項卡上，為X坐標輸入0.1\xa0。Z坐標為0.12\xa0。現在，接近傳感器已相對於 BubbleRob的 身體正確定位。我們在 場景層次中 雙擊接近傳感器的圖標 打開 其屬性 對話框。我們單擊顯示體積參數以打開 接近傳感器體積對話框 。我們將偏移量調整為0.005，角度調整為30，範圍調整為0.15。然後，在 接近傳感器屬性中 ，單擊顯示檢測參數。這將打開 接近傳感器檢測參數對話框 。如果距離小於則取消選中“不允許檢測”項，然後再次關閉該對話框。在場景層次結構中，我們雙擊接近傳感器的名稱，以便我們可以編輯其名稱。我們輸入 bubbleRob_sensingNose 並按回車鍵。 \n 我們選擇 bubbleRob_sensingNose ，然後 按住 \xa0Control鍵選擇 bubbleRob ，然後單擊[菜單欄->編輯->將最後選擇的對象設為父對象]。這會將傳感器連接到機器人的身體。我們也可以拖 bubbleRob_sensingNose 到 bubbleRob 在場景層次。這就是我們現在擁有的： \n \n [接近傳感器連接到 bubbleRob的 身體] \n 接下來，我們將照顧 BubbleRob的 車輪。我們使用[菜單欄->文件->新場景]創建一個新場景。跨多個場景工作通常非常方便，以便可視化並僅對特定元素進行工作。我們添加一個尺寸為（0.08,0.08,0.02）的純原始圓柱體。至於 BubbleRob 的主體，如果尚未啟用，則在該圓柱的 對象通用屬性中 啟用\xa0 Collidable ， Measurable ， Renderable 和 Detectable 。然後，將圓柱的絕對位置設置為（0.05,0.1,0.04），並將其絕對方向設置為（-90,0,0）。我們將名稱更改為 bubbleRob_leftWheel 。我們複製並粘貼滾輪，然後將復制的絕對Y坐標設置為-0.1。我們將副本重命名為 bubbleRob_rightWheel 。我們選擇兩個輪子，複製它們，然後切換回場景1，然後粘貼輪子。 \n 現在，我們需要為車輪添加 接頭 （或電動機）。我們單擊[菜單欄->添加->關節->旋轉]將旋轉關節添加到場景。在大多數情況下，將新對象添加到場景時，該對象將出現在世界的起源處。我們保持關節處於選中狀態，然後控制選擇 bubbleRob_leftWheel 。在“\xa0 位置”對話框 的“\xa0位置”選項卡上，單擊“\xa0應用到選擇”按鈕：這將關節定位在左輪的中心。然後，在“\xa0 方向”對話框 的“\xa0方向”選項卡上，執行相同的操作：這將關節與左輪定向的方向相同。我們將關節重命名為 bubbleRob_leftMotor 。現在，我們在場景層次中雙擊關節的圖標以打開 關節屬性 對話框。然後，單擊“\xa0顯示動態參數”以打開 關節動力學屬性 對話框。我們啟用電動機，並檢查項目“\xa0目標速度為零時鎖定電動機”。現在，我們對右馬達重複相同的過程，並將其重命名為 bubbleRob_rightMotor 。現在，我們將左輪連接到左馬達，將右輪連接到右馬達，然後將兩個馬達連接到 bubbleRob 。這就是我們所擁有的： \n \n [接近傳感器，電動機和車輪] \n 我們運行模擬，並註意到機器人向後倒下。我們仍然缺少與地板的第三個聯繫點。現在，我們添加一個小的滑塊（或腳輪）。在一個新的場景，我們並添加純原始球體直徑為0.05，讓球 可碰撞 ， 可衡量的 ， 可渲染 和 檢測的 （如果尚未啟用），然後將其重命名為 bubbleRob_slider 。我們在 形狀動力學屬性 中將Material設置為 noFrictionMaterial 。為了將滑塊與機器人的其餘部分牢固地鏈接在一起，我們使用[菜單欄->添加->力傳感器]\xa0添加了 力傳感器對象 。我們將其重命名為 bubbleRob_connection 並將其上移0.05。我們將滑塊連接到力傳感器，然後復制兩個對象，切換回場景1並粘貼它們。然後，我們將力傳感器沿絕對X軸移動-0.07，然後將其安裝到機器人主體上。如果現在運行模擬，我們會注意到滑塊相對於機器人主體略微移動：這是因為兩個對象（即 bubbleRob_slider 和 bubbleRob ）都相互碰撞。為了避免在動力學模擬過程中產生奇怪的影響，我們必須通知CoppeliaSim兩個對像不會相互碰撞，我們可以通過以下方式進行此操作：在 shape dynamics屬性中 ，為 bubbleRob_slider 設置了本地可響應蒙版設置為00001111，對於 bubbleRob ，我們將本地可響應掩碼設置為11110000。如果再次運行仿真，我們會注意到兩個對像不再乾涉。這就是我們現在擁有的： \n \n [接近傳感器，電機，車輪和滑塊] \n 我們再次運行仿真，發現即使在電機鎖定的情況下， BubbleRob也會 輕微移動。我們還嘗試使用不同的物理引擎運行仿真：結果將有所不同。動態仿真的穩定性與所涉及的非靜態形狀的質量和慣性緊密相關。有關此效果的說明，請務必仔細閱讀 本 節和 該 節。現在，我們嘗試糾正這種不良影響。我們選擇兩個輪子和滑塊，然後在“形狀動力學”對話框中單擊3次M = M * 2（用於選擇）。效果是所有選定形狀的質量都將乘以8。我們對3個選定形狀的慣性進行相同的操作，然後再次運行仿真：穩定性得到了改善。在關節動力學對話框中，我們將兩個電機的目標速度都設置為50。我們運行模擬： BubbleRob 現在向前移動並最終掉落在地板上。我們將兩個電機的目標速度項都重置為零。 \n 對象 bubbleRob 是所有以後將形成 BubbleRob\xa0 模型的 對象 的基礎。我們將在稍後定義模型。同時，我們要定義代表 BubbleRob 的對象的集合。為此，我們定義了一個 集合對象 。我們單擊[菜單欄->工具->集合]以打開 集合對話框 。或者，我們也可以通過單擊相應的工具欄按鈕來打開對話框： \n \n \n 在集合對話框中，點擊添加新集合。一個新的集合對像出現在下面的列表中。目前，新添加的集合仍為空（未定義）。在列表中選擇新的收藏項時，在場景層次中選擇 bubbleRob ，然後在收藏對話框中單擊“\xa0添加\xa0”。現在，我們的集合被定義為包含層次結構樹的所有對象（從 bubbleRob 對 像 開始）（集合的組成顯示在“\xa0組成元素和屬性”部分中）。要編輯集合名稱，請雙擊它，然後將其重命名為 bubbleRob_collection 。我們關閉收集對話框。 \n 在此階段，我們希望能夠跟踪BubbleRob與任何其他對象之間的最小距離。為此，我們使用[菜單欄->工具->計算模塊屬性]\xa0打開 距離對話框 。或者，我們也可以使用相應的工具欄按鈕打開計算模塊屬性對話框： \n \n \n 在距離對話框中，單擊添加新的距離對象，然後選擇一個距離對： [collection] bubbleRob_collection-場景中的所有其他可測量對象 。這只是添加了一個距離對象，該距離對象將測量集合 bubbleRob_collection （即該集合中的任何 可測量對象 ）與場景中任何其他可測量對象之間的最小距離。我們通過雙擊其名稱將距離對象重命名為 bubbleRob_distance 。我們關閉距離對話框。現在運行模擬時，我們看不到任何區別，因為距離對象將嘗試測量（並顯示） BubbleRob 之間的最小距離段 以及場景中的其他任何可測量對象。問題在於，在此階段，場景中沒有其他可測量的對象（定義地板的形狀默認情況下已禁用其可測量的屬性）。在本教程的後續階段，我們將為場景添加障礙。 \n 接下來，我們將向 BubbleRob 添加一個 圖形對象 ，以顯示最小距離以上的距離，同時還顯示 BubbleRob 隨時間 的 軌跡。我們單擊[菜單欄->添加->圖]並將其重命名為 bubbleRob_graph 。我們將圖形附加到 bubbleRob ，並將圖形的絕對坐標設置為（0,0,0.005）。現在，通過在場景層次結構中雙擊其圖標來打開 圖形屬性 對話框。我們取消選中“\xa0顯示XYZ平面”，然後單擊“\xa0添加新數據流”以進行記錄，然後選擇“\xa0對象：數據流類型的絕對x位置\xa0”\xa0和 bubbleRob_graph 用於記錄的對象/項目。數據流記錄列表中出現了一個項目。該項目是 bubbleRob_graph的 絕對X坐標的數據流（即，將記錄 bubbleRobGraph的 對象的絕對X位置）。現在，我們還想記錄y和z位置：我們以與上述類似的方式添加這些數據流。現在，我們有3個數據流，分別表示BubbleRob的x，y和z軌跡。我們將添加更多的數據流，使我們能夠跟踪我們的機器人與環境之間的最小距離：我們點擊添加新的數據流記錄，並選擇距離：段長度的數據流類型，並 bubbleRob_distance 用於記錄的對象/項目。在數據流記錄列表中，我們現在將Data重命名為bubbleRob_x_pos，將Data0重命名為bubbleRob_y_pos，將Data1重命名為bubbleRob_z_pos，將Data2重命名為bubbleRob_obstacle_dist。 \n 我們在“\xa0數據流”記錄列表中和“\xa0時間圖屬性”部分中選擇 bubbleRob_x_pos ，取消選中“\xa0可見”。我們對 bubbleRob_y_pos 和 bubbleRob_z_pos 都執行相同的 操作 。這樣，在時間圖中只能看到 bubbleRob_obstacle_dist 數據流。以下是我們應該擁有的： \n \n [圖形屬性] \n 接下來，我們將建立一個顯示 BubbleRob 軌蹟的3D曲線：單擊編輯3D曲線打開 XY圖和3D曲線對話框 ，然後單擊添加新曲線。在對話框彈出打開，我們選擇 bubbleRob_x_pos 為X-值項， bubbleRob_y_pos 為Y值項， bubbleRob_z_pos 的Z值項目。我們將新添加的曲線從 Curve 重命名為bubbleRob_path。最後，我們檢查“\xa0相對於世界”項目並將“\xa0曲線寬度”設置為4： \n \n [3D曲線屬性] \n \n 我們關閉與圖有關的所有對話框。現在我們將一個電機目標速度設置為50，運行模擬，然後將看到 BubbleRob的 軌跡顯示在場景中。然後，我們停止仿真並將電動機目標速度重置為零。 \n 我們添加具有以下尺寸的純原始圓柱體：（0.1，0.1，0.2）。我們希望此圓柱體是靜態的（即不受重力或碰撞的影響），但仍會對非靜態的可響應形狀施加一些碰撞響應。為此，我們在 形狀動力學屬性中 禁用“\xa0主體是動態的”\xa0。我們也希望我們的汽缸是\xa0 可碰撞 ， 可衡量的 ， 可渲染 和 檢測的 。我們在 對象的通用屬性中 執行此操作。現在，在仍選擇圓柱體的情況下，我們單擊對象平移工具欄按鈕： \n \n \n 現在我們可以拖動場景中的任何點：圓柱體將跟隨運動，同時始終受約束以保持相同的Z坐標。我們複製並粘貼圓柱幾次，然後將它們移動到 BubbleRob 周圍的 位置 （從頂部查看場景時執行該操作最方便）。在對象移動期間，按住Shift鍵可以執行較小的移動步驟。按住ctrl鍵可以在與 常規 方向正交的方向上移動。完成後，再次選擇相機平移工具欄按鈕： \n \n \n 我們將左馬達的目標速度設置為50並運行模擬：現在，圖形視圖顯示了到最近障礙物的距離，並且該距離段在場景中也可見。我們停止模擬並將目標速度重置為零。 \n 現在，我們需要完成BubbleRob作為 模型 定義。我們選擇模型庫（即對象 bubbleRob ），然後檢查項目Object是模型庫，並且Object / model可以轉移或接受 對象 共有 屬性 中的DNA：現在有一個點畫框，它包圍了模型層次結構中的所有對象。我們選擇兩個關節，即接近傳感器和圖形，然後啟用項目“不顯示為內部模型選擇”，然後在同一對話框中單擊“\xa0應用於選擇”：模型邊界框現在忽略了兩個關節和接近傳感器。仍在同一對話框中，我們禁用相機可見性圖層2，並為兩個關節和力傳感器啟用攝像機可見性層\xa010：這有效地隱藏了兩個關節和力傳感器，因為默認情況下禁用9-16層。任何時候我們都可以 修改整個場景的可見性層 。要完成模型定義，我們選擇視覺傳感器，兩個輪子，滑塊和圖形，然後啟用“\xa0選擇模型基礎”項：如果現在嘗試在場景中的模型中選擇一個對象，則將選擇整個模型，這是一種將整個模型作為單個對象進行處理和操作的便捷方法。此外，這可以防止模型受到意外修改。仍然可以通過在按住Shift的同時單擊選擇對像或在場景層次結構中正常選擇它們，來在場景中選擇模型中的單個對象。最後，我們將模型樹折疊到場景層次中。這就是我們所擁有的： \n \n [\xa0 BubbleRob 模型定義] \n 接下來，我們將在與 BubbleRob 接近傳感器相同的位置和方向上添加 視覺 傳感器。我們再次打開模型層次結構，然後單擊[菜單欄->添加->視覺傳感器->透視類型]，然後將視覺傳感器連接到接近傳感器，並將視覺傳感器的本地位置和方向設置為（0,0,0）。我們還確保視覺傳感器不可見，不是模型邊界框的一部分，並且如果單擊該模型，則會選擇模型。為了自定義視覺傳感器，我們打開 其屬性 對話框。我們將遠裁剪平面項設置為1，將分辨率x和分辨率y設置為 \xa0項目分別為256和256。我們向場景中添加了一個浮動視圖，然後在新添加的浮動視圖上，右鍵單擊[彈出菜單->視圖->將視圖與選定的視覺傳感器關聯]（我們確保視覺傳感器在該過程中被選中）。 \n 通過單擊[菜單欄->添加->關聯的子腳本->非線程]，將非線程子腳本附加到視覺傳感器。我們雙擊場景層次結構中視覺傳感器旁邊出現的小圖標：這將打開我們剛剛添加的子腳本。我們將以下代碼複製並粘貼到 腳本編輯器中 ，然後將其關閉： \n function sysCall_vision(inData)\n    simVision.sensorImgToWorkImg(inData.handle) -- copy the vision sensor image to the work image\n    simVision.edgeDetectionOnWorkImg(inData.handle,0.2) -- perform edge detection on the work image\n    simVision.workImgToSensorImg(inData.handle) -- copy the work image to the vision sensor image buffer\nend\n\nfunction sysCall_init()\nend \n 為了能夠看到視覺傳感器的圖像，我們開始模擬，然後再次停止。 \n 我們場景所需的最後一件事是一個小的 子腳本 ，它將控制 BubbleRob的 行為。我們選擇 bubbleRob 並單擊[菜單欄->添加->關聯的子腳本->非線程]。我們雙擊場景層次結構中 bubbleRob 名稱旁邊顯示的腳本圖標，然後將以下代碼複製並粘貼到 腳本編輯器中 ，然後將其關閉： \n function speedChange_callback(ui,id,newVal)\n    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction sysCall_init()\n    -- This is executed exactly once, the first time this script is executed\n    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self) -- this is bubbleRob\'s handle\n    leftMotor=sim.getObjectHandle("bubbleRob_leftMotor") -- Handle of the left motor\n    rightMotor=sim.getObjectHandle("bubbleRob_rightMotor") -- Handle of the right motor\n    noseSensor=sim.getObjectHandle("bubbleRob_sensingNose") -- Handle of the proximity sensor\n    minMaxSpeed={50*math.pi/180,300*math.pi/180} -- Min and max speeds for each motor\n    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode\n    -- Create the custom UI:\n        xml = \'<ui title="\'..sim.getObjectName(bubbleRobBase)..\' speed" closeable="false" resizeable="false" activate="false">\'..[[\n        <hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/>\n        <label text="" style="* {margin-left: 300px;}"/>\n        </ui>\n        ]]\n    ui=simUI.create(xml)\n    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5\n    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\nend\n\nfunction sysCall_actuation()\n    result=sim.readProximitySensor(noseSensor) -- Read the proximity sensor\n    -- If we detected something, we set the backward mode:\n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end \n\n    if (backUntilTime<sim.getSimulationTime()) then\n        -- When in forward mode, we simply move forward at the desired speed\n        sim.setJointTargetVelocity(leftMotor,speed)\n        sim.setJointTargetVelocity(rightMotor,speed)\n    else\n        -- When in backward mode, we simply backup in a curve at reduced speed\n        sim.setJointTargetVelocity(leftMotor,-speed/2)\n        sim.setJointTargetVelocity(rightMotor,-speed/8)\n    end\nend\n\nfunction sysCall_cleanup()\n\tsimUI.destroy(ui)\nend \n \n 我們運行模擬。 BubbleRob 現在在嘗試避開障礙物的同時向前移動（以非常基本的方式）。在模擬仍在運行時，更改 BubbleRob的 速度，然後將其複制/粘貼幾次。在模擬仍在運行時，也嘗試擴展其中的一些。請注意，根據環境的不同，最小距離計算功能可能會嚴重降低仿真速度。您可以通過選中/取消選中“\xa0啟用所有距離計算”項，在“\xa0 距離”對話框中 打開和關閉該功能。 \n 使用腳本控制機器人或模型只是一種方法。CoppeliaSim提供了許多不同的方法（也可以結合使用），請參閱 外部控制器教程 。 \n', 'tags': '', 'url': 'BubbleRob tutorial.html'}, {'title': 'Line following BubbleRob', 'text': '由40723210提供 \n 在本教程中，我們旨在擴展BubbleRob的功能，以使他/她遵循地面上的規則。確保您已完全閱讀並理解第 一個BubbleRob教程 。本教程由Eric Rohmer提供。 \n 在CoppeliaSim的安裝文件夾中的 tutorials / BubbleRob中 加載第一個BubbleRob教程的場景。與本教程相關的場景文件位於 tutorials / LineFollowingBubbleRob中 。下圖說明了我們將設計的仿真場景： \n \n \n 我們首先創建3個 視覺傳感器 中的第一個，並將其附加到 bubbleRob 對象。選擇[菜單欄->添加->視覺傳感器->正交類型]。雙擊 場景層次結構中 新創建的視覺傳感器圖標，編輯其屬性，然後更改參數以反映以下對話框： \n \n \n 視覺傳感器必鬚麵向地面，因此選擇它，然後在“\xa0 方向”對話框 的“\xa0方向”選項卡上，將“\xa0 Alpha \xa0-\xa0 Beta \xa0-\xa0 Gamma” 項設置為[180; 0; 0]\xa0。 \n 我們有幾種可能性可以讀取視覺傳感器。由於我們的視覺傳感器只有一個像素，並且操作簡單，因此我們只需查詢視覺傳感器讀取的圖像的平均強度值即可。對於更複雜的情況，我們可以設置 視覺回調函數 。現在，將視覺傳感器複製並粘貼兩次，並將其名稱調整為 leftSensor ， middleSensor 和 rightSensor 。將 bubbleRob設置為 其父級（ 即將 其附加到 bubbleRob 對象）。現在，您的傳感器在場景層次中應如下所示： \n \n \n 讓我們正確放置傳感器。對於使用 位置對話框 中，在位置選項卡，並設置以下的絕對坐標： \n \n \n 左傳感器：[0.2; 0.042; 0.018] \n 中間傳感器：[0.2; 0; 0.018] \n 右傳感器：[0.2; -0.042; 0.018] \n \n \n 現在讓我們修改環境。我們可以移去BubbleRob前面的幾個圓柱體。接下來，我們將構建機器人將嘗試遵循的 路徑 。現在最好切換到頂視圖：通過 頁面選擇器工具欄按鈕 選擇 頁面 \xa04\xa0。然後單擊[菜單欄->添加->路徑->圓圈類型]。 使用鼠標 啟用 對象移動 。您可以通過兩種方式調整路徑的形狀： \n \n \n 選擇路徑（並且只有路徑）後，按住Ctrl並單擊其 控制點之一 。然後可以將它們拖動到正確的位置。 \n 選擇路徑後，進入 路徑編輯模式 。在那裡，您可以靈活地調整各個路徑控制點。 \n \n \n 對路徑的幾何形狀滿意（您隨時可以在以後的階段對其進行修改）後，選擇它，然後取消選中 路徑屬性 中的“\xa0顯示點的方向”，“\xa0顯示路徑線”和“\xa0顯示路徑上的當前位置”。然後單擊“\xa0顯示路徑整形對話框”。這將打開 路徑整形對話框 。單擊“\xa0啟用路徑整形”，將類型設置為“\xa0水平線段”，然後將“\xa0縮放比例” 到4.0。最後將顏色調整為黑色。我們必須對路徑進行最後一個重要的調整：當前，路徑的z位置與地板的z位置重合。結果是有時我們會看到路徑，有時會看到地板（這種效果在openGl行話中被稱為“\xa0 z-fighting \xa0”）。這不僅影響我們所看到的，而且還會影響視覺傳感器所看到的。為了避免與z戰鬥有關的問題，只需將路徑對象的位置向上移動0.5毫米即可。 \n 最後一步是調整BubbleRob的控制器，使其也將遵循黑色路徑。打開附著於 bubbleRob 的 子腳本 ，並將其替換為以下代碼： \n function speedChange_callback(ui,id,newVal)\n    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction sysCall_init()\n    -- This is executed exactly once, the first time this script is executed\n    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self)\n    leftMotor=sim.getObjectHandle("leftMotor")\n    rightMotor=sim.getObjectHandle("rightMotor")\n    noseSensor=sim.getObjectHandle("sensingNose")\n    minMaxSpeed={50*math.pi/180,300*math.pi/180}\n    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode\n    floorSensorHandles={-1,-1,-1}\n    floorSensorHandles[1]=sim.getObjectHandle("leftSensor")\n    floorSensorHandles[2]=sim.getObjectHandle("middleSensor")\n    floorSensorHandles[3]=sim.getObjectHandle("rightSensor")\n    -- Create the custom UI:\n        xml = \'<ui title="\'..sim.getObjectName(bubbleRobBase)..\' speed" closeable="false" resizeable="false" activate="false">\'..[[\n        <hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/>\n        <label text="" style="* {margin-left: 300px;}"/>\n        </ui>\n        ]]\n    ui=simUI.reate(xml)\n    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5\n    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\nend\n\nfunction sysCall_actuation()\n    result=sim.readProximitySensor(noseSensor)\n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end\n\n    -- read the line detection sensors:\n    sensorReading={false,false,false}\n    for i=1,3,1 do\n        result,data=sim.readVisionSensor(floorSensorHandles[i])\n        if (result>=0) then\n            sensorReading[i]=(data[11]<0.3) -- data[11] is the average of intensity of the image\n        end\n        print(sensorReading[i])\n    end\n\n    -- compute left and right velocities to follow the detected line:\n    rightV=speed\n    leftV=speed\n    if sensorReading[1] then\n        leftV=0.03*speed\n    end\n    if sensorReading[3] then\n        rightV=0.03*speed\n    end\n    if sensorReading[1] and sensorReading[3] then\n        backUntilTime=sim.getSimulationTime()+2\n    end\n\n    if (backUntilTime<sim.getSimulationTime()) then\n        -- When in forward mode, we simply move forward at the desired speed\n        sim.setJointTargetVelocity(leftMotor,leftV)\n        sim.setJointTargetVelocity(rightMotor,rightV)\n    else\n        -- When in backward mode, we simply backup in a curve at reduced speed\n        sim.setJointTargetVelocity(leftMotor,-speed/2)\n        sim.setJointTargetVelocity(rightMotor,-speed/8)\n    end\nend\n\nfunction sysCall_cleanup()\n\tsimUI.destroy(ui)\nend \n \n 您可以輕鬆地調試以下視覺傳感器的生產線：選擇一個，然後在場景視圖中選擇[右鍵->添加->浮動視圖]，然後在新添加的浮動視圖中選擇[右鍵->視圖- ->將視圖與選定的視覺傳感器關聯]。 \n 最後，刪除在第 一個BubbleRob教程 中添加的輔助項：刪除圖像處理視覺傳感器及其關聯的浮動視圖，該浮動視圖表示障礙物的清除。通過 距離對話框 也刪除距離計算對象。而已！ \n', 'tags': '', 'url': 'Line following BubbleRob.html'}, {'title': 'External controller tutorial', 'text': "由40723210提供 \n 在CoppeliaSim中，有幾種方法可以控制機器人或仿真： \n \n The most convenient way is to write a \xa0 child script \xa0 that will handle the behaviour of a given robot or \xa0 model . It is the most convenient way, because child scripts are directly attached to \xa0 scene objects , they will be duplicated together with their associated scene objects, they do not need any compilation with an external tool, they can run in \xa0 threaded \xa0 or \xa0 non-threaded \xa0 mode, they can be extended via \xa0 custom Lua function \xa0 or via a \xa0 Lua extension library . Another major advantage in using child scripts: there is no communication lag as with the last 3 methods mentioned in this section (i.e. the \xa0 regular API \xa0 is used), and child scripts are part of the application main thread (inherent synchronous operation). There are several drawback to writing scripts however: you don't have the choice of the programming language, you can't have the fastest code, and you can't directly access external function libraries, except the Lua extension libraries. \n \n \n \n 最方便的方法是編寫一個 子腳本 ，以處理給定機器人或 模型 的行為 。 這是最便捷的方式，因為孩子的腳本直接連接到 場景中的對象 ，他們將與它們相關的場景對象進行複製，他們不需要任何編譯與外部的工具，它們可以在運行 線程 還是 非線程 模式，可以通過 自定義Lua函數 或 Lua擴展庫對其進行擴展 。 使用子腳本的另一個主要優點：與本節中提到的後三種方法（即 常規API） 一樣，沒有通信延遲 ，並且子腳本是應用程序主線程的一部分（固有的同步操作）。 但是，編寫腳本有幾個缺點：您無法選擇編程語言，不能擁有最快的代碼，並且除了Lua擴展庫之外，您無法直接訪問外部函數庫。 \n \n \n Another way one can control a robot or a simulation is by writing a \xa0 plugin . The plugin mechanism allows for callback mechanisms, \xa0 custom Lua function registration , and of course access to external function libraries. A plugin is often used in conjunction with child scripts (e.g. the plugin registers custom Lua functions, that, when called from a child script, will call back a specific plugin function). A major advantage in using plugins is also that there is no communication lag as with the last 3 methods mentioned in this section (i.e. the \xa0 regular API \xa0 is used), and that a plugin is part of the application main thread (inherent synchronous operation). The drawbacks with plugins are: they are more complicated to program, and they need to be compiled with an external too. Refer also to the \xa0 plugin tutorial . \n \n \n 可以控制機器人或模擬的另一種方法是編寫 插件 。 插件機制允許回調機制， 自定義Lua函數註冊 ，當然還可以訪問外部函數庫。 插件通常與子腳本結合使用（例如，插件註冊自定義Lua函數，當從子腳本中調用時，該Lua函數將回調特定的插件函數）。 使用插件的一個主要優點是，與本節中提到的後3種方法（即 常規API） 一樣，沒有通信延遲 （使用），並且插件是應用程序主線程的一部分（固有的同步操作）。 插件的缺點是：它們的編程更加複雜，並且也需要使用外部編譯。 另請參閱 插件教程 。 \n \n \n A third and forth way one can control a robot or a simulation is by writing an external client application that relies on the \xa0 remote API . This is a very convenient and easy way, if you need to run the control code from an external application, from a robot or from another computer. This also allows you to control a simulation or a \xa0 model \xa0 (e.g. a virtual robot) with the exact same code as the one that runs the real robot. The remote API comes in two versions: the \xa0 B0-based remote API , and the \xa0 legacy remote API . \n \n \n 控制機器人或模擬的第三種方式是編寫依賴於 遠程API 的外部客戶端應用程序 。 如果您需要從外部應用程序，機器人或另一台計算機運行控制代碼，這是一種非常便捷的方法。 這還允許您 使用與運行真實機器人完全相同的代碼 來控制仿真或 模型 （例如，虛擬機器人）。 遠程API有兩個版本： 基於B0的遠程API 和 舊版遠程API 。 \n \n \n A fifth way to control a robot or a simulation is via a \xa0 ROS \xa0 node. In a similar way as the \xa0 remote API , ROS is a convenient way to have several distributed processes communicate with each other. While the remote API is very lightweight and fast, it allows only communication with CoppeliaSim. ROS on the other hand allows connecting virtually any number of processes with each other, and a large amount of compatible libraries are available. It is however heavier and more complicated than the remote API. Refer to the \xa0 ROS interfaces \xa0 for details. \n \n \n 控制機器人或仿真的第五種方法是通過 ROS 節點。 ROS \xa0 與 遠程API 相似 ，是使多個分佈式進程相互通信的便捷方法。 儘管遠程API非常輕巧且快速，但它僅允許與CoppeliaSim通信。 另一方面，ROS允許幾乎將任意數量的進程相互連接，並且提供了大量兼容的庫。 但是，它比遠程API重並且更複雜。 有關詳細信息， 請參閱 ROS接口 。 \n \n \n A sixth way to control a robot or a simulation is via a \xa0 BlueZero \xa0 (BØ) node. In a similar way as ROS, BlueZero is a convenient way to have several distributed processes communicate with each other, and is a lightweight and cross-platform solution. Refer to the \xa0 BlueZero interface \xa0 for details. \n \n \n 控制機器人或模擬的第六種方法是通過 BlueZero （BØ）節點。 與ROS類似，BlueZero是使多個分佈式進程相互通信的一種便捷方法，並且是一種輕量級的跨平台解決方案。 有關詳細信息， 請參考 BlueZero界面 。 \n \n \n A seventh way to control a robot or a simulation is by writing an external application that communicates via various means (e.g. pipes, sockets, serial port, etc.) with a CoppeliaSim plugin or CoppeliaSim script. Two major advantages are the choice of programming language, which can be just any language, and the flexibility. Here also, the control code can run on a robot, or a different computer. This way of controlling a simulation or a model is however more tedious that the methods with the \xa0 remote API . \n \n \n 控制機器人或模擬的第七種方法是編寫一個外部應用程序，該應用程序通過各種方式（例如管道，套接字，串行端口等）與CoppeliaSim插件或CoppeliaSim腳本進行通信。 選擇編程語言（可以是任何一種語言）和靈活性是兩個主要優點。 同樣，控制代碼也可以在機器人或其他計算機上運行。 但是，與使用 遠程API 的方法相比，這種控制仿真或模型的方法更加乏味 。 \n \n \n 有8個與本教程相關的場景文件： \n \n scenes/controlTypeExamples/controlledViaScript : one robot is controlled via a \xa0 non-threaded child script , the other is controlled via a \xa0 threaded child script . \n scenes/controlTypeExamples/controlledViaPlugin : the robot is controlled via a \xa0 plugin . \n scenes/controlTypeExamples/controlledViaB0RemoteApi : the robot is controlled via the \xa0 B0-based remote API . \n scenes/controlTypeExamples/controlledViaLegacyRemoteApi : the robot is controlled via the \xa0 legacy remote API . \n scenes/controlTypeExamples/controlledViaB0 : the robot is controlled via the \xa0 BlueZero interface . \n scenes/controlTypeExamples/controlledViaRos : the robot is controlled via the \xa0 ROS interface . \n scenes/controlTypeExamples/controlledViaRos2 : the robot is controlled via the \xa0 ROS2 interface . \n scenes/controlTypeExamples/controlledViaTcp : the robot is controlled via \xa0 LuaSocket \xa0 and TCP. \n \n \n \n \n scenes/controlTypeExamples/controlledViaScript : 一個機器人通過控制 非螺紋子腳本 ，另一種是通過受控的 螺紋子腳本 。 \n scenes/controlTypeExamples/controlledViaPlugin ：機器人是通過 插件 控制的 。 \n scenes/controlTypeExamples/controlledViaB0RemoteApi ：通過 基於B0的遠程API 來控制機器人 。 \n scenes/controlTypeExamples/controlledViaLegacyRemoteApi ：通過 舊版遠程API 控制機器人 。 \n scenes/controlTypeExamples/controlledViaB0 ：通過 BlueZero界面 控制機器人 。 \n scenes/controlTypeExamples/controlledViaRos ：通過 ROS接口 控制機器人 。 \n cenes/controlTypeExamples/controlledViaRos2 ：通過 ROS2接口 控制機器人 。 \n scenes/controlTypeExamples/controlledViaTcp ：機器人是通過 LuaSocket 和TCP \xa0 控制的 。 \n \n \n 在所有8種情況下， 都使用 子腳本 ，主要是為了與外界建立鏈接（例如，啟動正確的客戶端應用程序，並將正確的對象句柄傳遞給它）。 有兩種方法可以控制機器人，仿真程序或仿真程序本身：通過使用 自定義腳本 或 加載項 。 但是，不建議將它們用於控制，而應在不運行模擬時將其用於處理功能。 \n 例如，鏈接到場景 控制 的ViaB0RemoteApi.ttt中的機器人的子腳本 具有以下主要任務： \n \n 使用某些對象句柄作為參數 啟動控制器應用程序（ bubbleRobClient_b0RemoteApi ）。 基於對象B0的遠程API的服務器功能由對象 b0RemoteApiServer 提供 。 \n \n 作為另一個示例，鏈接到場景 控制 的ViaRos.ttt中的機器人的子腳本 具有以下主要任務： \n \n 檢查是否 已加載CoppeliaSim \xa0 的 ROS接口 \n 使用某些主題名稱或對象句柄作為參數 啟動控制器應用程序（ rosBubbleRob ） \n \n 然而，作為另一個示例，鏈接到場景 控制 的ViaTcp.ttt中的機器人的子腳本 具有以下主要任務： \n \n 搜索空閒的套接字連接端口 \n 使用所選的連接端口作為參數 啟動控制器應用程序（ bubbleRobServer ） \n 本地連接到控制器應用程序 \n 在每次仿真過程中，將傳感器值發送到控制器，並從控制器讀取所需的電機值 \n 在每次模擬過程中，將所需的電機值應用於機器人的關節 \n \n 運行模擬，然後復制並粘貼機器人：您將看到重複的機器人將直接運行，因為附加的子腳本負責啟動各自外部應用程序的新實例，或調用適當的插件函數。 \n", 'tags': '', 'url': 'External controller tutorial.html'}, {'title': 'Simulation', 'text': '由40723210提供 \n 可以使用[菜單欄->模擬->開始/暫停/停止模擬]或通過相關的工具欄按鈕來啟動，暫停和停止CoppeliaSim中的模擬： \n \n [模擬開始/暫停/停止工具欄按鈕] \n 在內部，模擬器將使用其他中間狀態，以正確告知 腳本 或程序接下來將發生的情況。 以下狀態圖說明了模擬器的內部狀態： \n \n [模擬狀態圖] \n 腳本和程序應始終根據當前系統調用功能以及可能的 模擬狀態進行反應 ，以便正確運行。 優良作法是將每個控制代碼分成至少4個系統調用函數（例如，用於 非線程子腳本 ）： \n \n \n 初始化函數 ： sysCall_init ：僅在腳本初始化時才調用該函數。 \n 激勵 函數 ： sysCall_actuation ：應在發生激勵時調用該函數。 \n Sensing函數 ： sysCall_sensing ：應在發生傳感時調用此函數。 \n 清理函數 ： sysCall_cleanup ：在取消初始化腳本之前（例如，在模擬結束時或銷毀腳本時）調用該函數。 \n \n \n 有關如何安排典型腳本的示例，請參考 main腳本 ， 子腳本 和 自定義腳本 頁面。 \n 仿真循環 \n 模擬器通過以恆定的時間步長推進模擬時間來進行操作。 下圖說明了主要的仿真循環： \n \n [主仿真循環] \n 通過嘗試使仿真時間與實時保持同步來支持實時仿真： \n \n [實時仿真循環] \n 以下是一個非常簡化的 主客戶端應用程序 （ 為清晰起見，已省略了 消息， 插件 處理和其他詳細信息）： \n void initializationCallback\n{\n    // do some initialization here\n}\n\nvoid loopCallback\n{\n    if ( (simGetSimulationState()&sim_simulation_advancing)!=0 )\n    {\n        if ( (simGetRealTimeSimulation()!=1)||(simIsRealTimeSimulationStepNeeded()==1) )\n        {\n            if ((simHandleMainScript()&sim_script_main_script_not_called)==0)\n                simAdvanceSimulationByOneStep();\n        }\n    }\n}\n\nvoid deinitializationCallback\n{\n    // do some clean-up here\n} \n 取決於仿真的複雜性，計算機的性能和 仿真設置 ，實時仿真可能並不總是可能的。 \n 仿真速度 \n 在非實時仿真中，仿真速度（即感知速度）主要取決於兩個因素：仿真時間步長和一個渲染通道的仿真通道數量（ 有關更多詳細信息， 請參見 仿真對話框 ）。 在實時仿真的情況下，仿真速度主要取決於實時乘法係數，而且在一定程度上取決於仿真時間步長（太小的仿真時間步長可能與實時時間不兼容）。由於計算機的計算能力有限，因此無法進行仿真。 在模擬過程中，可以使用以下工具欄按鈕來調整模擬速度： \n \n [模擬速度調整工具欄按鈕] \n 以某種方式調整模擬速度，以使初始模擬時間步長永遠不會增加（例如，這可能因此而導致機制中斷）。 以下兩個圖說明了仿真速度調整機制： \n \n [ \xa0 非實時 模擬的模擬速度調整機制 ] \n \n \n [用於 實時 仿真的仿真速度調整機制 ] \n 默認情況下，每個模擬週期由以下 順序 操作 組成 ： \n \n \n 執行 主腳本 \n 渲染場景 \n \n 螺紋渲染 \n \n 渲染操作將始終增加仿真週期的持續時間，從而也降低了仿真速度。 可以定義每個場景渲染的主腳本執行次數（請參閱後面的內容），但這在某些情況下還不夠，因為渲染仍然會減慢每個第x個模擬週期的時間（這可能會限制實時性）。 在這種情況下，可以通過 用戶設置 或以下工具欄按鈕 激活線程渲染模式 ： \n \n [線程渲染工具欄按鈕] \n 激活線程渲染模式後，模擬週期將僅包括執行 主腳本 ，因此模擬將以最大速度運行。 渲染將通過不同的線程進行，並且不會減慢模擬任務的速度。 然而，必須考慮缺點。 激活線程渲染後，： \n \n \n 渲染將與模擬循環異步進行，並且可能會出現視覺故障 \n 該 錄像機 將不以恆定速度運轉（某些幀可能會跳過） \n 應用程序的穩定性可能會降低 \n 某些操作（例如擦除對像等）需要等待渲染線程完成工作才能執行，反之亦然。 在那些情況下，循環可能比順序渲染模式花費更多的時間。 \n \n \n', 'tags': '', 'url': 'Simulation.html'}, {'title': 'Simulation dialog', 'text': '由40723210提供 \n 可以通過[菜單欄->模擬->模擬設置]或單擊以下工具欄按鈕來訪問模擬對話框： \n \n [模擬工具欄按鈕] \n \n [模擬設置對話框] \n \n 時間步 ： 模擬 時間步。 每次 執行 主腳本 時，仿真時間都會增加仿真時間步長。 使用較大的時間步會導致快速但不准確/不穩定的仿真。 另一方面，較小的時間步長（通常）會導致更精確的仿真，但是會花費更多時間。 強烈建議保留默認時間步長。 \n 每幀模擬遍數（ppf） ：一個渲染遍的模擬遍數。 值為10表示刷新屏幕之前，主腳本已執行10次（10個模擬步驟）。 如果您的圖形卡較慢，則可以選擇僅顯示兩幅中的一幅。 \n 當仿真時間高於時暫停 ：允許指定仿真時間，在該時間暫停仿真（例如，能夠在特定仿真時間分析某些結果）。 \n 暫停腳本錯誤 ：如果啟用，則在發生 腳本 錯誤時 將暫停仿真 。 \n 模擬開始時全屏 ：如果啟用，則模擬以全屏模式開始。 請注意，在全屏模式下，對話框和消息將不會出現或不可見，只有鼠標左鍵處於活動狀態。 因此，僅在正確配置場景並最終確定場景後才建議使用該模式。 可以使用esc鍵保留全屏模式，並 在仿真過程中 通過 布爾參數 \xa0 sim_booparam_fullscreen 進行 切換 \xa0 。 Unler Linux和MacOS可能僅部分支持全屏模式，並且在某些系統上切換回普通模式可能會失敗。 \n 實時仿真，倍增係數 ：如果選擇，則仿真時間將嘗試跟隨實時。 X的乘數將使仿真運行比實時快X倍。 \n 落後時嘗試趕上 ：在實時仿真過程中，仿真時間可能無法實時跟踪（例如，由於某些瞬間繁重的計算）。 在這種情況下，如果選中此復選框，則模擬時間將嘗試趕上損失的時間（例如，當計算負載再次減少時），這會明顯提高速度。 \n 復位場景初始狀態 ：當被選擇時，那麼所有 的對象 將被復位到它們的初始狀態：包括對象的本地位置，局部方向和它的父（只要該對象沒有另外修飾的（例如縮放））， 關節 以及 路徑的 固有位置，浮動 視圖 位置和大小等。這意味著除非進行了重大更改（ 形狀 縮放，對象移除等） ，否則下一次模擬運行將以與上一次相同的方式執行 。 此項目將忽略一些次要設置。 \n 刪除新對象 ：選中該選項後，在仿真運行期間添加的場景對象將在仿真結束時被刪除。 \n \n', 'tags': '', 'url': 'Simulation dialog.html'}, {'title': 'Webots Tutorial', 'text': '首先 Webots是一個具備建模、程式設計和模擬移動機器人開發平臺，主要用於地面機器人模擬。使用者可以在一個共享的環境中設計多種複雜的異構機器人，可以自定義環境大小，環境中所有物體的屬性包括形狀、顏色、文字、質量、功能等也都可由使用者來進行自由配置，它使用ODE檢測物體碰撞和模擬剛性結構的動力學特性，可以精確的模擬物體速度、慣性和摩擦力等物理屬性。每個機器人可以裝配大量可供選擇的模擬感測器和驅動器，機器人的控制器可以通過內部整合化開發環境或者第三方開發環境進行程式設計，機器人每個行為都可以在真實世界中測試。 \n Webots Tutorial-1 \n 1.創建一個新目錄和世界，都要改名子。 \n 2.開始設定地板的格子與外牆的高度。 \n 3.加入一個木箱並且調整大小和高度。 \n 4.複製出三個木箱並且移動到牆角，儲存世界。 \n 5.再來要添加一台e-puck機器，儲存後模擬。 \n 6.使用alt+左鍵拖移，來測試施加外力狀況。 \n 7.設定木箱的物理重量，才能夠施加外力。 \n 8.創建控制器程式(python)，名子一樣要改。 \n 9.修改程式碼後，更改e-puck的controllers。 \n 10.完成後儲存，即可照著腳本進行移動。 \n 我的操作影片(有字幕): https://youtu.be/zINF95Z_b1s \n \n \n \n \n Webots Tutorial-2 \n 1.另存一個新的檔案。 2.創建一個新地板場景和實體球。 3.設定其形狀、位置以及參數。 4.更改球體大小以及命名。 5.將邊界物體訂為剛命名的。 6.創建四面牆壁，儲存並測試。 \n 我的操作影片(有字幕): https://youtu.be/bE5tuK2tLBU \n \n \n Webots Tutorial-3 \n 1.另存一個新的檔案。 2.更改四個牆壁的顏色及參數。 3.準備 將球的外觀做改變。 4. 設定所要圖案的路徑，儲存。 5.再來測試 渲染模式即可。 \n 我的操作影片(有字幕): https://youtu.be/d25DXY8W_rU \n \n \n Webots Tutorial-4 \n 1.一樣先建立新的檔案。 2.創建一個python程式檔。 3.將控制改為現在的程式檔。 4.將教材給的程式複製貼上。 5.儲存之後即可開始模擬。 6.機器會緩慢的閃避障礙物。 \n 我的操作影片(有字幕): https://youtu.be/7zeqP98Y2ek \n \n \n Webots Tutorial-5 \n 1.另存一個新的檔案。 2.新增實體 在創建連趕及三個型體。 3.設定好三個的形狀、大小及參數。 4.調整位子、 重量、密度和 質心位置。 5.將物體 方向轉正，提 高位置。 6.設置啞鈴沒有摩擦力，儲存即可。 \n 我的操作影片(有字幕): https://youtu.be/iJBotPDJ5ME \n \n \n Webots Tutorial-6 \n 1.一樣另存一個新的檔案。 2.刪掉其他東西，只留牆壁和地板。 3.創建一個robot， 將實體加上去。 4. 新增一個身體和四個輪子，命名。 5.調整全部的參數、實體 位置和軸位置。 6. 添加感應器， 調整大小和位置。 7.x軸方向要向外，角度是0.3 rad。 8.創建一個 python控制器，命名儲存。 9.更改robot的控制器，選擇剛建的。 10.提高robot的高度， 模擬測試即可。 \n 我的操作影片(有字幕): https://youtu.be/vxuzuLsOoUs \n \n', 'tags': '', 'url': 'Webots Tutorial.html'}, {'title': 'User Interface', 'text': 'Webots GUI由四個主要窗口組成： 顯示並允許您與3D模擬進行交互 的 3D窗口 ， 表示當前世界的層次結構 的“ \xa0 場景樹” ，允許您編輯源代碼 的“ \xa0 文本”編輯器 ，以及最後， 同時顯示編譯和控制器輸出 的 控制台 。 \n \n Webots GUI \n \n GUI有九個菜單： File, Edit, View, Simulation, Build, Overlays, Tools, Wizards 和 Help 。 \n 文件菜單 \n “ \xa0 文件” 菜單允許您執行常規的文件操作：加載，保存等。 \n \n \n 所述 新世界 菜單項目（和按鈕）中只含有模擬窗打開一個新的世界 ElevationGrid ，顯示為10×10平方1米×1米的表面上的棋盤。 \n \n \n “ \xa0 打開世界...” 菜單項（和按鈕）打開一個文件選擇對話框，該對話框允許您選擇要加載的“ .wbt”文件。 \n \n \n 通過“ \xa0 打開最近的世界” 菜單項，可以從子菜單中顯示的列表中選擇一個最近打開的“ .wbt”文件，以重新打開該文件。 \n \n \n “ \xa0 打開示例世界” 菜單項將打開一個對話框，列出所有可用的示例世界，在其中可以通過在搜索字段中輸入文件名或其中的一部分來搜索要加載的特定“ .wbt”文件。 \n \n \n “ \xa0 保存世界” 菜單項（和按鈕）使用當前文件名（顯示在主窗口頂部的文件名）保存當前世界。 在每個 Save .wbt文件的內容上都將被覆蓋，Webots不會創建任何備份副本，因此，您應謹慎使用此按鈕，並最終手動進行安全副本。 \n \n \n “ \xa0 另存為...” 菜單項（和按鈕）使用用戶輸入的新文件名保存當前世界。 請注意，“。wbt”文件應始終保存在Webots項目目錄以及“ worlds”子目錄中，否則將無法重新打開該文件。 \n \n \n “ \xa0 重新加載世界” 菜單項（和按鈕）從已保存的版本重新加載當前世界，並從頭開始重新進行仿真。 \n \n 注意 ：打開（或重新加載）世界時，如果世界花費了2秒鐘以上的時間來加載窗口，則會彈出窗口並顯示進度。 使用此窗口可以取消加載世界，在這種情況下，將打開空白世界。 \n \n \n \n 所述 復位仿真 菜單項目（和按鈕）恢復模擬的初始狀態。 仿真並沒有像重新加載一樣完全被破壞和重建，但是所有節點的初始狀態都得以恢復，這要快得多。 \n \n 注意 ：為了重置模擬，執行以下步驟： \n \n 模擬時間設置為00:00:00 \n 仿真期間添加的所有節點都將被刪除。 \n 所有聲源均已停止。 \n Webots內部使用的隨機種子將被重置。 \n 重置所有節點。 根據節點類型，這具有以下含義： \n 剎車 ：剎車被釋放。 \n Charger ： 恢復 第一個 \xa0 Shape 子節點 的 battery 字段和 \xa0 Material 節點 的 emissiveColor 字段 。 \n 連接器 ：如果已連接，則分離連接器，並 isLocked 恢復 該 字段 的值 。 \n 顯示 ：圖像被清除。 \n 發射 器 \xa0 / \xa0 接收器 ：消息隊列已清除。 \n 關節 \xa0 / \xa0 電機 ：位置，速度，加速度，可用扭矩和可用力將恢復。 \n LED ：如果第一個子節點是Light節點，則其 color 字段將恢復並關閉。 如果第一個子 節點 是 \xa0 Shape 節點，則將 還原 emissiveColor 其 \xa0 Material 節點 的 字段 。 \n 激光雷達 ：恢復旋轉頭的位置。 \n 筆 ：清除所有繪製的紋理。 \n 螺旋槳 ：慢速螺旋線及其初始位置已恢復。 \n 機械手 ： battery 還原字段，刪除所有主管標籤，還原節點可見性，並重新啟動控制器。 \n 穩定 ： translation 和 rotation 字段被恢復，物理場被重置。 \n Track ：還原電動機位置，並且還原 第一個 \xa0 Shape 子節點 translation 的 \xa0 Appearance 節點 的textureTransform節點 的 字段 。 \n 觀點 ： orientation 和 position 字段已還原。 \n \n \n \n \n “ \xa0 新建文本文件” 菜單項（和按鈕）在文本編輯器中打開一個空文本文件。 \n \n \n “ \xa0 打開文本文件...” 菜單項（和按鈕）打開一個文件選擇對話框，該對話框允許您選擇要加載的文本文件（例如“ .java”文件）。 \n \n \n “ \xa0 保存文本文件” 菜單項（和按鈕）將保存當前文本文件。 \n \n \n “ \xa0 將文本文件另存為...” 菜單項（和按鈕）使用用戶輸入的新文件名保存當前文本文件。 \n \n \n 將 保存所有文本文件 菜單項保存所有打開的和未保存的文本文件。 \n \n \n “ \xa0 還原文本文件” 菜單項（和按鈕）從保存的版本中重新加載文本文件。 \n \n \n “ \xa0 打印預覽...” 菜單項打開一個窗口，可讓您管理頁面佈局，以便從文本編輯器中打印文件。 \n \n \n “ \xa0 打印...” 菜單項打開一個窗口，使您可以打印文本編輯器的當前文件。 \n \n \n 在 導入VRML97 ... 菜單項，在現場樹的末尾添加VRML97對象。 這些對象來自您必須指定的VRML97文件。 此功能對於導入在3D建模程序中建模的複雜形狀，然後導出到VRML97（以前稱為VRML 2.0）非常有用。 大多數3D建模軟件，例如3D Studio Max，Maya，AutoCAD，Pro Engineer，AC3D或Art Of Illusion，都包含VRML97（或VRML 2.0）導出功能。 請注意，Webots無法以VRML 1.0格式導入文件。 導入後，這些對象 將在場景樹的底部 顯示為 Group ， Transform 或 Shape 節點。 然後，您可以將這些對象轉換為Webots節點（例如 Solid ， Robot 等），或將它們剪切並粘貼到 children 現有Webots節點列表中。 \n \n \n 該 出口VRML97 ... 項目讓您當前載入世界保存為“.WRL”的文件，符合VRML97標準。 反過來，可以使用任何VRML97查看器和大多數3D建模軟件打開此類文件。 \n \n \n 使用 “截取屏幕截圖...” 項可以截取Webots中當前視圖的截屏。 它會打開一個文件對話框，將當前視圖另存為PNG或JPG圖像。 \n \n \n 在 製作電影... 項允許你創建MPEG電影（Linux和MacOS）或AVI動畫（Windows）中。 電影錄製開始後，將在中更改此項 Stop Movie... 。 在錄製期間，可以更改運行模式並暫停模擬。 但是，僅在Webots步驟期間捕獲幀，而在暫停模擬時不捕獲。 除了選擇影片的分辨率和壓縮質量外，還可以通過設置動畫來以加速模式或慢動作記錄模擬。 Video acceleration 彈出對話框中的值。 如果視頻加速度值小於1，則錄製的動畫將比模擬慢。 最大減慢速度，即最小加速度值，是由模擬的基本時間步長定義的，因為不可能以比模擬更新率更高的幀率進行記錄。 為了增加最大的減慢速度，您應該減少仿真的基本時間步長。 選中視頻字幕選項將在電影的右上角顯示加速度值。 \n \n \n \n “製作電影...”對話框 \n \n \n \n “ \xa0 導出HTML5模型...” 項允許您將當前世界導出為交互式3D“ .html”文件。 您可以在 本節中 獲得有關此主題的更多信息 。 \n \n \n “ \xa0 製作HTML5動畫...” 項使您可以將模擬記錄為3D動畫並將其發佈在HTML5網頁上。 開始動畫錄製後，此項目將更改為 Stop HTML5 Animation... ，可用於停止動畫錄製。 您可以在 本節中 獲得有關此主題的更多信息 。 \n \n \n 退出將 終止當前的模擬並關閉Webot。 \n \n \n \n 注意： 在Windows上，使用“退出”代替“退出”。 \n \n 編輯菜單 \n “ \xa0 編輯” 菜單提供了常用的文本編輯功能，可操縱在“ \xa0 文本”編輯器中 打開的 文件 ，例如“複製”，“粘貼”，“剪切”等。 \n 查看菜單 \n 使用“ \xa0 查看” 菜單可以控制模擬窗口中的查看。 \n \n \n 的 跟隨對象 子菜單可固定的（靜態）視點和跟隨移動對象（通常是一個機器人）的視點之間切換。 如果希望視點跟隨對象，則首先需要用鼠標選擇對象，然後根據所需的以下行為檢查子菜單中的一項。 有關不同以下行為的更多信息， 請參考 Viewpoint 文檔。 \n \n \n 加載或還原文件後， “ \xa0 還原 視點” 項會將視點的位置和方向恢復為其初始設置。 當您在場景中導航時迷路並想要返回原始視點時，此功能非常方便。 \n \n \n \xa0 將視點移至對象 會將視點移至中心並在選定節點上縮放。 如果所選項目是字段，則將定位上級父節點。 該對象將位於3D視圖的中心，並且將完全可見。 \n \n \n 在 更改視圖 子菜單移動視點對準它在任何所選擇的對象周圍的世界六大對齊軸。 如果未選擇任何對象，則視點將以世界原點為中心。 可用的選項為 \xa0 前視圖 ， \xa0 後視圖 ， \xa0 左視圖 ， \xa0 右視圖 ， \xa0 頂視圖 和 \xa0 底視圖 。 \n \n \n “ \xa0 全屏” 項啟用和禁用在整個屏幕上顯示3D窗口。 \n \n \n 該 虛擬現實耳機 子菜單允許你使用虛擬現實的耳機，如HTC萬歲或Oculus Rift以查看模擬： \n \n 將 啟用 選項允許你切換模擬視圖耳機。 \n “ \xa0 跟踪頭戴式耳機位置” 和“ \xa0 跟踪頭戴式耳機方向” 項目指定是否應跟踪頭戴式耳機的位置和方向並將其應用於視點。 \n “ \xa0 查看左眼” ，“ \xa0 查看右眼” 和“ \xa0 空視圖” 單選按鈕使您可以選擇在模擬視圖中應顯示的內容。 您可以看到左眼圖像，右眼圖像或什麼都看不到。 \n 使用“ \xa0 抗鋸齒” 項可以在兩隻眼睛的圖像上啟用抗鋸齒（請注意，抗鋸齒會降低仿真速度）。 \n 此處 介紹耳機的安裝過程 。 \n \n \n 注意 ：此菜單當前僅在Windows上存在。 如果您在Windows上並且未啟用菜單，則表明未安裝驅動程序或未連接耳機。 \n \n \n \n 通過“ \xa0 投影” 單選按鈕組，可以在“ \xa0 透視投影” （默認）和“ \xa0 Webots模擬”窗口的“ \xa0 正投影” 模式 之間進行選擇 。 該 透視 模式對應於天然投影：其中所述更遠的對象是從觀察者，較小它出現在圖像中。 使用 正交 投影時，與查看者的距離不會影響物體的大小。 此外，在 正交 模式下，模型中平行的線在屏幕上平行繪製，因此，此投影有時在建模階段很有用。 在 正交 模式下 不會渲染陰影 。 \n \n \n “ \xa0 渲染” 單選按鈕組使您可以在“ \xa0 普通渲染” （默認）和“ \xa0 Webots模擬” \xa0 的“ \xa0 線框” 模式 之間進行選擇 。 在 普通渲染 模式下，對像以其幾何面，材質，顏色和紋理進行渲染，其方式與通常用眼睛或照相機看到的方式相同。 在 線框渲染 模式下，只有可呈現圖元的段被渲染。 此模式對於調試網格很有用。 如果 線框渲染 模式和 View / Optional Rendering / Show All Bounding Objects 切換按鈕均被激活，則僅繪製邊界對象（不渲染可渲染圖元）。 這可用於調試衝突檢測問題。 \n \n \n 在 可選的渲染 子菜單，可以顯示或隱藏，補充信息。 這些渲染僅顯示在主渲染中，並隱藏在機器人攝像機中。 它們用於更好地了解模擬的行為： \n \n \n 使用“ \xa0 顯示坐標系”， 可以將3D窗口右下角的全局坐標系顯示或隱藏為分別代表x，y和z軸的紅色，綠色和藍色箭頭。 \n \n \n 使用“ \xa0 顯示所有邊界對象”， 可以顯示或隱藏所有邊界對象（在 每個 Solid 節點 的 boundingObject 字段中 定義 ）。 邊界對象由白線表示。 當發生碰撞時，這些線變為玫瑰，而當實體處於空閒狀態（即，它靜止不與任何其他活動的實體相互作用）時，這些線變為藍色。 \n \n \n “ \xa0 顯示接觸點” 使您可以顯示或隱藏由碰撞檢測引擎生成的接觸點。 沒有示出沒有產生相應的接觸力的接觸點。 接觸力僅對使用物理模擬的對像生成（ 需要 物理 節點）。 需要考慮此操作的步驟。 \n \n \n 使用 顯示連接器軸 可以顯示或隱藏連接器軸。 旋轉對齊方式顯示為黑色，而y和z軸分別顯示為綠色和藍色。 \n \n \n 使用“ \xa0 顯示關節軸” 可以顯示或隱藏關節軸。 關節軸用黑線表示。 \n \n \n 所述 顯示測距儀平截頭體 ，可以顯示或隱藏，OpenGL的平截頭體剔除和場景中的每個測距儀所記錄的圖像，使用黃色線框。 如果測距儀設備被禁用或第一張圖像尚不可用，則視錐將以灰色繪製。 OpenGL剔除視錐是與測距儀視場相對應的截頂金字塔。 記錄的圖像顯示在視錐台所描述的平面上，其距離對應於距設備中心的測距儀的最小範圍。 有關此概念的更多信息，請參見OpenGL文檔。 \n \n \n 使用“ \xa0 顯示激光雷達路徑” ，您可以使用青色線框顯示或隱藏場景中每個激光雷達的圖層（激光射線路徑）。 如果禁用了激光雷達設備或尚無法進行第一次測量，則將這些層繪製為灰色。 \n \n \n 該 展會激光雷達點雲 ，可以顯示或隱藏，對於每一個激光雷達點雲點雲模式下啟用的場景。 點雲由這些點本身的位置以及從激光雷達原點到這些點的光線（從藍色（頂層）到紅色（底層）的漸變）表示。 這種可選的渲染在計算上很昂貴，因此會大大降低仿真速度。 請注意，如果點雲包含超過2500個點，則不會顯示從激光雷達原點到該點的射線。 \n \n \n “ \xa0 顯示攝像機視錐” 允許您使用洋紅色線框顯示或隱藏場景中每個攝像機的OpenGL消隱視錐和記錄的圖像。 如果禁用了相機設備或第一張圖像尚不可用，則視錐將以灰色繪製。 OpenGL剔除視錐是與攝像機視場相對應的截頂金字塔。 由於遠端平面設置為無窮大，因此未顯示金字塔的背面。 記錄的圖像顯示在相機的近平面上。 有關此概念的更多信息，請參見OpenGL文檔。 \n \n \n 所述 顯示DistanceSensor射線 ，可以顯示或隱藏，光線由距離傳感器設備鑄造。 這些光線繪製為紅線（在碰撞點之外變為綠色）。 它們的長度對應於設備的最大範圍。 如果距離傳感器設備被禁用或尚無法進行第一次測量，則光線將以灰色繪製。 \n \n \n 所述 顯示LightSensor射線 ，可以顯示或隱藏，光線鑄造由光傳感器裝置。 這些射線繪製為黃線。 如果禁用了光傳感器設備或尚無法進行第一次測量，則光線將以灰色繪製。 \n \n \n “ \xa0 顯示光位置” 允許您顯示或隱藏 PointLight 和 SpotLight 燈 的位置 。 \xa0 沒有顯示 DirectionalLight 節點。 \xa0 PointLight 和 SpotLight 節點由被耀斑圍繞的彩色圓圈表示。 \n \n \n “ \xa0 顯示筆繪畫射線” 使您可以顯示或隱藏筆設備繪畫的射線。 如果啟用繪畫，這些光線將繪製為紫線，否則繪製為灰線。 \n \n \n “ \xa0 顯示雷達視錐” 允許您顯示或隱藏雷達視錐。 如果啟用了雷達設備，則視錐表將顯示為藍色，否則，如果禁用了雷達或尚無法進行首次測量，則視錐表將顯示為灰色。 雷達視錐表代表雷達可以在其中檢測目標的體積。 \n \n \n “ \xa0 顯示重心” 使您可以顯示或隱藏具有非NULL \xa0 物理 節點 的選定實體的全局重心 。 重心呈深藍色。 \n \n \n “ \xa0 顯示浮力中心” 使您可以顯示或隱藏具有非NULL \xa0 物理 節點 的選定實體的整體浮力中心 。 浮力中心以紫色渲染。 \n \n \n 使用 顯示支撐多邊形， 可以顯示或隱藏具有非NULL \xa0 物理 節點 的選定實體的支撐多邊形 。 所謂支撐多邊形，是指實體的接觸點的凸包在水平平面上的投影，該平麵包含最低的多邊形。 此外，如果質心在後面的平面中的投影位於支撐多邊形內（靜態平衡），則呈綠色，否則呈紅色。 此渲染選項僅可用於頂部沒有其他實體的實體。 \n \n \n \n \n 如果 啟用 了“ \xa0 禁用選擇” 選項，則它會阻止您在單擊3D窗口時更改所選的實體節點。 當您要更改視點而不修改場景樹中的可見字段和選定字段時，這在建模階段特別有用。 \n \n \n 如果 啟用 了“ \xa0 鎖定視點” 選項，則可以阻止您 在3D窗口上拖動鼠標或移動鼠標滾輪時 更改“ \xa0 視點” 節點 的位置和方向 。 當您不想意外更改視點的位置和方向時，此功能特別有用。 \n \n \n \n 注意 ：“按 對象” ，“按 對象和旋轉” ，“ \xa0 投影” ，“ \xa0 渲染” ，“ \xa0 可選渲染項目” ，“ \xa0 禁用選擇” 和“ \xa0 鎖定視點” 選項按每個世界保存，而其他選項為全局。 \n \n 模擬菜單 \n 該 模擬 菜單用於控制模擬模式。 \n \n \n 在 暫停 菜單項（和按鈕）暫停仿真。 \n \n \n “ \xa0 步驟” 菜單項（和按鈕）執行模擬的一個基本時間步。 該步驟的持續時間 在 WorldInfo 節點 的 basicTimeStep 字段中 定義 ，可以在場景樹窗口中進行調整以滿足您的需求。 \n \n \n 該 實時 菜單項（和按鈕），直到它被中斷運行在實時仿真 Pause 或 Step 。 在運行模式下，場景的3D顯示每 n個 基本時間步 刷新一次 ，其中 n displayRefresh 在 WorldInfo 節點 的 字段中 定義 。 \n \n \n “ \xa0 運行” 菜單項（和按鈕）類似於 Real-time ，除了它運行得盡可能快。 \n \n \n 的 快速 菜單項目（和按鈕）是一樣 Run ，不同的是沒有圖形渲染被執行。 由於禁用了圖形渲染（黑屏），因此可以加快仿真速度，因此非常適合CPU密集型仿真（遺傳算法，視覺，學習等）。 \n \n \n 構建菜單 \n 在 生成 菜單提供的功能，以編譯（或交叉編譯）控制器的代碼。 此處 將更詳細地描述構建菜單 。 \n 疊加菜單 \n “ \xa0 覆蓋” 菜單提供特定於渲染設備覆蓋的操作（“ \xa0 相機” ，“ \xa0 顯示” ，“” \xa0 Rangefinder ）。 僅當在3D窗口中選擇了機械手或模擬中只有一個機械手時，此菜單的某些操作才有效： \n \n \n “ \xa0 攝像機設備” 子菜單包含所選機器人及其後代機器人的所有攝像機設備的列表，並允許用戶通過選中或取消選中相應項目來顯示或隱藏單個攝像機覆蓋圖像。 相機覆蓋層與顯示覆蓋層不同，因為它們具有洋紅色邊框。 請注意，如果 Hide All Camera Overlays 選中 該 項目，則與 Camera Devices 菜單項 的狀態無關，攝像頭設備的疊加層在3D視圖中將不可見 。 一 Camera Devices ，如果在外部窗口通過雙擊它顯示的疊加層的紋理菜單項將被禁用。 \n \n \n 所述 測距儀設備 子菜單包含所有選定的機器人的測距儀設備和其後代機器人的列表，並讓用戶顯示或隱藏由選中或取消選中相應的項的單測距儀的疊加圖像。 測距儀疊加層與照相機疊加層不同，因為它們具有黃色邊框。 請注意，如果 Hide All RangeFinder Overlays 選中 該 項目，則與 RangeFinder Devices 菜單項 的狀態無關，在3D視圖中將不會顯示測距儀設備覆蓋圖 。 一 RangeFinder Devices ，如果在外部窗口通過雙擊它顯示的疊加層的紋理菜單項將被禁用。 \n \n \n 所述 顯示設備 的子菜單包含所選機器人的所有的顯示設備和其後代機器人的列表，並讓通過檢查或取消選中相應的項目的用戶顯示或隱藏單個顯示疊加圖像。 顯示覆蓋圖與相機覆蓋圖不同，因為其青色邊框。 請注意，如果 Hide All Display Overlays 選中 該 項目，則顯示設備覆蓋圖在3D視圖中將不可見，而與 Display Devices 菜單項 的狀態無關 。 一 Display Devices ，如果在外部窗口通過雙擊它顯示的疊加層的紋理菜單項將被禁用。 \n \n \n 另一方面，以下各項始終處於活動狀態，並適用於世界上所有的機器人： \n \n \n “ \xa0 隱藏所有攝像機覆蓋物” 選項可獨立於 Camera Devices 子菜單中 設置的特定機器人設備選項，在3D視圖中隱藏所有攝像機設備覆蓋物 。 \n \n \n “ \xa0 隱藏所有RangeFinder疊加層” 選項獨立於 RangeFinder Devices 子菜單中 設置的特定機器人的設備選項，在3D視圖中隱藏所有相機設備的疊加層 。 \n \n \n “ \xa0 隱藏所有顯示覆蓋圖” 選項可獨立於 Display Devices 子菜單中 設置的特定機器人的設備選項，隱藏3D視圖中的所有顯示設備覆蓋圖 。 \n \n \n 工具菜單 \n 在 工具 菜單可以打開各種Webots窗口。 \n \n \n 在 3D視圖 菜單項顯示或隱藏3D窗口，並允許您與3D模擬互動。 \n \n \n 該 場景樹 菜單項打開 Scene Tree ，可以在其中編輯虛擬世界的窗口。 或者，也可以雙擊主窗口中的某些對象：這將自動打開“場景樹”，並選擇相應的對象。 \n \n \n 在 文本編輯器 菜單項打開Webots文本編輯器。 該編輯器可用於編輯和編譯控制器源代碼。 \n \n \n “ \xa0 控制台” 菜單項將打開“ Webots控制台”，這是一個只讀控制台，用於顯示Webots錯誤消息和控制器輸出。 \n \n \n “ \xa0 文檔” 菜單項顯示或隱藏脫機“ Webots”文檔窗口。 \n \n \n “ \xa0 還原佈局” 菜單項可還原主窗口面板的出廠佈局。 \n \n \n 該 清除控制台 菜單項清除控制台。 \n \n \n “ \xa0 編輯物理插件” 菜單項將在文本編輯器中打開 物理插件 的源代碼。 \n \n \n “ \xa0 首選項” 項將彈出 本節中 描述的窗口 。 \n \n \n 嚮導菜單 \n 該 嚮導 菜單可以更容易地創建新的項目和新的控制器。 \n \n \n “ \xa0 新建項目目錄...” 菜單項首先提示您選擇文件系統位置，然後創建一個項目目錄。 項目目錄包含幾個子目錄，這些子目錄用於存儲與特定Webots項目相關的文件，即世界文件，控制器文件，數據文件，插件等。Webots會記住當前項目目錄，並自動從中打開並保存任何類型的文件。當前項目目錄的相應子目錄。 \n \n \n “ \xa0 New Robot Controller ...” 菜單項允許您創建新的控制器程序。 首先將提示您在C，C ++，Java，Python或 MATLAB \xa0 TM 控制器 之間進行選擇 。 如果您在Windows上選擇C或C ++，Webots將為您提供創建Makefile / gcc項目或Visual Studio項目的可能性。 然後，Webots將要求您輸入控制器的名稱，最後它將在當前項目目錄中創建所有必需的文件（包括模板源代碼文件）。 \n \n \n “ \xa0 新建物理插件...” 菜單項將使您可以為項目創建新的物理插件。 Webots要求您選擇一種編程語言（C或C ++）和新的物理插件的名稱。 然後，它將在當前項目中創建目錄，模板源代碼文件和Makefile。 \n \n \n 幫助菜單 \n 使用“ \xa0 幫助” 菜單可以更輕鬆地訪問文檔，支持和常規信息。 \n \n \n “ \xa0 關於...” 項將打開一個 About... 顯示許可證信息 的 窗口。 \n \n \n “ \xa0 Webots導覽...” 菜單項啟動了一個導覽，通過一系列示例演示了Webots的功能。 \n \n \n “ \xa0 檢查更新...” 項會彈出一個窗口，通知正在使用的Webots版本是否為最新版本，並在需要時提供下載最新版本的鏈接。 \n \n \n 在 OpenGL的信息... 菜單項，為您提供有關當前OpenGL硬件和驅動程序的信息。 它可以用於診斷渲染問題。 \n \n \n 其餘菜單項以HTML頁面，PDF文檔等形式顯示各種信息。 \n 主工具欄 \n 主工具欄包含用於添加新節點對世界的按鈕，速度表（見本 節 ）和快捷方式的項目 File ， Simulation 和 View 菜單。 \n \n \n \xa0 隱藏/顯示場景樹 ：顯示或隱藏場景樹，並因此調整3D窗口的大小。 \n \n \n \xa0 添加 ：添加節點或對象。 對於節點，這會觸發一個對話框，使您可以從列表中選擇節點類型。 將使用默認值創建新節點，之後可以對其進行修改。 您只能插入適合相應字段的節點。 該對話框還可以通過單擊 導入... 按鈕 來加載先前導出的節點 。 有關如何導出節點的更多信息，請參見 此處 。 \n \n \n 車速表和虛擬時間 \n 速度計（請參見下 圖 ）指示計算機上模擬的速度。 它顯示在主工具欄上，並指示仿真與實時相比運行的速度。 換句話說，它代表虛擬時間的速度。 如果速度計的值為2，則意味著您的計算機仿真的運行速度是相應真實機器人的兩倍。 此信息在 Run 模式和 Fast 模式下 均有效 。 注意：在逐步模式下運行模擬時，不會顯示模擬速度（ N/A 而是顯示）。 \n \n 車速表 \n \n 在速度表的左側， 使用以下格式顯示 虛擬時間 ： \n H:MM:SS:MMM\n \n 其中 H 是小時數（可以是幾位數字）， MM 是分鐘數， SS 是秒數， MMM 是毫秒數（請參見此 圖 ）。 如果車速表的值大於1，則虛擬時間的進度要快於實時時間。 \n 可以 在場景樹窗口 basicTimeStep 的 WorldInfo 節點 的 字段中 設置模擬的基本時間步長 。 它以虛擬時間毫秒錶示。 該時間步長的值定義了在 Step 模式 期間執行的時間步長 。 此步驟乘以 displayRefresh 同一 WorldInfo 節點 的 字段， 以定義刷新顯示的頻率。 \n', 'tags': '', 'url': 'User Interface.html'}, {'title': 'Scene Tree', 'text': '如上一節所述，要訪問“場景樹窗口”，可以 Scene Tree 在 Tools 菜單中選擇，也可以按 Show Scene Tree 主工具欄中的按鈕。場景樹包含描述模擬世界（包括機器人和環境）及其圖形表示的信息。Webots的場景樹的結構類似於VRML97文件。它由節點列表組成，每個節點包含字段。字段可以包含值（文本字符串，數字值）或其他節點。 \n 本節描述了“場景樹”的用戶界面，並概述了VRML97節點和Webots節點。 \n \n 場景樹窗口 \n \n 場景樹具有上下文菜單，該上下文菜單包含許多有用的操作，具體取決於選擇，包括但不限於：剪切，複製和粘貼操作，將字段重置為其默認值，將 視點 移至對象，設置 視點 跟隨對象，或打開文檔查看器以查看所選節點的文檔。 \n 此外，如果當前選擇是 Robot 節點（或後代，或 PROTO 基於 Robot的 實例 ），則可以在文本編輯器中打開相應的機器人窗口或打開機器人的控制器。 \n 現場編輯 \n 可以雙擊擴展節點。 選擇字段後，可以在“場景樹”的底部編輯其值。 雙擊或按 Enter 字段上 的 鍵將選擇字段編輯器面板的第一個可編輯項目。 可以通過在字段編輯器面板中的所有項目之間切換來將鍵盤焦點返回到“場景樹”。 對於文本字段，通過按鍵應用更改 Enter 。 這對於數字字段是相同的，但是向上和向下箭頭鍵也可以用於向上和向下調整值，並立即應用更改。 對於復選框，使用 Space 欄 更改值 。 應用的更改將立即反映在3D窗口中。 字段編輯器部分提供以下按鈕： \n \n Webots節點編輯器 \n \n \n \n 顯示調整大小手柄 ：顯示用於調整大小和縮放3D窗口中選定節點的手柄。 僅對“幾何”節點和“ \xa0 變換” 節點 派生的節點顯示此選項 。 對於過程性PROTO節點，僅當在模板語句中未使用調整大小或縮放所涉及的字段時才可用。 \n \n', 'tags': '', 'url': 'Scene Tree.html'}]};